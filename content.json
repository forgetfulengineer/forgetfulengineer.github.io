{"posts":[{"title":"【PHP】4種判斷變數或陣列是否存在的方法","text":"本篇重點 使用 empty()、is_null()、isset() 或是直接使用if ($variable) 判斷式來判斷變數或陣列是否存在 資料檢查甚麼時候會有錯誤訊息(php error) 先了解這些會幫助你更快理解唷😁 【PHP】解析邏輯運算子 and、or、&amp;&amp;、|| 之間的差異 在開發動態網頁時，後端程式扮演了一個重要的角色，可能會處理來自前端程式的資料，也有可能處理來自資料庫的資料，在這種情況下，我們必須嚴謹地檢查數據的完整性，以確保後續的程式能夠順暢運行。那麼有哪些函數能夠進行這樣的檢查？ 首先先了解各種類型的判斷，判斷的類型有 無效值(null) 布林值(boolean) 字串(string) 數值(integer) 陣列(array) 判斷差異表比較不同的function在各種情況下的判斷 型態 if ($x) empty() isset() is_null() $x = null null false true false true $x is undefined null false true false true $x = true boolean true false true false $x = false boolean false true true false $x = ‘’ string false true true false $x = ‘1’ string true false true false $x = ‘0’ string false true true false $x = ‘-1’ string true false true false $x = ‘hello’ string true false true false $x = ‘true’ string true false true false $x = ‘false’ string true false true false $x = 1 integer true false true false $x = 0 integer false true true false $x = -1 integer true false true false $x = 666 integer true false true false $x = array() array false true true false $x = array(‘a’, ‘b’) array true false true false if ($x) 和 empty() 的判斷結果相反 isset() 和 is_null() 的判斷結果相反 螢光標記是我覺得特別要注意的判斷結果 範例 用戶填寫表格資料並送出資料，這些資料會從前端傳到後端程式，此時我們需要驗證是否有填入資料或是資料是否正確 php12345678&lt;?php// 使用 isset() 搭配 intval() 確認是否有參數傳入且為大於 0 的數值$age = isset($_POST['age']) &amp;&amp; intval($_POST['age']) &gt; 0 ? intval($_POST['age']) : 0;// 初步整理 $age 值後，檢查是否需要返回前端重新填寫年齡if ($age == 0) { // 返回前端請用戶重新填寫年齡} 情境一，填寫年齡 30 傳入後端，isset() 為 true，且 intval() 後數值大於零，$age = 30 往下接續處理 情境二，填寫年齡 0 傳入後端，isset() 為 true，但 intval() 後數值等於零，$age = 0 返回前端處理 情境三，無填寫年齡傳入後端，isset() 為 false，$age = 0 返回前端處理 健忘筆記 ? : 是一種條件運算符，稱為 三元運算符，可以用來做因果判斷 動手做做看 前端資料傳入後端後做資料檢查 情境一，填寫年齡 30 傳入後端，isset() 為 true，且 intval() 後數值大於零，$age = 30 往下接續處理情境二，填寫年齡 0 傳入後端，isset() 為 true，但 intval() 後數值等於零，$age = 0 返回前端處理情境三，無填寫年齡傳入後端，isset() 為 false，$age = 0 返回前端處理 動手做做看 從資料庫撈取資料，並檢測是否有資料，如果為無資料需要做處理 情境一，從資料庫撈取會員資訊，並取得完整資料 php12345678910111213141516171819&lt;?php$user_data = array( 'name' =&gt; '小明', 'gender' =&gt; 'Male',);// 使用 if (!$user_data) 確認變數內是否有資料if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 false，原本 if ($user_data) 為 true，但碰到驚嘆號反轉布林值結果，因此為 false 跳過判斷// 使用 !is_array($user_data) 搭配 empty($user_data) 確認變數內是否有資料if (!is_array($user_data) || empty($user_data)) { // 無資料時的處理}// 結果：!is_array($user_data) 為 false，empty($user_data) 也為 false，因此跳過判斷 動手做做看 情境一，從資料庫撈取會員資訊，並取得完整資料 資料檢查1：if (!$user_data) 判斷為 false，原本 if ($user_data) 為 true，但碰到驚嘆號反轉布林值結果，因此為 false 跳過判斷資料檢查2：!is_array($user_data) 為 false，empty($user_data) 也為 false，因此跳過判斷 動手做做看 情境二，從資料庫撈取會員資訊，但沒有撈到資料寫入空陣列 php12345678910111213141516&lt;?php$user_data = array();// 使用 if (!$user_data) 確認變數內是否有資料if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 true 進入無資料處理// 使用 !is_array($user_data) 搭配 empty($user_data) 確認變數內是否有資料if (!is_array($user_data) || empty($user_data)) { // 無資料時的處理}// 結果：!is_array($user_data)為 false，但 empty($user_data) 為 true，因此進入無資料處理 動手做做看 情境二，從資料庫撈取會員資訊，但沒有撈到資料寫入空陣列 資料檢查1：if (!$user_data) 判斷為 true 進入無資料處理資料檢查2：!is_array($user_data)為 false，但 empty($user_data) 為 true，因此進入無資料處理 動手做做看 情境三，從資料庫撈取會員資訊，但沒有撈到資料寫入字串 php1234567891011121314&lt;?php$user_data = 'no_data';if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 false 跳過判斷if (!is_array($user_data) || empty($user_data)) { // !is_array()為 true，因此進入無資料處理 // 無資料時的處理}// 結果：!is_array($user_data) 判斷為 true，因此進入無資料處理 健忘筆記 如果查找資料庫，沒有取得資料會寫入 array 以外的型態，那使用 !is_array($x) 搭配 empty() 來檢查資料會是更謹慎的做法 動手做做看 情境三，從資料庫撈取會員資訊，但沒有撈到資料寫入字串 資料檢查1：if (!$user_data) 判斷為 false 跳過判斷資料檢查2：!is_array($user_data) 判斷為 true，因此進入無資料處理 動手做做看 錯誤訊息在進行資料完整性檢查時，要確保資料的完整性，但又不希望出現錯誤訊息，那麼應該採用哪種函數? 這四種驗證方式除了兩兩相反外，還有一個很重要的差異 “錯誤訊息” 也就是PHP error。當變數 $x 沒有被賦值時，使用 if ($x) 和 is_null($x) 會引發錯誤訊息，但使用 isset($x) 和 empty($x) 不會，不過這些錯誤屬於較輕微的 E_NOTICE 級別，所以在沒有開啟PHP的所有錯誤提示的情況下是不會對網頁造成影響，但還是應該盡量處理這些錯誤。 範例 情境一，檢查陣列中不存在的索引 php12345&lt;?php$a = [];var_dump($a[1]); // NULL，錯誤訊息 Notice: Undefined offset: 1var_dump(isset($a[1])); // bool(false)，無錯誤訊息 $a 設定為一個空陣列，卻指定不存在的索引1，因此在 var_dump($a[1]) 的情況下會出現錯誤訊息 動手做做看 情境一，檢查陣列中不存在的索引 $a 設定為一個空陣列，卻指定不存在的索引1，因此在 var_dump($a[1]) 的情況下會出現錯誤訊息 動手做做看 情境二，判斷不存在的變數 php1234&lt;?php// $b 沒有被賦值var_dump(is_null($b)); // bool(true)，Notice: Undefined variable: b var_dump(empty($b)); // bool(true)，無錯誤訊息 $b 沒有被賦值，因此在 is_null($b) 的情況下會出現錯誤訊息。 動手做做看 情境二，檢查不存在的變數 $b 沒有被賦值，因此在 is_null($b) 的情況下會出現錯誤訊息 動手做做看 情境三，有個陣列內的值需要做處理，但這個值不一定存在，如果不存在就不需要處理 php123456789101112131415161718192021222324252627282930&lt;?php// 如果$user內沒有'age'$user = array( 'name' =&gt; '小明');if ($user['age']) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：出現錯誤訊息 Notice: Undefined index: age 並跳出判斷，'adult'沒有寫入資料// 為了不跳出錯誤訊息且正常判斷，可以改成!empty($user['age'])if (!empty($user['age'])) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：無錯誤訊息跳出判斷// 如果$user內有'age'$user = array( 'name' =&gt; '小明', 'age' =&gt; 10);if (!empty($user['age'])) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：!empty($user['age'])判斷為true，$user['adult'] 寫入 false 判斷用戶是否成年，而 $user 內 ‘age’ 的值不一定存在，因此需要檢查 ‘age’ 是否存在再做處理 健忘筆記 在不確定資料內部狀況的情況下，可以使用 empty() 來讓錯誤訊息消失 動手做做看 情境三，有個陣列內的值需要做處理，但這個值不一定存在，如果不存在就不需要處理 資料檢查1：出現錯誤訊息 Notice: Undefined index: age 並跳出判斷，'adult'沒有寫入資料資料檢查2：無錯誤訊息跳出判斷資料檢查3：!empty($user['age'])判斷為true，$user['adult'] 寫入 false 動手做做看 結論依不同的需求，使用function 來判斷變數或陣列的完整性。 if ($x) 和 empty($x) 的判斷結果相反 isset($x) 和 is_null($x) 的判斷結果相反 無設定 $x 值的狀況下 if ($x) 和 is_null($x) 會跳錯誤訊息 isset($x) 和 empty($x) 則不會跳錯誤訊息 檢查完整性可以減少 bug 的發生，不用修 bug 就是開心😆～ 你平常會檢查變數或陣列的資料完整性嗎? 是用甚麼方法處理呢? 歡迎留言跟大家分享！ 動手做做看 PHP 線上編輯器 參考資料 【官方文件】PHP類型比較表 延伸閱讀 【官方文件】資料類型的介紹 【官方文件】判斷式(if)介紹 【官方文件】布林值false的定義 【官方文件】PHP error 介紹","link":"/Backend/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/"},{"title":"【VSCode】在 VSCode terminal 使用 git bash","text":"本篇重點 為什麼要使用 git bash VSCode terminal 選項新增 git bash 將 git bash 設定為 VSCode 的預設終端機 我本身是使用 Windows 系統，為了熟悉 Linux 環境和 Git 的相關指令，嘗試了一些方法 虛擬環境 - VirtualBox、docker windows 子系統 - WSL git for windows - git bash 剛開始是使用 VirtualBox 創建 ubuntu 來熟悉 linux 的指令，後來覺得每次都要啟動虛擬機很麻煩，最後選擇 git bash 來在本機實做。 為什麼要使用 git bash在 windows 環境下： 可以使用大部分的 linux 系統指令，例如 ls、cp、mv、rm 等 可以使用 git 版本控制工具 無須安裝虛擬機或 Windows 子系統 在 VSCode terminal 新增 git bash 選項一直都是有需要使用 git 的時候才叫出 git bash 執行指令，但這樣其實有點麻煩，而且還需要不斷切換視窗。 隨著對 VSCode 的了解，才知道 VSCode 有內建 terminal，windows 預設的 terminal 是 cmd 或是 powersell。接下來會把 git bash 設定到 VSCode 的 terminal 選項，這樣就可以直接在 VSCode 中使用了！ 1. 開啟 VSCode 設定檔 (JSON檔)方法一、使用快捷鍵開啟 使用按鍵 F1 或是 ctrl + shift + p 顯示所有命令 輸入 open settings 選取 Preferences: Open User Settings (Json) 3. 即可開啟設定檔 settings.json 方法二、從設定中開啟 點擊VSCode 左下角齒輪裡的設定 (快捷鍵 ctrl + ,) 2. 點擊右上角的 開啟設定(json) 3. 即可開啟設定檔 settings.json 2. 新增 git bash 到 terminal 選項 當前使用的 VSCode 版本為 1.84 將設定值寫入 settings.json settings.json12345&quot;terminal.integrated.profiles.windows&quot;: { &quot;Git Bash&quot;: { &quot;path&quot;: &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot;, }} 健忘筆記 &quot;path&quot; 請設定自己 git bash 的路徑，以及這邊的檔案是 bash.exe 不是 git-bash.exe。 &quot;terminal.integrated.profiles 的其他設定可以到官方文件查看。 設定後存檔，重新開啟 VSCode，使用按鍵 ctrl + ‵ ( ‵ 就是 ~ 鍵) 開啟終端機，就可以在選項中看到 git bash 了！ 終端機名稱設定 &quot;Git Bash&quot; 如果顯示不行使用或是終端機選項中沒有出現，嘗試修改名稱，使用 &quot;GitBash&quot; 或 &quot;Git_Bash&quot; 等，我的兩台電腦一台可以使用 &quot;Git Bash&quot; 一台則不行，爬文的結果此問題應該是 VSCode 版本導致，建議更新版本後再設定。 將 git bash 設定為 VSCode 的預設終端機terminal 增加 git bash 選項後，將其設為預設終端機，之後每次開終端機就都是 git bash 了 將設定值寫入 settings.json settings.json1&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot; 設定後存檔重新開啟 VSCode，終端機就會自動選擇 git bash 開啟了！ 健忘筆記 &quot;terminal.integrated.profiles.windows&quot; 和 &quot;terminal.integrated.defaultProfile.windows&quot; 是最新的設定參數，&quot;terminal.integrated.shell.windows&quot; 已是舊設定值無法使用。 快速切換 shell在終端機命令列打上 shell 名稱 bash / powershell / cmd 就可以快速切換。 切換 powershell 切換 cmd 切換 git bash 結論對我來說，能夠在同一個視窗內完成所有工作，直接在 VSCode 中查看程式並執行指令是最方便的方式。 這邊整理需要注意的地方： 查看 VSCode 版本，有些版本設定會有問題，當前使用的版本為 1.84 設定 git bash 的路徑 “path”，請填寫自己 bash.exe 的檔案位置 \"terminal.integrated.shell.windows\" 已棄用，請使用 \"terminal.integrated.profiles.windows\" 和 \"terminal.integrated.defaultProfile.windows\" 你們覺得這樣方便嗎？ 歡迎分享你的看法～ 延伸閱讀 [官方文件] VSCode terminal 介紹 [官方文件] VSCode terminal 設定檔 [為你自己學Git] 終端機是甚麼？ [為你自己學Git] 什麼是Git？為什麼要學習它？","link":"/Other/VSCode/Using-Git-Bash-in-VSCode/"},{"title":"【MySQL】解析資料庫語言類型 DDL、DML、DCL、DQL","text":"本篇重點 了解 DML、DDL、DCL 和 DQL 分別是資料庫裡的哪些功能 以下說明會以 MySQL 的指令做說明 在資料庫管理中，DML、DDL、DCL 和 DQL 是資料庫領域中的四種類型，它們各自負責著不同的任務。 舉例的中括號 [ ] 為替換字串 DDL (Data Definition Language) 數據定義語言DDL用於定義和管理資料庫結構。 包括創建、修改和刪除資料庫、資料表、索引等對象的操作。 常見指令 CREATE：建立資料庫的物件 (資料表、索引等) DESCRIBE：查詢資料表的結構資訊 ALTER：修改現有資料庫對象的結構 (新增欄位、修改資料型別等) TRUNCATE：刪除資料表中的所有資料，但保留資料表的結構 DROP：刪除資料庫的物件 (資料表、索引等) 實例搶先看 DDL 數據定義語言 CREATE：建立資料庫的物件 (資料表、索引等)DESCRIBE：查詢資料表的結構資訊ALTER：修改現有資料庫對象的結構 (新增欄位、修改資料型別等)DROP：刪除資料庫的物件 (資料表、索引等) 實例搶先看 舉例創建資料庫 mysql1234CREATE DATABASE [資料庫名稱];// 創建 &quot;mydatabase&quot; 資料庫CREATE DATABASE mydatabase; 創建資料表 mysql12345678CREATE TABLE [資料表名稱];// 創建 &quot;customers&quot; 資料表CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY,name VARCHAR(50),email VARCHAR(100)); 查詢資料表的結構資訊 mysql1234DESCRIBE [資料表名稱];// 查看 &quot;customers&quot; 資料表結構資訊DESCRIBE customers; 修改資料表結構 mysql1234567ALTER TABLE [資料表名稱] [修改事項];// &quot;customers&quot; 資料表新增一個欄位 &quot;phone&quot;ALTER TABLE customers ADD phone VARCHAR(20);// 刪除 &quot;customers&quot; 資料表的 &quot;phone&quot; 欄位ALTER TABLE customers DROP COLUMN phone; 清空資料表所有資料 mysql1234TRUNCATE TABLE [資料表名稱];// 清空 &quot;customers&quot; 資料表內所有內容TRUNCATE TABLE customers; 刪除資料表 mysql1234DROP TABLE [資料表名稱];// 刪除 &quot;customers&quot; 資料表DROP TABLE customers; 健忘筆記 刪除資料功能 (TRUNCATE 指令或刪除資料表的欄位等) 無法回滾（Rollback），一旦執行就無法還原被刪除的資料。在使用刪除功能時，請再三確認要刪除的資料。 動手做做看 動手做做看 DML (Data Manipulation Language) 數據操作語言DML 是用於操作和處理資料。 包括對資料進行插入、更新和刪除等操作。 常見指令 INSERT INTO：新增資料到資料表中 UPDATE：更改資料表中的資料 DELETE：刪除資料表中的資料 健忘筆記 在一些資料庫系統中，SELECT 指令也可能被視為 DML 指令的一部分，這取決於特定資料庫的標準。但在 MySQL 中，通常將 SELECT 指令歸類為 DQL 指令。 實例搶先看 DML 數據操作語言 INSERT INTO：新增資料到資料表中SELECT：查詢資料庫中的資料UPDATE：更改資料表中的資料DELETE：刪除資料表中的資料 實例搶先看 舉例新增資料 mysql1234INSERT INTO [資料庫名稱] ([欄位]) VALUES ([值]);// 在 &quot;customers&quot; 資料表新增一筆客戶資料INSERT INTO customers (name, email) VALUES ('John', 'john@example.com'); 更新資料 mysql1234UPDATE [資料庫名稱] SET [修改值] WHERE [條件];// 在 &quot;customers&quot; 資料表更新一筆客戶資料UPDATE customers SET email = 'newJohn@example.com' WHERE name = 'John'; 刪除資料 mysql1234DELETE FROM [資料庫名稱] WHERE [條件];// 在 &quot;customers&quot; 資料表刪除一筆客戶資料DELETE FROM customers WHERE name = 'John'; 動手做做看 動手做做看 DQL (Data Query Language) 數據查詢語言DQL 用於查詢資料庫的資料。 主要目的是檢索所需的數據，而不涉及對數據進行修改。 常見指令 SELECT：查詢資料庫中的資料 WHERE：條件篩選資料 DISTINCT：檢索唯一的資料值 ORDER BY：依指定的欄位排序資料 GROUP BY：依指定的欄位分組 實例搶先看 DQL 數據查詢語言 SELECT：查詢資料庫中的資料WHERE：條件篩選資料DISTINCT：檢索唯一的資料值ORDER BY：按照指定的欄位排序資料GROUP BY：依指定的欄位分組 實例搶先看 舉例查詢資料 mysql1234SELECT [欄位名稱] FROM [資料表名稱];// 搜索 table_name 資料表內所有欄位的資料SELECT * FROM table_name; 篩選條件 mysql1234SELECT [欄位名稱] FROM [資料表名稱] WHERE [篩選條件];// 搜索 table_name 資料表內 uid = 123 的資料SELECT * FROM table_name WHERE uid = 123; 搜索唯一值 mysql1234SELECT DISTINCT [欄位名稱] FROM [資料表名稱];// 搜索 order_list 資料表內 uid 唯一值的資料SELECT DISTINCT uid FROM order_list; 依指定欄位排序資料 mysql1234567SELECT [欄位名稱] FROM [資料表名稱] ORDER BY [欄位名稱] (ASC/DESC);// 搜索 order_list 資料表內所有資料並以uid做排序SELECT * FROM order_list ORDER BY uid;// 設定順序由大排到小SELECT * FROM order_list ORDER BY uid DESC; 健忘筆記 ORDER BY 未指定排序，預設使用 ASC (升冪)，順序由小排到大，如果想要由大排到小，可以設定 ORDER BY [欄位名稱] DESC; 依指定的欄位分組 mysql1234SELECT [欄位名稱] FROM [資料表名稱] GROUP BY [欄位名稱];// 依 team 去分組，計算每組的人數SELECT team, COUNT(*) FROM table_name GROUP BY team; 動手做做看 動手做做看 DCL (Data Control Language) 數據控制語言DCL 用於控制資料庫的使用權限和訪問權限。 包括授予、撤銷用戶的權限，以及確保資料庫的安全性和完整性。 常見指令 CREATE USER：創建新的使用者 DROP USER：刪除現有的使用者 GRANT：授予使用者特定的權限和許可權 REVOKE：撤銷使用者的特定權限和許可權 舉例創建新的使用者 mysql1234CREATE USER [使用者名稱]@[IP位置或主機名] IDENTIFIED BY 'password';// 創建新使用者 &quot;mary&quot;，並設定密碼CREATE USER 'mary'@'localhost' IDENTIFIED BY 'password'; 健忘筆記 IDENTIFIED BY 是用於設定使用者密碼的指令，可以省略這個指令讓使用者直接進入資料庫，但這樣就有安全性的問題 刪除現有的使用者 mysql1234DROP USER [使用者名稱]@[IP位置或主機名];// 刪除資料庫使用者 &quot;mary&quot;DROP USER 'mary'@'localhost'; 授予權限 mysql1234GRANT [權限] ON [資料庫名稱].* TO [使用者名稱]@[IP位置或主機名];// 授予 &quot;john&quot; 在 my_database 搜尋和寫入和刪除的權限GRANT SELECT, INSERT, DELETE ON my_database.* TO 'john'@'localhost'; 健忘筆記 ‘john‘@’localhost’ 是用來指定使用者帳號和使用者連接的 IP，指定連接 IP 確保資料庫的安全性my_database.* 是指定 my_database 資料庫的所有資料表，也可以指定特定資料表的權限，例如 my_database.my_table 收回權限 mysql1234REVOKE [權限] ON [資料庫名稱].* FROM [使用者名稱]@[IP位置或主機名];// 收回 &quot;john&quot; 在 my_database 刪除的權限REVOKE DELETE ON my_database.* FROM 'john'@'localhost'; 結論有一次在看 MySQL 文件的時候裡面提到 DQL，但也沒有特別解釋什麼是 DQL，後來去查才知道這是資料庫語言類型，感覺很容易忘記所以有了這篇😆 DDL：定義和管理資料庫結構 DML：操作和處理資料 DQL：查詢資料庫的資料 DCL：控制資料庫的使用權限和訪問權限。","link":"/Backend/MySQL/Analyzing-4-Types-of-Database-Language/"},{"title":"【jQuery、css】解析六種組合選擇器：相連、+、～、&gt;、,、空格","text":"本篇重點 組合選擇器是甚麼 選擇器內的符號( +、~、&gt; 、, 等)有甚麼含意 jQuery 要使用組合選擇器還是原生的函式 設定 CSS 樣式或是 jQuery 要操作 DOM 元素時，會用到選擇器選取元素，兩者的選擇器類似，你可能看過選擇器中有一些符號，例如 +、~、&gt; 或是空格，這些將兩個元素組合起來的選擇器就稱為「組合選擇器 Combinator」，熟悉符號的意思可以加速抓到想要的元素，甚至提升整體效能，那來了解這些符號分別代表甚麼意思吧！ 標籤之間的關係先了解 HTML 階層間的關係，可以用家族的關係來了解每個階層。 舉例來說，以 &lt;div id=&quot;john&quot;&gt; 角度出發，看看下面標籤之間的關係 html12345678&lt;div&gt;john的父親(父層) &lt;p&gt;john的哥哥或姊姊&lt;/p&gt; &lt;div id=&quot;john&quot;&gt; &lt;p&gt;john的孩子(子層)&lt;/p&gt; &lt;/div&gt; &lt;p&gt;john的弟弟或妹妹&lt;/p&gt;&lt;/div&gt;&lt;div&gt;john父親的弟弟或妹妹&lt;/div&gt; 接下來會使用家族關係來解釋各個組合選擇器的使用方法。 健忘筆記 可以使用 tag、id、class 等選擇器做組合選擇器 相連的選擇器選擇器相連且中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 範例 實例搶先看 相連的選擇器 選擇器相連且中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 html123456&lt;div id=&quot;father&quot;&gt; john的父親(父層) &lt;div class=&quot;select&quot; id=&quot;tom&quot;&gt;tom (john的哥哥)&lt;/div&gt; &lt;p class=&quot;select&quot; id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p&gt;john的弟弟或妹妹&lt;/p&gt;&lt;/div&gt; css1234567#john.select { background-color: orange;}div.select#tom { background-color: gray;} jQuery1234567$(&quot;#john.select&quot;).click(function () { alert(&quot;john&quot;);});$(&quot;div#tom.select&quot;).click(function () { alert(&quot;tom&quot;);}); 空格相連的選擇器指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 範例 實例搶先看 空格相連的選擇器 指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 html12345678910&lt;p class=&quot;select&quot;&gt;class=&quot;select&quot;&lt;/p&gt;&lt;div id=&quot;father&quot;&gt; john的父親(父層) &lt;p class=&quot;find&quot;&gt;class=&quot;find&quot;&lt;/p&gt; &lt;div class=&quot;select&quot; id=&quot;tom&quot;&gt;tom (john的哥哥)&lt;/div&gt; &lt;p class=&quot;select&quot; id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot;&gt;joy (john的&lt;b class=&quot;select&quot;&gt;弟弟或妹妹&lt;/b&gt;)&lt;/p&gt; &lt;p class=&quot;find&quot;&gt;class=&quot;find&quot;&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot;&gt;class=&quot;select&quot;&lt;/p&gt; css1234567#father .select { background-color: orange;}div #joy { background-color: gray;} 健忘筆記 使用空格只會選取 &lt;div id=&quot;father&quot;&gt; 內層的元素，因此在 &lt;div id=&quot;father&quot;&gt; 外層上下的 class=&quot;select&quot; 元素不會有反應 jQuery1234567$(&quot;#father .select&quot;).click(function () { alert(&quot;orange&quot;);});$(&quot;div #joy&quot;).click(function () { alert(&quot;gray&quot;);}); 實作這個例子時你會發現，點擊文字”弟弟或妹妹” 會發現先跳出 orange 再跳出 gray，這是JS的事件冒泡，如果要解決這個問題可以使用 、event.stopPropagation() 來處理。 jQuery1234$(&quot;#father .select&quot;).click(function() { alert(&quot;orange&quot;); event.stopPropagation()}); 健忘筆記 事件冒泡：指內層元素觸發事件，外層元素也跟著觸發 選取同一家族內的指定元素，也可以使用 jquery 函數的 .find() 來選取 jQuery123$(&quot;#father&quot;).find('.find').click(function () { alert(&quot;find&quot;);}); 「+」相連的選擇器同一層後的第一個元素，表示會選取大弟或大妹 範例 實例搶先看 「+」相連的選擇器 同一層後的第一個元素，表示會選取大弟或大妹 html1234567&lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot;&gt;joy (john的弟弟或妹妹)&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot; id=&quot;first&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;p class=&quot;select&quot;&gt;father的二弟或二妹&lt;/p&gt; css123#father + .select { background-color: orange;} 健忘筆記 使用「+」只會選取 &lt;div id=&quot;father&quot;&gt; 同層後的第一個元素，所以只有 &lt;p class=&quot;select&quot; id=&quot;first&quot;&gt; 會被選取 jQuery123$(&quot;#father + .select&quot;).click(function() { alert(&quot;click&quot;);}); 同層後的第一個元素，也可以使用 jquery 函數的 .next() 來選取 jQuery12345678$(&quot;#john&quot;).next().click(function () { alert(&quot;.next()&quot;);});// 指定同層後的第一個元素$(&quot;#first&quot;).next(&quot;.select&quot;).click(function () { alert(&quot;.next('.select')&quot;);}); 健忘筆記 如果 .next() 有指定元素例如 .next(&quot;.select&quot;)，表示會選取同一層後第一個是 class=&quot;select&quot; 的元素，如果第一個元素不是則不會選取 「~」相連的選擇器同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 範例 實例搶先看 「~」相連的選擇器 同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 html12345678910&lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot; class=&quot;nextAll&quot;&gt;joy (john的弟弟或妹妹)&lt;/p&gt; &lt;p id=&quot;betty&quot;&gt;betty (joy的弟弟或妹妹)&lt;/p&gt; &lt;p id=&quot;tom&quot; class=&quot;nextAll&quot;&gt;tom (joy的弟弟或妹妹)&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot; id=&quot;first&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;p id=&quot;second&quot;&gt;father的二弟或二妹&lt;/p&gt;&lt;p class=&quot;select&quot; id=&quot;second&quot;&gt;father的三弟或三妹&lt;/p&gt; css123#father ~ .select { background-color: orange;} 健忘筆記 使用「~」只會選取 &lt;div id=&quot;father&quot;&gt; 同層後的所有指定元素，所以 &lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt; 不會反應 jQuery123$(&quot;#father ~ .select&quot;).click(function () { alert(&quot;click&quot;);}); 同層後的所有元素，也可以使用 jquery 函數的 .nextAll() 來選取 jQuery12345678$(&quot;#john&quot;).nextAll().click(function(){ alert('nextAll');})// 指定同層後的所有指定元素$(&quot;#john&quot;).nextAll(&quot;.nextAll&quot;).click(function(){ alert('nextAll(&quot;.nextAll&quot;)');}) 健忘筆記 如果 .nextAll() 有指定元素例如 .nextAll(&quot;.nextAll&quot;)，表示會選取同一層後所有有 class=&quot;nextAll&quot; 的元素，如果沒有則不會選取 「&gt;」相連的選擇器剛好在下一層的所有指定元素，表示會選取親生的指定小孩 範例 實例搶先看 「>」相連的選擇器 剛好在下一層的所有指定元素，表示會選取親生的指定小孩 html1234567891011121314&lt;p class=&quot;select&quot;&gt;father的哥哥或姐姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot; class=&quot;select&quot;&gt;john&lt;/p&gt; &lt;div id=&quot;joy&quot;&gt;joy &lt;p id=&quot;tim&quot; class=&quot;select&quot;&gt;tim (joy的小孩)&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;tom&quot; class=&quot;select&quot;&gt;father的子層&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;div id=&quot;mother&quot;&gt;mother &lt;p id=&quot;ken&quot; class=&quot;select&quot;&gt;ken&lt;/p&gt; &lt;p id=&quot;eason&quot;&gt;eason&lt;/p&gt; &lt;p id=&quot;kevin&quot; class=&quot;select&quot;&gt;kevin&lt;/p&gt;&lt;/div&gt; 這邊比較以空格和以「&gt;」相連的差別 css1234567#father .select { color: green;}#father &gt; .select { background-color: orange;} jQuery123$(&quot;#father &gt; .select&quot;).click(function () { alert(&quot;click&quot;);}); 健忘筆記 使用「&gt;」只會選取 &lt;div id=&quot;father&quot;&gt; 下一層的所有指定元素，因此不會選取到 &lt;p id=&quot;tim&quot; class=&quot;select&quot;&gt;tim (joy的小孩)&lt;/p&gt;&lt;div&gt; 下一層的所有元素，也可以使用 jquery 函數的 .children() 來選取 jQuery12345678$(&quot;#mother&quot;).children().click(function(){ alert('children()');})// 指定元素下一層的所有指定元素$(&quot;#mother&quot;).children(&quot;.select&quot;).click(function(){ alert('children(&quot;.select&quot;)');}) 健忘筆記 如果 .children() 有指定元素例如 .children(&quot;.select&quot;)，表示會選取下一層中所有有 class=&quot;select&quot; 的元素，如果沒有則不會選取 「,」相連的選擇器需要相同樣式或是相同行為的元素綁在一起 範例 實例搶先看 「,」相連的選擇器 需要相同樣式或是相同行為的元素綁在一起 html1234567&lt;p class=&quot;example1&quot;&gt;example1&lt;/p&gt;&lt;p class=&quot;example2&quot;&gt;example2&lt;/p&gt;&lt;p class=&quot;example3&quot;&gt;example3&lt;/p&gt;&lt;div&gt;div &lt;p class=&quot;example4&quot;&gt;example4&lt;/p&gt; &lt;span class=&quot;example5&quot;&gt;example5&lt;/span&gt;&lt;/div&gt; css12345.example1,.example3,div &gt; span { background-color: orange;} jQuery123$(&quot;.example1, .example3, div &gt; span&quot;).click(function () { alert(&quot;click&quot;);}); 健忘筆記 可以使用各種選擇器選取元素，再用「,」綁在一起 jQuery 要使用組合選擇器還是原生的函式jQuery 選取元素有很多方法，這邊比較組合選擇器和使用 jQuery 的函數的差異 例如：選取 id=”father” 層底下的所有 class=”select” 元素 jQuery12345/* 組合選擇器 */$(&quot;#father .select&quot;)/* jQuery 的函數 */$(&quot;#father&quot;).find(&quot;.select&quot;) 兩種方式都可以達到同樣的效果。在選取元素數量較少的情況下，兩者的差異非常微小，因為目前的瀏覽器及 jQuery 有對此進行優化。但如果選取的元素數量龐大，使用組合選擇器是較有效率的。 總結來說，如果不用考慮效能，則根據個人喜好和代碼的可讀性選擇一種方法來撰寫。覺得使用原生函式較容易閱讀及維護，那就直接使用原生函式吧！ 結論 相連的選擇器：選擇器中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 空格相連的選擇器：指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 「+」相連的選擇器：同一層後的第一個元素，表示會選取大弟或大妹 「~」相連的選擇器：同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 「&gt;」相連的選擇器：剛好在下一層的所有指定元素，表示會選取親生的指定小孩 「,」相連的選擇器：需要相同樣式或是相同行為的元素綁在一起 選擇器用的好，書寫方面會更方便、選取某個元素時會更快速，也可以降低程式的複雜度，閱讀起來更舒服！ 你有什麼常用的選擇器嗎？歡迎跟大家分享～ 延伸閱讀 [官方文件] MDN CSS selectors [iT邦幫忙] JQuery 選擇器的補充 [iT邦幫忙] 事件冒泡","link":"/Frontend/JQuery/Analyzing-Six-Types-of-Combinator/"},{"title":"【Git】了解 git config 設定","text":"本篇重點 了解設定區域：--system, --global, --local git config 常見設定 查詢 git config 設定 刪除 git config 設定 設定的區域依需求做不同範圍的設定，在不同區域的設定影響 git 操作的範圍 當前儲存庫設定 --local在資料夾建立 git 環境後，這個資料夾就是當前儲存庫的設定區域 設定檔文件通常位於當前資料夾的 .git/config 用戶級別設定 --global系統用戶的設定區域，會影響當前用戶所建立的所有儲存庫區域。 設定檔文件通常位於用戶家目錄下的 .gitconfig 或 .config/git/config 系統級別設定 --system系統管理員的設定區域，會影響所有用戶所建立的所有儲存庫區域。 設定檔文件通常位於 /etc/gitconfig 健忘筆記 如果想查詢各個區域的設定檔，可以使用 git config --list --show-origin [區域]，例如 git config --list --show-origin --global 設定區域優先級git config 會依照固定的優先順序進行覆蓋。優先順序如下： --local：對當前資料夾的 Git 儲存庫有效，優先級最高，會覆蓋 --global 和 --system 的相同設定。 --global：對當前用戶的所有 Git 儲存庫有效，優先級次於 --local ，會覆蓋 --system 的相同設定，但不會覆蓋 --local 的。 --system：對系統上所有 Git 的儲存庫有效，優先級最低，會被 --global 和 --local 覆蓋相同的設定。 健忘筆記 優先級順序： --local &gt; --global &gt; --system git config 常見設定各個設定都可以依據需求來做不同區域的設定 舉例的中括號 [ ] 為替換字串 git1234567git config [要設定的區域] [甚麼設定] [設定值]// 設定用戶級別的區域git config --global user.name &quot;forgetfulengineer&quot;// 設定當前儲存庫的區域git config --local user.email &quot;thatforgetfulengineer@gmail.com&quot; 健忘筆記 如果沒有指定設定位置，例如：git config user.name &quot;forgetfulengineer&quot;git config 的預設位置為 -- local 設定使用者名稱和郵件地址git123456789// 設定使用者的名稱git config --global user.name &quot;[名字]&quot;git config --global user.name &quot;forgetfulengineer&quot;// 設定使用者信箱git config --local user.email &quot;[信箱]&quot;git config --local user.email &quot;thatforgetfulengineer@gmail.com&quot; 設定 Git 指令縮寫git1234567891011git config --global alias.[縮寫] [指令]// 設定 st 等於 statusgit config --global alias.st status// 設定完後使用 git st 等於 git status 的效果// 設定 br 等於 branchgit config --global alias.br branch// 設定完後使用 git br 等於 git branch 的效果 設定 Git 使用的編輯器git config –global core.editor “vim” git1234git config --global core.editor &quot;[編輯器]&quot;// 設定 vim 為 git 的編輯器git config --global core.editor &quot;vim&quot; 設定 git log 顯示各分支進度git12345// 開啟顯示各分支進度git config --global log.decorate auto// 關閉顯示各分支進度git config --global log.decorate no log.decorate 設置有幾個選項： auto：根據終端檢測決定是否顯示各分支進度。 short：顯示簡短的各分支進度。 full：顯示完整的各分支進度。 no：不顯示各分支進度。 健忘筆記 HEAD -&gt; dev 表示當前 branch 的進度，當前在 dev 這個 branch 上origin/dev 表示遠端 branch 的進度，當前 github 上的 dev branch 在 “無障礙功能優化” 這個 commit 上 當前本地 branch 還沒跟遠端 branch 的進度同步 設定檔案權限 git 的追蹤預設情況下修改檔案的權限(chmod) 會影響 git 的紀錄 git12345// 開啟追蹤檔案權限git config --global core.filemode true// 關閉追蹤檔案權限git config --global core.filemode false 範例 command12345678910111213141516// chmod_test.txt 檔案權限是 644touch chmod_test.txt// 用 chmod 修改檔案權限chmod 755 chmod_test.txt// git diff 查看檔案更動紀錄git diff chmod_test.txt// git diff 結果diff --git a/chmod_test.txt b/chmod_test.txtold mode 100644new mode 100755// 不想記錄檔權限，關閉追蹤檔案權限git config --global core.filemode false 健忘筆記 三位數的檔案權限數字用來說明三種身分user(自己)、group(組別)、other(其它人)的權限，每一位數是三種權限read(4)、write(2)、execute(1)的加總。詳細說明看這裡！ 查詢 git config 設定值及刪除設定查詢單一設定git12345// 查詢 --global 的使用者名稱git config --get --global user.name// 查詢 --local 的 log 設定git config --get --local log.decorate 查詢所有設定git12345// 查詢 --global 的所有設定git config --global --list// 也可以用縮寫 -lgit config --global -l 健忘筆記 如果沒有指定設定位置，例如：git config --list，會列出當前存儲庫的 Git 配置 --local 和當前用戶級別的 Git 配置 --global，但不包括系統級別的 Git 配置 --system 刪除設定使用以下命令來刪除 Git 的現有設定： git12345// 刪除 --global 的使用者名稱git config --unset --global user.name// 刪除 --local 的 log 設定git config --unset --get --local log.decorate 結論我認為 git config 中最基本也最重要的兩種設定是 user.name 和 user.email，因為使用 git commit 時會記錄名字和信箱，如果沒有設定且嘗試使用 git commit，Git 通常會給出錯誤提示。如果仍然嘗試進行提交，Git 可能會使用空值或電腦的使用者名稱作為提交者資訊，獨自開發的情況下影響不大，但多人開發專案時提交資訊就非常重要了。(才有辦法追朔誰開發出 bug 🤣) 增加一些設定也可以讓我們更加便利，像是設定快捷鍵簡短指令長度，加快打指令的速度，或是讓 git log 顯示分支進度，讓資訊更一目了然。 可能還有很多方便的設定，如果你知道就分享一下吧～ 延伸閱讀 【官方文件】git init 創建 git 倉儲環境 【官方文件】git config 介紹 【官方文件】git commit 介紹","link":"/Other/Git/Understanding-Git-Config-Settings/"},{"title":"【PHP】解析邏輯運算子 and、or、&amp;&amp;、|| 之間的差異","text":"本篇重點 and 和 &amp;&amp;之間有什麼差別，它們分別代表什麼意思？ or 和 || 之間有什麼差別，它們分別代表什麼意思？ 邏輯運算子的執行順序 邏輯運算子使用建議 「分數有及格嗎？」、「考卷的姓名和學號都是正確的嗎？」、「這張考卷是 john 還是tom 的？」，在日常生活中很常用到的條件判斷，在程式中也很常出現，PHP 提供了很多符號來輔助我們，使用邏輯運算子來達到目的。 &amp;&amp;、AND vs || 、OR &amp;&amp;、AND 是「且、和」的意思，符號兩邊的條件都達成，結果為 true，反之為 false ||、OR 是「或」的意思，符號兩邊依左至右判斷，如果有條件達成，結果為 true，反之為 false 範例依學生的資訊做條件處理 實例搶先看 &&、AND vs || 、OR &&、AND：「且、和」的意思，符號兩邊的條件都達成，結果為 true，反之為 false||、OR：「或」的意思，符號兩邊依左至右判斷，如果有條件達成，結果為 true，反之為 false 實例搶先看 php12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php// 設定學生 'john' 的資訊$name = 'john';$score = 60;$gender = 'male';// &amp;&amp;、AND 範例// 判斷學生是 john，且分數是及格if ($name == 'john' &amp;&amp; $score &gt;= 60) { echo '判斷為true，學生是 john，且分數是及格';} else { echo '判斷為false';}// 結果：if ($name == 'john' &amp;&amp; $score &gt;= 60) 判斷為true，「&amp;&amp;」兩邊的條件皆正確// 判斷學生不是john，且性別是男生if ($name != 'john' AND $gender == 'male') { echo '判斷為true，學生不是john，且性別是男生';} else { echo '判斷為false';}// 結果：if ($name != 'john' AND $gender == 'male') 判斷為 false，第一個條件學生不是 john 是錯誤的，因此也不用看第二個條件了，整個判斷式直接錯誤// ||、OR 範例// 判斷學生是john或是學生是女生if ($name == 'john' || $gender == 'female') { echo '判斷為true，學生是john，或是學生是女生';} else { echo '判斷為false';}// 結果：if ($name == 'john' || $gender == 'female') 判斷為 true，第一個條件學生是 john 是正確的，因此也不用看第二個條件了，整個判斷式直接正確// 判斷學生分數不及格或是這位學生不是男生if ($score &lt; 60 OR $gender != 'male') { echo '判斷為true，學生分數不及格或是這位學生不是男生';} else { echo '判斷為false';}// 結果：if ($name == 'john' || $gender == 'female') 判斷為 false，第一個條件不正確，接續判斷第二個條件，第二個條件也不正確 動手做做看 動手做做看 &amp;&amp; vs AND 以及 || vs OR接著來比較 and 和 &amp;&amp; 之間以及 or 和 || 之間的差異 簡單來說它們的差異就是執行的優先順序（Operator Precedence）不同 「&amp;&amp;」的執行順序比「=」高，而「=」的執行順序比「AND」高 「||」的執行順序比「=」高，而「=」的執行順序比「OR」高 範例依學生的資訊做條件處理 實例搶先看 && vs AND 以及 || vs OR 「&&」的執行順序比「=」高，而「=」的執行順序比「AND」高「||」的執行順序比「=」高，而「=」的執行順序比「OR」高 實例搶先看 php123456789101112131415161718192021222324252627282930313233&lt;?php// 設定學生 'Tom' 的資訊$student_id = 123;$name = 'tom';$gender = 'male';$score = 49;// &amp;&amp;、AND 範例// 判斷學生學號是123，且分數是及格$answer = $student_id == 123 &amp;&amp; $score &gt;= 60;// 結果：判斷結果為 fasle，第二個條件錯誤$answer = $student_id == 123 AND $score &gt;= 60;// 結果：判斷結果為 true，因為「=」的執行順序比「AND」高，因此變成先執行「$answer = $student_id== 123」，導致 $answer 先賦值$answer = ($student_id == 123 AND $score &gt;= 60);// 結果：判斷結果為 false，因為加了括號改變執行順序，先執行「$student_id == 123 AND $score &gt;= 60」// 判斷這位學生是 john 還是 tom$answer = $name == 'john' || $name == 'tom';// 結果：判斷結果為 true，第一個條件正確$answer = $name == 'john' OR $name == 'tom';// 結果：判斷結果為 false，因為「=」的執行順序比「OR」高，因此變成先執行「$answer = $name == 'john'」，導致 $answer 先賦值$answer = ($name == 'john' OR $name == 'tom');// 結果：判斷結果為 true，因為加了括號改變執行順序，先執行「$name == 'john' OR $name == 'tom'」 健忘筆記 判斷式建議使用 &amp;&amp; 和 || ，如果要使用 AND 和 OR 記得加上括號減少錯誤發生～詳細的執行順序看這裡！ 動手做做看 動手做做看 結論條件判斷時，依需求使用不同的邏輯運算子幫助我們達到目的。 「&amp;&amp;」、「AND」 是「且」的意思，符號兩邊的條件皆須達成時使用 「||」、「OR」 是「或」的意思，符號兩邊的條件只需要有一個條件達成時使用 「&amp;&amp;」的執行順序比「=」高，而「=」的執行順序比「AND」高 「||」的執行順序比「=」高，而「=」的執行順序比「OR」高 運算子的執行優先順序大大的影響判斷的結果，所以在使用時要多加注意，不然會得到意想不到的結果😆，建議使用「&amp;&amp;」和「||」可以減少錯誤的發生～ 延伸閱讀 【官方文件】邏輯運算子介紹 【官方文件】運算子優先級","link":"/Backend/PHP/Comparing-the-Differences-Between-Logical-Operators/"}],"tags":[{"name":"php","slug":"php","link":"/tags/php/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"git bash","slug":"git-bash","link":"/tags/git-bash/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"}],"categories":[{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"PHP","slug":"Backend/PHP","link":"/categories/Backend/PHP/"},{"name":"VSCode","slug":"Other/VSCode","link":"/categories/Other/VSCode/"},{"name":"MySQL","slug":"Backend/MySQL","link":"/categories/Backend/MySQL/"},{"name":"Css","slug":"Frontend/Css","link":"/categories/Frontend/Css/"},{"name":"Git","slug":"Other/Git","link":"/categories/Other/Git/"},{"name":"JQuery","slug":"Frontend/JQuery","link":"/categories/Frontend/JQuery/"}],"pages":[{"title":"404 - 網頁不存在","text":"var redirects = { \"/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/\": \"/Backend/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/\", \"/VSCode/Using-Git-Bash-in-VSCode/\": \"/Other/VSCode/Using-Git-Bash-in-VSCode/\", }; var path = window.location.pathname; if (redirects[path]) { window.location.replace(redirects[path]); } 這是一個不存在的頁面 抱歉，找不到你要的頁面 😢將在 5 秒後返回首頁。 let countTime = 5; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if (countTime === 0) { location.href = 'https://forgetfulengineer.github.io'; } setTimeout(() => { count(); }, 1000); } count();","link":"/404.html"}]}