{"posts":[{"title":"【PHP】4種判斷變數或陣列是否存在的方法","text":"本篇重點 使用 empty()、is_null()、isset() 或是直接使用if ($variable) 判斷式來判斷變數或陣列是否存在 資料檢查甚麼時候會有錯誤訊息(php error) 在開發動態網頁時，後端程式扮演了一個重要的角色，可能會處理來自前端程式的資料，也有可能處理來自資料庫的資料，在這種情況下，我們必須嚴謹地檢查數據的完整性，以確保後續的程式能夠順暢運行。那麼有哪些函數能夠進行這樣的檢查？ 首先先了解各種類型的判斷，判斷的類型有 無效值(null) 布林值(boolean) 字串(string) 數值(integer) 陣列(array) 判斷差異表比較不同的function在各種情況下的判斷 型態 if ($x) empty() isset() is_null() $x = null null false true false true $x is undefined null false true false true $x = true boolean true false true false $x = false boolean false true true false $x = ‘’ string false true true false $x = ‘1’ string true false true false $x = ‘0’ string false true true false $x = ‘-1’ string true false true false $x = ‘hello’ string true false true false $x = ‘true’ string true false true false $x = ‘false’ string true false true false $x = 1 integer true false true false $x = 0 integer false true true false $x = -1 integer true false true false $x = 666 integer true false true false $x = array() array false true true false $x = array(‘a’, ‘b’) array true false true false if ($x) 和 empty() 的判斷結果相反 isset() 和 is_null() 的判斷結果相反 螢光標記是我覺得特別要注意的判斷結果 範例 用戶填寫表格資料並送出資料，這些資料會從前端傳到後端程式，此時我們需要驗證是否有填入資料或是資料是否正確 php12345678&lt;?php// 使用 isset() 搭配 intval() 確認是否有參數傳入且為大於 0 的數值$age = isset($_POST['age']) &amp;&amp; intval($_POST['age']) &gt; 0 ? intval($_POST['age']) : 0;// 初步整理 $age 值後，檢查是否需要返回前端重新填寫年齡if ($age == 0) { // 返回前端請用戶重新填寫年齡} 情境一，填寫年齡 30 傳入後端，isset() 為 true，且 intval() 後數值大於零，$age = 30 往下接續處理 情境二，填寫年齡 0 傳入後端，isset() 為 true，但 intval() 後數值等於零，$age = 0 返回前端處理 情境三，無填寫年齡傳入後端，isset() 為 false，$age = 0 返回前端處理 健忘筆記 ? : 是一種條件運算符，稱為 三元運算符，可以用來做因果判斷 動手做做看 前端資料傳入後端後做資料檢查 情境一，填寫年齡 30 傳入後端，isset() 為 true，且 intval() 後數值大於零，$age = 30 往下接續處理情境二，填寫年齡 0 傳入後端，isset() 為 true，但 intval() 後數值等於零，$age = 0 返回前端處理情境三，無填寫年齡傳入後端，isset() 為 false，$age = 0 返回前端處理 從資料庫撈取資料，並檢測是否有資料，如果為無資料需要做處理 情境一，從資料庫撈取會員資訊，並取得完整資料 php12345678910111213141516171819&lt;?php$user_data = array( 'name' =&gt; '小明', 'gender' =&gt; 'Male',);// 使用 if (!$user_data) 確認變數內是否有資料if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 false，原本 if ($user_data) 為 true，但碰到驚嘆號反轉布林值結果，因此為 false 跳過判斷// 使用 !is_array($user_data) 搭配 empty($user_data) 確認變數內是否有資料if (!is_array($user_data) || empty($user_data)) { // 無資料時的處理}// 結果：!is_array($user_data) 為 false，empty($user_data) 也為 false，因此跳過判斷 動手做做看 情境一，從資料庫撈取會員資訊，並取得完整資料 資料檢查1：if (!$user_data) 判斷為 false，原本 if ($user_data) 為 true，但碰到驚嘆號反轉布林值結果，因此為 false 跳過判斷資料檢查2：!is_array($user_data) 為 false，empty($user_data) 也為 false，因此跳過判斷 情境二，從資料庫撈取會員資訊，但沒有撈到資料寫入空陣列 php12345678910111213141516&lt;?php$user_data = array();// 使用 if (!$user_data) 確認變數內是否有資料if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 true 進入無資料處理// 使用 !is_array($user_data) 搭配 empty($user_data) 確認變數內是否有資料if (!is_array($user_data) || empty($user_data)) { // 無資料時的處理}// 結果：!is_array($user_data)為 false，但 empty($user_data) 為 true，因此進入無資料處理 動手做做看 情境二，從資料庫撈取會員資訊，但沒有撈到資料寫入空陣列 資料檢查1：if (!$user_data) 判斷為 true 進入無資料處理資料檢查2：!is_array($user_data)為 false，但 empty($user_data) 為 true，因此進入無資料處理 情境三，從資料庫撈取會員資訊，但沒有撈到資料寫入字串 php1234567891011121314&lt;?php$user_data = 'no_data';if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 false 跳過判斷if (!is_array($user_data) || empty($user_data)) { // !is_array()為 true，因此進入無資料處理 // 無資料時的處理}// 結果：!is_array($user_data) 判斷為 true，因此進入無資料處理 健忘筆記 如果查找資料庫，沒有取得資料會寫入 array 以外的型態，那使用 !is_array($x) 搭配 empty() 來檢查資料會是更謹慎的做法 動手做做看 情境三，從資料庫撈取會員資訊，但沒有撈到資料寫入字串 資料檢查1：if (!$user_data) 判斷為 false 跳過判斷資料檢查2：!is_array($user_data) 判斷為 true，因此進入無資料處理 錯誤訊息在進行資料完整性檢查時，要確保資料的完整性，但又不希望出現錯誤訊息，那麼應該採用哪種函數? 這四種驗證方式除了兩兩相反外，還有一個很重要的差異 “錯誤訊息” 也就是PHP error。當變數 $x 沒有被賦值時，使用 if ($x) 和 is_null($x) 會引發錯誤訊息，但使用 isset($x) 和 empty($x) 不會，不過這些錯誤屬於較輕微的 E_NOTICE 級別，所以在沒有開啟PHP的所有錯誤提示的情況下是不會對網頁造成影響，但還是應該盡量處理這些錯誤。 範例 情境一，檢查陣列中不存在的索引 php12345&lt;?php$a = [];var_dump($a[1]); // NULL，錯誤訊息 Notice: Undefined offset: 1var_dump(isset($a[1])); // bool(false)，無錯誤訊息 $a 設定為一個空陣列，卻指定不存在的索引1，因此在 var_dump($a[1]) 的情況下會出現錯誤訊息 動手做做看 情境一，檢查陣列中不存在的索引 $a 設定為一個空陣列，卻指定不存在的索引1，因此在 var_dump($a[1]) 的情況下會出現錯誤訊息 情境二，判斷不存在的變數 php1234&lt;?php// $b 沒有被賦值var_dump(is_null($b)); // bool(true)，Notice: Undefined variable: b var_dump(empty($b)); // bool(true)，無錯誤訊息 $b 沒有被賦值，因此在 is_null($b) 的情況下會出現錯誤訊息。 動手做做看 情境二，檢查不存在的變數 $b 沒有被賦值，因此在 is_null($b) 的情況下會出現錯誤訊息 情境三，有個陣列內的值需要做處理，但這個值不一定存在，如果不存在就不需要處理 php123456789101112131415161718192021222324252627282930&lt;?php// 如果$user內沒有'age'$user = array( 'name' =&gt; '小明');if ($user['age']) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：出現錯誤訊息 Notice: Undefined index: age 並跳出判斷，'adult'沒有寫入資料// 為了不跳出錯誤訊息且正常判斷，可以改成!empty($user['age'])if (!empty($user['age'])) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：無錯誤訊息跳出判斷// 如果$user內有'age'$user = array( 'name' =&gt; '小明', 'age' =&gt; 10);if (!empty($user['age'])) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：!empty($user['age'])判斷為true，$user['adult'] 寫入 false 判斷用戶是否成年，而 $user 內 ‘age’ 的值不一定存在，因此需要檢查 ‘age’ 是否存在再做處理 健忘筆記 在不確定資料內部狀況的情況下，可以使用 empty() 來讓錯誤訊息消失 動手做做看 情境三，有個陣列內的值需要做處理，但這個值不一定存在，如果不存在就不需要處理 資料檢查1：出現錯誤訊息 Notice: Undefined index: age 並跳出判斷，'adult'沒有寫入資料資料檢查2：無錯誤訊息跳出判斷資料檢查3：!empty($user['age'])判斷為true，$user['adult'] 寫入 false 結論依不同的需求，使用function 來判斷變數或陣列的完整性。 if ($x) 和 empty($x) 的判斷結果相反 isset($x) 和 is_null($x) 的判斷結果相反 無設定 $x 值的狀況下 if ($x) 和 is_null($x) 會跳錯誤訊息 isset($x) 和 empty($x) 則不會跳錯誤訊息 檢查完整性可以減少 bug 的發生，不用修 bug 就是開心😆～ 你平常會檢查變數或陣列的資料完整性嗎? 是用甚麼方法處理呢? 歡迎留言跟大家分享！ 動手做做看 PHP 線上編輯器 參考資料 【官方文件】PHP類型比較表 延伸閱讀 【官方文件】資料類型的介紹 【官方文件】判斷式(if)介紹 【官方文件】布林值false的定義 【官方文件】PHP error 介紹","link":"/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/"},{"title":"【jQuery、css】解析六種組合選擇器：相連、空格、+、～、&gt;、,","text":"本篇重點 組合選擇器是甚麼 選擇器內的符號( +、~、&gt; 、, 等)有甚麼含意 jQuery 要使用組合選擇器還是原生的函式 設定 CSS 樣式或是 jQuery 要操作 DOM 元素時，會用到選擇器選取元素，兩者的選擇器類似，你可能看過選擇器中有一些符號，例如 +、~、&gt; 或是空格，這些將兩個元素組合起來的選擇器就稱為「組合選擇器 Combinator」，熟悉符號的意思可以加速抓到想要的元素，甚至提升整體效能，那來了解這些符號分別代表甚麼意思吧！ 標籤之間的關係先了解 HTML 階層間的關係，可以用家族的關係來了解每個階層。 舉例來說，以 &lt;div id=&quot;john&quot;&gt; 角度出發，看看下面標籤之間的關係 html12345678&lt;div&gt;john的父親(父層) &lt;p&gt;john的哥哥或姊姊&lt;/p&gt; &lt;div id=&quot;john&quot;&gt; &lt;p&gt;john的孩子(子層)&lt;/p&gt; &lt;/div&gt; &lt;p&gt;john的弟弟或妹妹&lt;/p&gt;&lt;/div&gt;&lt;div&gt;john父親的弟弟或妹妹&lt;/div&gt; 接下來會使用家族關係來解釋各個組合選擇器的使用方法。 健忘筆記 可以使用 tag、id、class 等選擇器做組合選擇器 相連的選擇器選擇器相連且中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 範例 實例搶先看 相連的選擇器 選擇器相連且中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 html123456&lt;div id=&quot;father&quot;&gt; john的父親(父層) &lt;div class=&quot;select&quot; id=&quot;tom&quot;&gt;tom (john的哥哥)&lt;/div&gt; &lt;p class=&quot;select&quot; id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p&gt;john的弟弟或妹妹&lt;/p&gt;&lt;/div&gt; css1234567#john.select { background-color: orange;}div.select#tom { background-color: gray;} jQuery1234567$(&quot;#john.select&quot;).click(function () { alert(&quot;john&quot;);});$(&quot;div#tom.select&quot;).click(function () { alert(&quot;tom&quot;);}); 空格相連的選擇器指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 範例 實例搶先看 空格相連的選擇器 指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 html12345678910&lt;p class=&quot;select&quot;&gt;class=&quot;select&quot;&lt;/p&gt;&lt;div id=&quot;father&quot;&gt; john的父親(父層) &lt;p class=&quot;find&quot;&gt;class=&quot;find&quot;&lt;/p&gt; &lt;div class=&quot;select&quot; id=&quot;tom&quot;&gt;tom (john的哥哥)&lt;/div&gt; &lt;p class=&quot;select&quot; id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot;&gt;joy (john的&lt;b class=&quot;select&quot;&gt;弟弟或妹妹&lt;/b&gt;)&lt;/p&gt; &lt;p class=&quot;find&quot;&gt;class=&quot;find&quot;&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot;&gt;class=&quot;select&quot;&lt;/p&gt; css1234567#father .select { background-color: orange;}div #joy { background-color: gray;} 健忘筆記 使用空格只會選取 &lt;div id=&quot;father&quot;&gt; 內層的元素，因此在 &lt;div id=&quot;father&quot;&gt; 外層上下的 class=&quot;select&quot; 元素不會有反應 jQuery1234567$(&quot;#father .select&quot;).click(function () { alert(&quot;orange&quot;);});$(&quot;div #joy&quot;).click(function () { alert(&quot;gray&quot;);}); 實作這個例子時你會發現，點擊文字”弟弟或妹妹” 會發現先跳出 orange 再跳出 gray，這是JS的事件冒泡，如果要解決這個問題可以使用 、event.stopPropagation() 來處理。 jQuery1234$(&quot;#father .select&quot;).click(function() { alert(&quot;orange&quot;); event.stopPropagation()}); 健忘筆記 事件冒泡：指內層元素觸發事件，外層元素也跟著觸發 選取同一家族內的指定元素，也可以使用 jquery 函數的 .find() 來選取 jQuery123$(&quot;#father&quot;).find('.find').click(function () { alert(&quot;find&quot;);}); 「+」相連的選擇器同一層後的第一個元素，表示會選取大弟或大妹 範例 實例搶先看 「+」相連的選擇器 同一層後的第一個元素，表示會選取大弟或大妹 html1234567&lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot;&gt;joy (john的弟弟或妹妹)&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot; id=&quot;first&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;p class=&quot;select&quot;&gt;father的二弟或二妹&lt;/p&gt; css123#father + .select { background-color: orange;} 健忘筆記 使用「+」只會選取 &lt;div id=&quot;father&quot;&gt; 同層後的第一個元素，所以只有 &lt;p class=&quot;select&quot; id=&quot;first&quot;&gt; 會被選取 jQuery123$(&quot;#father + .select&quot;).click(function() { alert(&quot;click&quot;);}); 同層後的第一個元素，也可以使用 jquery 函數的 .next() 來選取 jQuery12345678$(&quot;#john&quot;).next().click(function () { alert(&quot;.next()&quot;);});// 指定同層後的第一個元素$(&quot;#first&quot;).next(&quot;.select&quot;).click(function () { alert(&quot;.next('.select')&quot;);}); 健忘筆記 如果 .next() 有指定元素例如 .next(&quot;.select&quot;)，表示會選取同一層後第一個是 class=&quot;select&quot; 的元素，如果第一個元素不是則不會選取 「~」相連的選擇器同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 範例 實例搶先看 「~」相連的選擇器 同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 html12345678910&lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot; class=&quot;nextAll&quot;&gt;joy (john的弟弟或妹妹)&lt;/p&gt; &lt;p id=&quot;betty&quot;&gt;betty (joy的弟弟或妹妹)&lt;/p&gt; &lt;p id=&quot;tom&quot; class=&quot;nextAll&quot;&gt;tom (joy的弟弟或妹妹)&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot; id=&quot;first&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;p id=&quot;second&quot;&gt;father的二弟或二妹&lt;/p&gt;&lt;p class=&quot;select&quot; id=&quot;second&quot;&gt;father的三弟或三妹&lt;/p&gt; css123#father ~ .select { background-color: orange;} 健忘筆記 使用「~」只會選取 &lt;div id=&quot;father&quot;&gt; 同層後的所有指定元素，所以 &lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt; 不會反應 jQuery123$(&quot;#father ~ .select&quot;).click(function () { alert(&quot;click&quot;);}); 同層後的所有元素，也可以使用 jquery 函數的 .nextAll() 來選取 jQuery12345678$(&quot;#john&quot;).nextAll().click(function(){ alert('nextAll');})// 指定同層後的所有指定元素$(&quot;#john&quot;).nextAll(&quot;.nextAll&quot;).click(function(){ alert('nextAll(&quot;.nextAll&quot;)');}) 健忘筆記 如果 .nextAll() 有指定元素例如 .nextAll(&quot;.nextAll&quot;)，表示會選取同一層後所有有 class=&quot;nextAll&quot; 的元素，如果沒有則不會選取 「&gt;」相連的選擇器剛好在下一層的所有指定元素，表示會選取親生的指定小孩 範例 實例搶先看 「>」相連的選擇器 剛好在下一層的所有指定元素，表示會選取親生的指定小孩 html1234567891011121314&lt;p class=&quot;select&quot;&gt;father的哥哥或姐姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot; class=&quot;select&quot;&gt;john&lt;/p&gt; &lt;div id=&quot;joy&quot;&gt;joy &lt;p id=&quot;tim&quot; class=&quot;select&quot;&gt;tim (joy的小孩)&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;tom&quot; class=&quot;select&quot;&gt;father的子層&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;div id=&quot;mother&quot;&gt;mother &lt;p id=&quot;ken&quot; class=&quot;select&quot;&gt;ken&lt;/p&gt; &lt;p id=&quot;eason&quot;&gt;eason&lt;/p&gt; &lt;p id=&quot;kevin&quot; class=&quot;select&quot;&gt;kevin&lt;/p&gt;&lt;/div&gt; 這邊比較以空格和以「&gt;」相連的差別 css1234567#father .select { color: green;}#father &gt; .select { background-color: orange;} jQuery123$(&quot;#father &gt; .select&quot;).click(function () { alert(&quot;click&quot;);}); 健忘筆記 使用「&gt;」只會選取 &lt;div id=&quot;father&quot;&gt; 下一層的所有指定元素，因此不會選取到 &lt;p id=&quot;tim&quot; class=&quot;select&quot;&gt;tim (joy的小孩)&lt;/p&gt;&lt;div&gt; 下一層的所有元素，也可以使用 jquery 函數的 .children() 來選取 jQuery12345678$(&quot;#mother&quot;).children().click(function(){ alert('children()');})// 指定元素下一層的所有指定元素$(&quot;#mother&quot;).children(&quot;.select&quot;).click(function(){ alert('children(&quot;.select&quot;)');}) 健忘筆記 如果 .children() 有指定元素例如 .children(&quot;.select&quot;)，表示會選取下一層中所有有 class=&quot;select&quot; 的元素，如果沒有則不會選取 「,」相連的選擇器需要相同樣式或是相同行為的元素綁在一起 範例 實例搶先看 「,」相連的選擇器 需要相同樣式或是相同行為的元素綁在一起 html1234567&lt;p class=&quot;example1&quot;&gt;example1&lt;/p&gt;&lt;p class=&quot;example2&quot;&gt;example2&lt;/p&gt;&lt;p class=&quot;example3&quot;&gt;example3&lt;/p&gt;&lt;div&gt;div &lt;p class=&quot;example4&quot;&gt;example4&lt;/p&gt; &lt;span class=&quot;example5&quot;&gt;example5&lt;/span&gt;&lt;/div&gt; css12345.example1,.example3,div &gt; span { background-color: orange;} jQuery123$(&quot;.example1, .example3, div &gt; span&quot;).click(function () { alert(&quot;click&quot;);}); 健忘筆記 可以使用各種選擇器選取元素，再用「,」綁在一起 jQuery 要使用組合選擇器還是原生的函式jQuery 選取元素有很多方法，這邊比較組合選擇器和使用 jQuery 的函數的差異 例如：選取 id=”father” 層底下的所有 class=”select” 元素 jQuery12345/* 組合選擇器 */$(&quot;#father .select&quot;)/* jQuery 的函數 */$(&quot;#father&quot;).find(&quot;.select&quot;) 兩種方式都可以達到同樣的效果。在選取元素數量較少的情況下，兩者的差異非常微小，因為目前的瀏覽器及 jQuery 有對此進行優化。但如果選取的元素數量龐大，使用組合選擇器是較有效率的。 總結來說，如果不用考慮效能，則根據個人喜好和代碼的可讀性選擇一種方法來撰寫。覺得使用原生函式較容易閱讀及維護，那就直接使用原生函式吧！ 結論 相連的選擇器：選擇器中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 空格相連的選擇器：指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 「+」相連的選擇器：同一層後的第一個元素，表示會選取大弟或大妹 「~」相連的選擇器：同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 「&gt;」相連的選擇器：剛好在下一層的所有指定元素，表示會選取親生的指定小孩 「,」相連的選擇器：需要相同樣式或是相同行為的元素綁在一起 選擇器用的好，書寫方面會更方便、選取某個元素時會更快速，也可以降低程式的複雜度，閱讀起來更舒服！ 你有什麼常用的選擇器嗎？歡迎跟大家分享～ 延伸閱讀 [官方文件] MDN CSS selectors [iT邦幫忙] JQuery 選擇器的補充 [iT邦幫忙] 事件冒泡","link":"/Frontend/JQuery/Analyzing-Six-Types-of-Combinator/"},{"title":"【VSCode】在 VSCode terminal 使用 git bash","text":"本篇重點 為什麼要使用 git bash VSCode terminal 選項新增 git bash 將 git bash 設定為 VSCode 的預設終端機 我本身是使用 Windows 系統，為了熟悉 Linux 環境和 Git 的相關指令，嘗試了一些方法 虛擬環境 - VirtualBox、docker windows 子系統 - WSL git for windows - git bash 剛開始是使用 VirtualBox 創建 ubuntu 來熟悉 linux 的指令，後來覺得每次都要啟動虛擬機很麻煩，最後選擇 git bash 來在本機實做。 為什麼要使用 git bash在 windows 環境下： 可以使用大部分的 linux 系統指令，例如 ls、cp、mv、rm 等 可以使用 git 版本控制工具 無須安裝虛擬機或 Windows 子系統 在 VSCode terminal 新增 git bash 選項一直都是有需要使用 git 的時候才叫出 git bash 執行指令，但這樣其實有點麻煩，而且還需要不斷切換視窗。 隨著對 VSCode 的了解，才知道 VSCode 有內建 terminal，windows 預設的 terminal 是 cmd 或是 powersell。接下來會把 git bash 設定到 VSCode 的 terminal 選項，這樣就可以直接在 VSCode 中使用了！ 1. 開啟 VSCode 設定檔 (JSON檔)方法一、使用快捷鍵開啟 使用按鍵 F1 或是 ctrl + shift + p 顯示所有命令 輸入 open settings 選取 Preferences: Open User Settings (Json) 3. 即可開啟設定檔 settings.json 方法二、從設定中開啟 點擊VSCode 左下角齒輪裡的設定 (快捷鍵 ctrl + ,) 2. 點擊右上角的 開啟設定(json) 3. 即可開啟設定檔 settings.json 2. 新增 git bash 到 terminal 選項 當前使用的 VSCode 版本為 1.84 將設定值寫入 settings.json settings.json12345&quot;terminal.integrated.profiles.windows&quot;: { &quot;Git Bash&quot;: { &quot;path&quot;: &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot;, }} 健忘筆記 &quot;path&quot; 請設定自己 git bash 的路徑，以及這邊的檔案是 bash.exe 不是 git-bash.exe。 &quot;terminal.integrated.profiles 的其他設定可以到官方文件查看。 設定後存檔，重新開啟 VSCode，使用按鍵 ctrl + ‵ ( ‵ 就是 ~ 鍵) 開啟終端機，就可以在選項中看到 git bash 了！ 終端機名稱設定 &quot;Git Bash&quot; 如果顯示不行使用或是終端機選項中沒有出現，嘗試修改名稱，使用 &quot;GitBash&quot; 或 &quot;Git_Bash&quot; 等，我的兩台電腦一台可以使用 &quot;Git Bash&quot; 一台則不行，爬文的結果此問題應該是 VSCode 版本導致，建議更新版本後再設定。 將 git bash 設定為 VSCode 的預設終端機terminal 增加 git bash 選項後，將其設為預設終端機，之後每次開終端機就都是 git bash 了 將設定值寫入 settings.json settings.json1&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot; 設定後存檔重新開啟 VSCode，終端機就會自動選擇 git bash 開啟了！ 健忘筆記 &quot;terminal.integrated.profiles.windows&quot; 和 &quot;terminal.integrated.defaultProfile.windows&quot; 是最新的設定參數，&quot;terminal.integrated.shell.windows&quot; 已是舊設定值無法使用。 快速切換 shell在終端機命令列打上 shell 名稱 bash / powershell / cmd 就可以快速切換。 切換 powershell 切換 cmd 切換 git bash 結論對我來說，能夠在同一個視窗內完成所有工作，直接在 VSCode 中查看程式並執行指令是最方便的方式。 這邊整理需要注意的地方： 查看 VSCode 版本，有些版本設定會有問題，當前使用的版本為 1.84 設定 git bash 的路徑 “path”，請填寫自己 bash.exe 的檔案位置 \"terminal.integrated.shell.windows\" 已棄用，請使用 \"terminal.integrated.profiles.windows\" 和 \"terminal.integrated.defaultProfile.windows\" 你們覺得這樣方便嗎？ 歡迎分享你的看法～ 延伸閱讀 [官方文件] VSCode terminal 介紹 [官方文件] VSCode terminal 設定檔 [為你自己學Git] 終端機是甚麼？ [為你自己學Git] 什麼是Git？為什麼要學習它？","link":"/VSCode/Using-Git-Bash-in-VSCode/"}],"tags":[{"name":"php","slug":"php","link":"/tags/php/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"git bash","slug":"git-bash","link":"/tags/git-bash/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Css","slug":"Frontend/Css","link":"/categories/Frontend/Css/"},{"name":"JQuery","slug":"Frontend/JQuery","link":"/categories/Frontend/JQuery/"}],"pages":[{"title":"404 - 網頁不存在","text":"這是一個不存在的頁面 抱歉，找不到你要的頁面 😢將在 5 秒後返回首頁。 let countTime = 5; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if (countTime === 0) { location.href = 'https://forgetfulengineer.github.io'; } setTimeout(() => { count(); }, 1000); } count();","link":"/404.html"}]}