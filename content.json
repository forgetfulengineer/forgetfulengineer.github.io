{"posts":[{"title":"【PHP】4種判斷變數或陣列是否存在的方法","text":"本篇重點 使用 empty()、is_null()、isset() 或是直接使用if ($variable) 判斷式來判斷變數或陣列是否存在 資料檢查甚麼時候會有錯誤訊息(php error) 先了解這些會幫助你更快理解唷😁 【PHP】解析邏輯運算子 and、or、&amp;&amp;、|| 之間的差異【PHP、JavaScript】三種實用的符號運算子 ?:、??、??= 在開發動態網頁時，後端程式扮演了一個重要的角色，可能會處理來自前端程式的資料，也有可能處理來自資料庫的資料，在這種情況下，我們必須嚴謹地檢查數據的完整性，以確保後續的程式能夠順暢運行。那麼有哪些函數能夠進行這樣的檢查？ 首先先了解各種類型的判斷，判斷的類型有 無效值(null) 布林值(boolean) 字串(string) 數值(integer) 陣列(array) 判斷差異表比較不同的function在各種情況下的判斷 型態 if ($x) empty() isset() is_null() $x = null null false true false true $x is undefined null false true false true $x = true boolean true false true false $x = false boolean false true true false $x = ‘’ string false true true false $x = ‘1’ string true false true false $x = ‘0’ string false true true false $x = ‘-1’ string true false true false $x = ‘hello’ string true false true false $x = ‘true’ string true false true false $x = ‘false’ string true false true false $x = 1 integer true false true false $x = 0 integer false true true false $x = -1 integer true false true false $x = 666 integer true false true false $x = array() array false true true false $x = array(‘a’, ‘b’) array true false true false if ($x) 和 empty() 的判斷結果相反 isset() 和 is_null() 的判斷結果相反 螢光標記是我覺得特別要注意的判斷結果 範例 用戶填寫表格資料並送出資料，這些資料會從前端傳到後端程式，此時我們需要驗證是否有填入資料或是資料是否正確 php12345678&lt;?php// 使用 isset() 搭配 intval() 確認是否有參數傳入且為大於 0 的數值$age = isset($_POST['age']) &amp;&amp; intval($_POST['age']) &gt; 0 ? intval($_POST['age']) : 0;// 初步整理 $age 值後，檢查是否需要返回前端重新填寫年齡if ($age == 0) { // 返回前端請用戶重新填寫年齡} 情境一，填寫年齡 30 傳入後端，isset() 為 true，且 intval() 後數值大於零，$age = 30 往下接續處理 情境二，填寫年齡 0 傳入後端，isset() 為 true，但 intval() 後數值等於零，$age = 0 返回前端處理 情境三，無填寫年齡傳入後端，isset() 為 false，$age = 0 返回前端處理 健忘筆記 ? : 是一種條件運算符，稱為三元運算符，可以用來做因果判斷，詳細可參考 【PHP、JavaScript】三種實用的符號運算子 ?:、??、??= 動手做做看 前端資料傳入後端後做資料檢查 情境一，填寫年齡 30 傳入後端，isset() 為 true，且 intval() 後數值大於零，$age = 30 往下接續處理情境二，填寫年齡 0 傳入後端，isset() 為 true，但 intval() 後數值等於零，$age = 0 返回前端處理情境三，無填寫年齡傳入後端，isset() 為 false，$age = 0 返回前端處理 動手做做看 從資料庫撈取資料，並檢測是否有資料，如果為無資料需要做處理 情境一，從資料庫撈取會員資訊，並取得完整資料 php12345678910111213141516171819&lt;?php$user_data = array( 'name' =&gt; '小明', 'gender' =&gt; 'Male',);// 使用 if (!$user_data) 確認變數內是否有資料if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 false，原本 if ($user_data) 為 true，但碰到驚嘆號反轉布林值結果，因此為 false 跳過判斷// 使用 !is_array($user_data) 搭配 empty($user_data) 確認變數內是否有資料if (!is_array($user_data) || empty($user_data)) { // 無資料時的處理}// 結果：!is_array($user_data) 為 false，empty($user_data) 也為 false，因此跳過判斷 動手做做看 情境一，從資料庫撈取會員資訊，並取得完整資料 資料檢查1：if (!$user_data) 判斷為 false，原本 if ($user_data) 為 true，但碰到驚嘆號反轉布林值結果，因此為 false 跳過判斷資料檢查2：!is_array($user_data) 為 false，empty($user_data) 也為 false，因此跳過判斷 動手做做看 情境二，從資料庫撈取會員資訊，但沒有撈到資料寫入空陣列 php12345678910111213141516&lt;?php$user_data = array();// 使用 if (!$user_data) 確認變數內是否有資料if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 true 進入無資料處理// 使用 !is_array($user_data) 搭配 empty($user_data) 確認變數內是否有資料if (!is_array($user_data) || empty($user_data)) { // 無資料時的處理}// 結果：!is_array($user_data)為 false，但 empty($user_data) 為 true，因此進入無資料處理 動手做做看 情境二，從資料庫撈取會員資訊，但沒有撈到資料寫入空陣列 資料檢查1：if (!$user_data) 判斷為 true 進入無資料處理資料檢查2：!is_array($user_data)為 false，但 empty($user_data) 為 true，因此進入無資料處理 動手做做看 情境三，從資料庫撈取會員資訊，但沒有撈到資料寫入字串 php1234567891011121314&lt;?php$user_data = 'no_data';if (!$user_data) { // 無資料時的處理}// 結果：if (!$user_data) 判斷為 false 跳過判斷if (!is_array($user_data) || empty($user_data)) { // !is_array()為 true，因此進入無資料處理 // 無資料時的處理}// 結果：!is_array($user_data) 判斷為 true，因此進入無資料處理 健忘筆記 如果查找資料庫，沒有取得資料會寫入 array 以外的型態，那使用 !is_array($x) 搭配 empty() 來檢查資料會是更謹慎的做法 動手做做看 情境三，從資料庫撈取會員資訊，但沒有撈到資料寫入字串 資料檢查1：if (!$user_data) 判斷為 false 跳過判斷資料檢查2：!is_array($user_data) 判斷為 true，因此進入無資料處理 動手做做看 錯誤訊息在進行資料完整性檢查時，要確保資料的完整性，但又不希望出現錯誤訊息，那麼應該採用哪種函數? 這四種驗證方式除了兩兩相反外，還有一個很重要的差異 “錯誤訊息” 也就是PHP error。當變數 $x 沒有被賦值時，使用 if ($x) 和 is_null($x) 會引發錯誤訊息，但使用 isset($x) 和 empty($x) 不會，不過這些錯誤屬於較輕微的 E_NOTICE 級別，所以在沒有開啟PHP的所有錯誤提示的情況下是不會對網頁造成影響，但還是應該盡量處理這些錯誤。 範例 情境一，檢查陣列中不存在的索引 php12345&lt;?php$a = [];var_dump($a[1]); // NULL，錯誤訊息 Notice: Undefined offset: 1var_dump(isset($a[1])); // bool(false)，無錯誤訊息 $a 設定為一個空陣列，卻指定不存在的索引1，因此在 var_dump($a[1]) 的情況下會出現錯誤訊息 動手做做看 情境一，檢查陣列中不存在的索引 $a 設定為一個空陣列，卻指定不存在的索引1，因此在 var_dump($a[1]) 的情況下會出現錯誤訊息 動手做做看 情境二，判斷不存在的變數 php1234&lt;?php// $b 沒有被賦值var_dump(is_null($b)); // bool(true)，Notice: Undefined variable: b var_dump(empty($b)); // bool(true)，無錯誤訊息 $b 沒有被賦值，因此在 is_null($b) 的情況下會出現錯誤訊息。 動手做做看 情境二，檢查不存在的變數 $b 沒有被賦值，因此在 is_null($b) 的情況下會出現錯誤訊息 動手做做看 情境三，有個陣列內的值需要做處理，但這個值不一定存在，如果不存在就不需要處理 php123456789101112131415161718192021222324252627282930&lt;?php// 如果$user內沒有'age'$user = array( 'name' =&gt; '小明');if ($user['age']) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：出現錯誤訊息 Notice: Undefined index: age 並跳出判斷，'adult'沒有寫入資料// 為了不跳出錯誤訊息且正常判斷，可以改成!empty($user['age'])if (!empty($user['age'])) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：無錯誤訊息跳出判斷// 如果$user內有'age'$user = array( 'name' =&gt; '小明', 'age' =&gt; 10);if (!empty($user['age'])) { $user['adult'] = ($user['age'] &gt;= 18) ? true : false;}// 結果：!empty($user['age'])判斷為true，$user['adult'] 寫入 false 判斷用戶是否成年，而 $user 內 ‘age’ 的值不一定存在，因此需要檢查 ‘age’ 是否存在再做處理 健忘筆記 在不確定資料內部狀況的情況下，可以使用 empty() 來讓錯誤訊息消失 動手做做看 情境三，有個陣列內的值需要做處理，但這個值不一定存在，如果不存在就不需要處理 資料檢查1：出現錯誤訊息 Notice: Undefined index: age 並跳出判斷，'adult'沒有寫入資料資料檢查2：無錯誤訊息跳出判斷資料檢查3：!empty($user['age'])判斷為true，$user['adult'] 寫入 false 動手做做看 結論依不同的需求，使用function 來判斷變數或陣列的完整性。 if ($x) 和 empty($x) 的判斷結果相反 isset($x) 和 is_null($x) 的判斷結果相反 無設定 $x 值的狀況下 if ($x) 和 is_null($x) 會跳錯誤訊息 isset($x) 和 empty($x) 則不會跳錯誤訊息 檢查完整性可以減少 bug 的發生，不用修 bug 就是開心😆～ 你平常會檢查變數或陣列的資料完整性嗎? 是用甚麼方法處理呢? 歡迎留言跟大家分享！ 動手做做看 PHP 線上編輯器 參考資料 【官方文件】PHP類型比較表 延伸閱讀 【官方文件】資料類型的介紹 【官方文件】判斷式(if)介紹 【官方文件】布林值false的定義 【官方文件】PHP error 介紹","link":"/Backend/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/"},{"title":"【VSCode】在 VSCode terminal 使用 git bash","text":"本篇重點 為什麼要使用 git bash VSCode terminal 選項新增 git bash 將 git bash 設定為 VSCode 的預設終端機 我本身是使用 Windows 系統，為了熟悉 Linux 環境和 Git 的相關指令，嘗試了一些方法 虛擬環境 - VirtualBox、docker windows 子系統 - WSL git for windows - git bash 剛開始是使用 VirtualBox 創建 ubuntu 來熟悉 linux 的指令，後來覺得每次都要啟動虛擬機很麻煩，最後選擇 git bash 來在本機實做。 為什麼要使用 git bash在 windows 環境下： 可以使用大部分的 linux 系統指令，例如 ls、cp、mv、rm 等 可以使用 git 版本控制工具 無須安裝虛擬機或 Windows 子系統 在 VSCode terminal 新增 git bash 選項一直都是有需要使用 git 的時候才叫出 git bash 執行指令，但這樣其實有點麻煩，而且還需要不斷切換視窗。 隨著對 VSCode 的了解，才知道 VSCode 有內建 terminal，windows 預設的 terminal 是 cmd 或是 powersell。接下來會把 git bash 設定到 VSCode 的 terminal 選項，這樣就可以直接在 VSCode 中使用了！ 1. 開啟 VSCode 設定檔 (JSON檔)方法一、使用快捷鍵開啟 使用按鍵 F1 或是 ctrl + shift + p 顯示所有命令 輸入 open settings 選取 Preferences: Open User Settings (Json) 3. 即可開啟設定檔 settings.json 方法二、從設定中開啟 點擊VSCode 左下角齒輪裡的設定 (快捷鍵 ctrl + ,) 2. 點擊右上角的 開啟設定(json) 3. 即可開啟設定檔 settings.json 2. 新增 git bash 到 terminal 選項 當前使用的 VSCode 版本為 1.84 將設定值寫入 settings.json settings.json12345&quot;terminal.integrated.profiles.windows&quot;: { &quot;Git Bash&quot;: { &quot;path&quot;: &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot;, }} 健忘筆記 &quot;path&quot; 請設定自己 git bash 的路徑，以及這邊的檔案是 bash.exe 不是 git-bash.exe。 &quot;terminal.integrated.profiles 的其他設定可以到官方文件查看。 設定後存檔，重新開啟 VSCode，使用按鍵 ctrl + ‵ ( ‵ 就是 ~ 鍵) 開啟終端機，就可以在選項中看到 git bash 了！ 終端機名稱設定 &quot;Git Bash&quot; 如果顯示不行使用或是終端機選項中沒有出現，嘗試修改名稱，使用 &quot;GitBash&quot; 或 &quot;Git_Bash&quot; 等，我的兩台電腦一台可以使用 &quot;Git Bash&quot; 一台則不行，爬文的結果此問題應該是 VSCode 版本導致，建議更新版本後再設定。 將 git bash 設定為 VSCode 的預設終端機terminal 增加 git bash 選項後，將其設為預設終端機，之後每次開終端機就都是 git bash 了 將設定值寫入 settings.json settings.json1&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot; 設定後存檔重新開啟 VSCode，終端機就會自動選擇 git bash 開啟了！ 健忘筆記 &quot;terminal.integrated.profiles.windows&quot; 和 &quot;terminal.integrated.defaultProfile.windows&quot; 是最新的設定參數，&quot;terminal.integrated.shell.windows&quot; 已是舊設定值無法使用。 快速切換 shell在終端機命令列打上 shell 名稱 bash / powershell / cmd 就可以快速切換。 切換 powershell 切換 cmd 切換 git bash 結論對我來說，能夠在同一個視窗內完成所有工作，直接在 VSCode 中查看程式並執行指令是最方便的方式。 這邊整理需要注意的地方： 查看 VSCode 版本，有些版本設定會有問題，當前使用的版本為 1.84 設定 git bash 的路徑 “path”，請填寫自己 bash.exe 的檔案位置 \"terminal.integrated.shell.windows\" 已棄用，請使用 \"terminal.integrated.profiles.windows\" 和 \"terminal.integrated.defaultProfile.windows\" 你們覺得這樣方便嗎？ 歡迎分享你的看法～ 延伸閱讀 [官方文件] VSCode terminal 介紹 [官方文件] VSCode terminal 設定檔 [為你自己學Git] 終端機是甚麼？ [為你自己學Git] 什麼是Git？為什麼要學習它？","link":"/Other/VSCode/Using-Git-Bash-in-VSCode/"},{"title":"【PHP】解析邏輯運算子 and、or、&amp;&amp;、|| 之間的差異","text":"本篇重點 and 和 &amp;&amp;之間有什麼差別，它們分別代表什麼意思？ or 和 || 之間有什麼差別，它們分別代表什麼意思？ 邏輯運算子的執行順序 邏輯運算子使用建議 先了解這些會幫助你更快理解唷😁 【PHP】4種判斷變數或陣列是否存在的方法【PHP、JavaScript】三種實用的符號運算子 ?:、??、??= 「分數有及格嗎？」、「考卷的姓名和學號都是正確的嗎？」、「這張考卷是 john 還是tom 的？」，在日常生活中很常用到的條件判斷，在程式中也很常出現，PHP 提供了很多符號來輔助我們，使用邏輯運算子來達到目的。 &amp;&amp;、AND vs || 、OR &amp;&amp;、AND 是「且、和」的意思，符號兩邊的條件都達成，結果為 true，反之為 false ||、OR 是「或」的意思，符號兩邊依左至右判斷，如果有條件達成，結果為 true，反之為 false 範例依學生的資訊做條件處理 實例搶先看 &&、AND vs || 、OR &&、AND：「且、和」的意思，符號兩邊的條件都達成，結果為 true，反之為 false||、OR：「或」的意思，符號兩邊依左至右判斷，如果有條件達成，結果為 true，反之為 false 實例搶先看 php12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php// 設定學生 'john' 的資訊$name = 'john';$score = 60;$gender = 'male';// &amp;&amp;、AND 範例// 判斷學生是 john，且分數是及格if ($name == 'john' &amp;&amp; $score &gt;= 60) { echo '判斷為true，學生是 john，且分數是及格';} else { echo '判斷為false';}// 結果：if ($name == 'john' &amp;&amp; $score &gt;= 60) 判斷為true，「&amp;&amp;」兩邊的條件皆正確// 判斷學生不是john，且性別是男生if ($name != 'john' AND $gender == 'male') { echo '判斷為true，學生不是john，且性別是男生';} else { echo '判斷為false';}// 結果：if ($name != 'john' AND $gender == 'male') 判斷為 false，第一個條件學生不是 john 是錯誤的，因此也不用看第二個條件了，整個判斷式直接錯誤// ||、OR 範例// 判斷學生是john或是學生是女生if ($name == 'john' || $gender == 'female') { echo '判斷為true，學生是john，或是學生是女生';} else { echo '判斷為false';}// 結果：if ($name == 'john' || $gender == 'female') 判斷為 true，第一個條件學生是 john 是正確的，因此也不用看第二個條件了，整個判斷式直接正確// 判斷學生分數不及格或是這位學生不是男生if ($score &lt; 60 OR $gender != 'male') { echo '判斷為true，學生分數不及格或是這位學生不是男生';} else { echo '判斷為false';}// 結果：if ($name == 'john' || $gender == 'female') 判斷為 false，第一個條件不正確，接續判斷第二個條件，第二個條件也不正確 動手做做看 動手做做看 &amp;&amp; vs AND 以及 || vs OR接著來比較 and 和 &amp;&amp; 之間以及 or 和 || 之間的差異 簡單來說它們的差異就是執行的優先順序（Operator Precedence）不同 「&amp;&amp;」的執行順序比「=」高，而「=」的執行順序比「AND」高 「||」的執行順序比「=」高，而「=」的執行順序比「OR」高 範例依學生的資訊做條件處理 實例搶先看 && vs AND 以及 || vs OR 「&&」的執行順序比「=」高，而「=」的執行順序比「AND」高「||」的執行順序比「=」高，而「=」的執行順序比「OR」高 實例搶先看 php123456789101112131415161718192021222324252627282930313233&lt;?php// 設定學生 'Tom' 的資訊$student_id = 123;$name = 'tom';$gender = 'male';$score = 49;// &amp;&amp;、AND 範例// 判斷學生學號是123，且分數是及格$answer = $student_id == 123 &amp;&amp; $score &gt;= 60;// 結果：判斷結果為 fasle，第二個條件錯誤$answer = $student_id == 123 AND $score &gt;= 60;// 結果：判斷結果為 true，因為「=」的執行順序比「AND」高，因此變成先執行「$answer = $student_id== 123」，導致 $answer 先賦值$answer = ($student_id == 123 AND $score &gt;= 60);// 結果：判斷結果為 false，因為加了括號改變執行順序，先執行「$student_id == 123 AND $score &gt;= 60」// 判斷這位學生是 john 還是 tom$answer = $name == 'john' || $name == 'tom';// 結果：判斷結果為 true，第一個條件正確$answer = $name == 'john' OR $name == 'tom';// 結果：判斷結果為 false，因為「=」的執行順序比「OR」高，因此變成先執行「$answer = $name == 'john'」，導致 $answer 先賦值$answer = ($name == 'john' OR $name == 'tom');// 結果：判斷結果為 true，因為加了括號改變執行順序，先執行「$name == 'john' OR $name == 'tom'」 健忘筆記 判斷式建議使用 &amp;&amp; 和 || ，如果要使用 AND 和 OR 記得加上括號減少錯誤發生～詳細的執行順序看這裡！ 動手做做看 動手做做看 結論條件判斷時，依需求使用不同的邏輯運算子幫助我們達到目的。 「&amp;&amp;」、「AND」 是「且」的意思，符號兩邊的條件皆須達成時使用 「||」、「OR」 是「或」的意思，符號兩邊的條件只需要有一個條件達成時使用 「&amp;&amp;」的執行順序比「=」高，而「=」的執行順序比「AND」高 「||」的執行順序比「=」高，而「=」的執行順序比「OR」高 運算子的執行優先順序大大的影響判斷的結果，所以在使用時要多加注意，不然會得到意想不到的結果😆，建議使用「&amp;&amp;」和「||」可以減少錯誤的發生～ 動手做做看 PHP 線上編輯器 延伸閱讀 【官方文件】邏輯運算子介紹 【官方文件】運算子優先級","link":"/Backend/PHP/Comparing-the-Differences-Between-Logical-Operators/"},{"title":"【jQuery、css】解析六種組合選擇器：相連、+、～、&gt;、,、空格","text":"本篇重點 組合選擇器是甚麼 選擇器內的符號( +、~、&gt; 、, 等)有甚麼含意 jQuery 要使用組合選擇器還是原生的函式 設定 CSS 樣式或是 jQuery 要操作 DOM 元素時，會用到選擇器選取元素，兩者的選擇器類似，你可能看過選擇器中有一些符號，例如 +、~、&gt; 或是空格，這些將兩個元素組合起來的選擇器就稱為「組合選擇器 Combinator」，熟悉符號的意思可以加速抓到想要的元素，甚至提升整體效能，那來了解這些符號分別代表甚麼意思吧！ 標籤之間的關係先了解 HTML 階層間的關係，可以用家族的關係來了解每個階層。 舉例來說，以 &lt;div id=&quot;john&quot;&gt; 角度出發，看看下面標籤之間的關係 html12345678&lt;div&gt;john的父親(父層) &lt;p&gt;john的哥哥或姊姊&lt;/p&gt; &lt;div id=&quot;john&quot;&gt; &lt;p&gt;john的孩子(子層)&lt;/p&gt; &lt;/div&gt; &lt;p&gt;john的弟弟或妹妹&lt;/p&gt;&lt;/div&gt;&lt;div&gt;john父親的弟弟或妹妹&lt;/div&gt; 接下來會使用家族關係來解釋各個組合選擇器的使用方法。 健忘筆記 可以使用 tag、id、class 等選擇器做組合選擇器 相連的選擇器選擇器相連且中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 範例 實例搶先看 相連的選擇器 選擇器相連且中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 html123456&lt;div id=&quot;father&quot;&gt; john的父親(父層) &lt;div class=&quot;select&quot; id=&quot;tom&quot;&gt;tom (john的哥哥)&lt;/div&gt; &lt;p class=&quot;select&quot; id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p&gt;john的弟弟或妹妹&lt;/p&gt;&lt;/div&gt; css1234567#john.select { background-color: orange;}div.select#tom { background-color: gray;} jQuery1234567$(&quot;#john.select&quot;).click(function () { alert(&quot;john&quot;);});$(&quot;div#tom.select&quot;).click(function () { alert(&quot;tom&quot;);}); 空格相連的選擇器指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 範例 實例搶先看 空格相連的選擇器 指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 html12345678910&lt;p class=&quot;select&quot;&gt;class=&quot;select&quot;&lt;/p&gt;&lt;div id=&quot;father&quot;&gt; john的父親(父層) &lt;p class=&quot;find&quot;&gt;class=&quot;find&quot;&lt;/p&gt; &lt;div class=&quot;select&quot; id=&quot;tom&quot;&gt;tom (john的哥哥)&lt;/div&gt; &lt;p class=&quot;select&quot; id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot;&gt;joy (john的&lt;b class=&quot;select&quot;&gt;弟弟或妹妹&lt;/b&gt;)&lt;/p&gt; &lt;p class=&quot;find&quot;&gt;class=&quot;find&quot;&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot;&gt;class=&quot;select&quot;&lt;/p&gt; css1234567#father .select { background-color: orange;}div #joy { background-color: gray;} 健忘筆記 使用空格只會選取 &lt;div id=&quot;father&quot;&gt; 內層的元素，因此在 &lt;div id=&quot;father&quot;&gt; 外層上下的 class=&quot;select&quot; 元素不會有反應 jQuery1234567$(&quot;#father .select&quot;).click(function () { alert(&quot;orange&quot;);});$(&quot;div #joy&quot;).click(function () { alert(&quot;gray&quot;);}); 實作這個例子時你會發現，點擊文字”弟弟或妹妹” 會發現先跳出 orange 再跳出 gray，這是JS的事件冒泡，如果要解決這個問題可以使用 、event.stopPropagation() 來處理。 jQuery1234$(&quot;#father .select&quot;).click(function() { alert(&quot;orange&quot;); event.stopPropagation()}); 健忘筆記 事件冒泡：指內層元素觸發事件，外層元素也跟著觸發 選取同一家族內的指定元素，也可以使用 jquery 函數的 .find() 來選取 jQuery123$(&quot;#father&quot;).find('.find').click(function () { alert(&quot;find&quot;);}); 「+」相連的選擇器同一層後的第一個元素，表示會選取大弟或大妹 範例 實例搶先看 「+」相連的選擇器 同一層後的第一個元素，表示會選取大弟或大妹 html1234567&lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot;&gt;joy (john的弟弟或妹妹)&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot; id=&quot;first&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;p class=&quot;select&quot;&gt;father的二弟或二妹&lt;/p&gt; css123#father + .select { background-color: orange;} 健忘筆記 使用「+」只會選取 &lt;div id=&quot;father&quot;&gt; 同層後的第一個元素，所以只有 &lt;p class=&quot;select&quot; id=&quot;first&quot;&gt; 會被選取 jQuery123$(&quot;#father + .select&quot;).click(function() { alert(&quot;click&quot;);}); 同層後的第一個元素，也可以使用 jquery 函數的 .next() 來選取 jQuery12345678$(&quot;#john&quot;).next().click(function () { alert(&quot;.next()&quot;);});// 指定同層後的第一個元素$(&quot;#first&quot;).next(&quot;.select&quot;).click(function () { alert(&quot;.next('.select')&quot;);}); 健忘筆記 如果 .next() 有指定元素例如 .next(&quot;.select&quot;)，表示會選取同一層後第一個是 class=&quot;select&quot; 的元素，如果第一個元素不是則不會選取 「~」相連的選擇器同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 範例 實例搶先看 「~」相連的選擇器 同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 html12345678910&lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot;&gt;john&lt;/p&gt; &lt;p id=&quot;joy&quot; class=&quot;nextAll&quot;&gt;joy (john的弟弟或妹妹)&lt;/p&gt; &lt;p id=&quot;betty&quot;&gt;betty (joy的弟弟或妹妹)&lt;/p&gt; &lt;p id=&quot;tom&quot; class=&quot;nextAll&quot;&gt;tom (joy的弟弟或妹妹)&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot; id=&quot;first&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;p id=&quot;second&quot;&gt;father的二弟或二妹&lt;/p&gt;&lt;p class=&quot;select&quot; id=&quot;second&quot;&gt;father的三弟或三妹&lt;/p&gt; css123#father ~ .select { background-color: orange;} 健忘筆記 使用「~」只會選取 &lt;div id=&quot;father&quot;&gt; 同層後的所有指定元素，所以 &lt;p class=&quot;select&quot;&gt;father的大哥或大姐&lt;/p&gt; 不會反應 jQuery123$(&quot;#father ~ .select&quot;).click(function () { alert(&quot;click&quot;);}); 同層後的所有元素，也可以使用 jquery 函數的 .nextAll() 來選取 jQuery12345678$(&quot;#john&quot;).nextAll().click(function(){ alert('nextAll');})// 指定同層後的所有指定元素$(&quot;#john&quot;).nextAll(&quot;.nextAll&quot;).click(function(){ alert('nextAll(&quot;.nextAll&quot;)');}) 健忘筆記 如果 .nextAll() 有指定元素例如 .nextAll(&quot;.nextAll&quot;)，表示會選取同一層後所有有 class=&quot;nextAll&quot; 的元素，如果沒有則不會選取 「&gt;」相連的選擇器剛好在下一層的所有指定元素，表示會選取親生的指定小孩 範例 實例搶先看 「>」相連的選擇器 剛好在下一層的所有指定元素，表示會選取親生的指定小孩 html1234567891011121314&lt;p class=&quot;select&quot;&gt;father的哥哥或姐姐&lt;/p&gt;&lt;div id=&quot;father&quot;&gt;father &lt;p id=&quot;john&quot; class=&quot;select&quot;&gt;john&lt;/p&gt; &lt;div id=&quot;joy&quot;&gt;joy &lt;p id=&quot;tim&quot; class=&quot;select&quot;&gt;tim (joy的小孩)&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;tom&quot; class=&quot;select&quot;&gt;father的子層&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;select&quot;&gt;father的大弟或大妹&lt;/p&gt;&lt;div id=&quot;mother&quot;&gt;mother &lt;p id=&quot;ken&quot; class=&quot;select&quot;&gt;ken&lt;/p&gt; &lt;p id=&quot;eason&quot;&gt;eason&lt;/p&gt; &lt;p id=&quot;kevin&quot; class=&quot;select&quot;&gt;kevin&lt;/p&gt;&lt;/div&gt; 這邊比較以空格和以「&gt;」相連的差別 css1234567#father .select { color: green;}#father &gt; .select { background-color: orange;} jQuery123$(&quot;#father &gt; .select&quot;).click(function () { alert(&quot;click&quot;);}); 健忘筆記 使用「&gt;」只會選取 &lt;div id=&quot;father&quot;&gt; 下一層的所有指定元素，因此不會選取到 &lt;p id=&quot;tim&quot; class=&quot;select&quot;&gt;tim (joy的小孩)&lt;/p&gt;&lt;div&gt; 下一層的所有元素，也可以使用 jquery 函數的 .children() 來選取 jQuery12345678$(&quot;#mother&quot;).children().click(function(){ alert('children()');})// 指定元素下一層的所有指定元素$(&quot;#mother&quot;).children(&quot;.select&quot;).click(function(){ alert('children(&quot;.select&quot;)');}) 健忘筆記 如果 .children() 有指定元素例如 .children(&quot;.select&quot;)，表示會選取下一層中所有有 class=&quot;select&quot; 的元素，如果沒有則不會選取 「,」相連的選擇器需要相同樣式或是相同行為的元素綁在一起 範例 實例搶先看 「,」相連的選擇器 需要相同樣式或是相同行為的元素綁在一起 html1234567&lt;p class=&quot;example1&quot;&gt;example1&lt;/p&gt;&lt;p class=&quot;example2&quot;&gt;example2&lt;/p&gt;&lt;p class=&quot;example3&quot;&gt;example3&lt;/p&gt;&lt;div&gt;div &lt;p class=&quot;example4&quot;&gt;example4&lt;/p&gt; &lt;span class=&quot;example5&quot;&gt;example5&lt;/span&gt;&lt;/div&gt; css12345.example1,.example3,div &gt; span { background-color: orange;} jQuery123$(&quot;.example1, .example3, div &gt; span&quot;).click(function () { alert(&quot;click&quot;);}); 健忘筆記 可以使用各種選擇器選取元素，再用「,」綁在一起 jQuery 要使用組合選擇器還是原生的函式jQuery 選取元素有很多方法，這邊比較組合選擇器和使用 jQuery 的函數的差異 例如：選取 id=”father” 層底下的所有 class=”select” 元素 jQuery12345/* 組合選擇器 */$(&quot;#father .select&quot;)/* jQuery 的函數 */$(&quot;#father&quot;).find(&quot;.select&quot;) 兩種方式都可以達到同樣的效果。在選取元素數量較少的情況下，兩者的差異非常微小，因為目前的瀏覽器及 jQuery 有對此進行優化。但如果選取的元素數量龐大，使用組合選擇器是較有效率的。 總結來說，如果不用考慮效能，則根據個人喜好和代碼的可讀性選擇一種方法來撰寫。覺得使用原生函式較容易閱讀及維護，那就直接使用原生函式吧！ 結論 相連的選擇器：選擇器中間沒有空格或是符號，表示同一個 tag 要同時符合所有條件 空格相連的選擇器：指定元素層內的所有指定元素，表示同一家族內的指定元素都會選擇 「+」相連的選擇器：同一層後的第一個元素，表示會選取大弟或大妹 「~」相連的選擇器：同一層後的所有指定元素，表示會選取所有指定弟弟或妹妹 「&gt;」相連的選擇器：剛好在下一層的所有指定元素，表示會選取親生的指定小孩 「,」相連的選擇器：需要相同樣式或是相同行為的元素綁在一起 選擇器用的好，書寫方面會更方便、選取某個元素時會更快速，也可以降低程式的複雜度，閱讀起來更舒服！ 你有什麼常用的選擇器嗎？歡迎跟大家分享～ 動手做做看 codepen 線上編輯器 延伸閱讀 [官方文件] MDN CSS selectors [iT邦幫忙] JQuery 選擇器的補充 [iT邦幫忙] 事件冒泡","link":"/Frontend/JQuery/Analyzing-Six-Types-of-Combinator/"},{"title":"【MySQL】解析資料庫語言類型 DDL、DML、DCL、DQL","text":"本篇重點 了解 DML、DDL、DCL 和 DQL 分別是資料庫裡的哪些功能 以下說明會以 MySQL 的指令做說明 在資料庫管理中，DML、DDL、DCL 和 DQL 是資料庫領域中的四種類型，它們各自負責著不同的任務。 舉例的中括號 [ ] 為替換字串 DDL (Data Definition Language) 數據定義語言DDL用於定義和管理資料庫結構。 包括創建、修改和刪除資料庫、資料表、索引等對象的操作。 常見指令 CREATE：建立資料庫的物件 (資料表、索引等) DESCRIBE：查詢資料表的結構資訊 ALTER：修改現有資料庫對象的結構 (新增欄位、修改資料型別等) TRUNCATE：刪除資料表中的所有資料，但保留資料表的結構 DROP：刪除資料庫的物件 (資料表、索引等) 實例搶先看 DDL 數據定義語言 CREATE：建立資料庫的物件 (資料表、索引等)DESCRIBE：查詢資料表的結構資訊ALTER：修改現有資料庫對象的結構 (新增欄位、修改資料型別等)DROP：刪除資料庫的物件 (資料表、索引等) 實例搶先看 舉例創建資料庫 mysql1234CREATE DATABASE [資料庫名稱];// 創建 &quot;mydatabase&quot; 資料庫CREATE DATABASE mydatabase; 創建資料表 mysql12345678CREATE TABLE [資料表名稱];// 創建 &quot;customers&quot; 資料表CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY,name VARCHAR(50),email VARCHAR(100)); 查詢資料表的結構資訊 mysql1234DESCRIBE [資料表名稱];// 查看 &quot;customers&quot; 資料表結構資訊DESCRIBE customers; 修改資料表結構 mysql1234567ALTER TABLE [資料表名稱] [修改事項];// &quot;customers&quot; 資料表新增一個欄位 &quot;phone&quot;ALTER TABLE customers ADD phone VARCHAR(20);// 刪除 &quot;customers&quot; 資料表的 &quot;phone&quot; 欄位ALTER TABLE customers DROP COLUMN phone; 清空資料表所有資料 mysql1234TRUNCATE TABLE [資料表名稱];// 清空 &quot;customers&quot; 資料表內所有內容TRUNCATE TABLE customers; 刪除資料表 mysql1234DROP TABLE [資料表名稱];// 刪除 &quot;customers&quot; 資料表DROP TABLE customers; 健忘筆記 刪除資料功能 (TRUNCATE 指令或刪除資料表的欄位等) 無法回滾（Rollback），一旦執行就無法還原被刪除的資料。在使用刪除功能時，請再三確認要刪除的資料。 動手做做看 動手做做看 DML (Data Manipulation Language) 數據操作語言DML 是用於操作和處理資料。 包括對資料進行插入、更新和刪除等操作。 常見指令 INSERT INTO：新增資料到資料表中 UPDATE：更改資料表中的資料 DELETE：刪除資料表中的資料 健忘筆記 在一些資料庫系統中，SELECT 指令也可能被視為 DML 指令的一部分，這取決於特定資料庫的標準。但在 MySQL 中，通常將 SELECT 指令歸類為 DQL 指令。 實例搶先看 DML 數據操作語言 INSERT INTO：新增資料到資料表中SELECT：查詢資料庫中的資料UPDATE：更改資料表中的資料DELETE：刪除資料表中的資料 實例搶先看 舉例新增資料 mysql1234INSERT INTO [資料庫名稱] ([欄位]) VALUES ([值]);// 在 &quot;customers&quot; 資料表新增一筆客戶資料INSERT INTO customers (name, email) VALUES ('John', 'john@example.com'); 更新資料 mysql1234UPDATE [資料庫名稱] SET [修改值] WHERE [條件];// 在 &quot;customers&quot; 資料表更新一筆客戶資料UPDATE customers SET email = 'newJohn@example.com' WHERE name = 'John'; 刪除資料 mysql1234DELETE FROM [資料庫名稱] WHERE [條件];// 在 &quot;customers&quot; 資料表刪除一筆客戶資料DELETE FROM customers WHERE name = 'John'; 動手做做看 動手做做看 DQL (Data Query Language) 數據查詢語言DQL 用於查詢資料庫的資料。 主要目的是檢索所需的數據，而不涉及對數據進行修改。 常見指令 SELECT：查詢資料庫中的資料 WHERE：條件篩選資料 DISTINCT：檢索唯一的資料值 ORDER BY：依指定的欄位排序資料 GROUP BY：依指定的欄位分組 想了解指令的執行順序，可以參考 【MySQL】DQL 指令的執行順序與效能優化 實例搶先看 DQL 數據查詢語言 SELECT：查詢資料庫中的資料WHERE：條件篩選資料DISTINCT：檢索唯一的資料值ORDER BY：按照指定的欄位排序資料GROUP BY：依指定的欄位分組 實例搶先看 舉例查詢資料 mysql1234SELECT [欄位名稱] FROM [資料表名稱];// 搜索 table_name 資料表內所有欄位的資料SELECT * FROM table_name; 篩選條件 mysql1234SELECT [欄位名稱] FROM [資料表名稱] WHERE [篩選條件];// 搜索 table_name 資料表內 uid = 123 的資料SELECT * FROM table_name WHERE uid = 123; 搜索唯一值 mysql1234SELECT DISTINCT [欄位名稱] FROM [資料表名稱];// 搜索 order_list 資料表內 uid 唯一值的資料SELECT DISTINCT uid FROM order_list; 依指定欄位排序資料 mysql1234567SELECT [欄位名稱] FROM [資料表名稱] ORDER BY [欄位名稱] (ASC/DESC);// 搜索 order_list 資料表內所有資料並以uid做排序SELECT * FROM order_list ORDER BY uid;// 設定順序由大排到小SELECT * FROM order_list ORDER BY uid DESC; 健忘筆記 ORDER BY 未指定排序，預設使用 ASC (升冪)，順序由小排到大，如果想要由大排到小，可以設定 ORDER BY [欄位名稱] DESC; 依指定的欄位分組 mysql1234SELECT [欄位名稱] FROM [資料表名稱] GROUP BY [欄位名稱];// 依 team 去分組，計算每組的人數SELECT team, COUNT(*) FROM table_name GROUP BY team; 動手做做看 動手做做看 DCL (Data Control Language) 數據控制語言DCL 用於控制資料庫的使用權限和訪問權限。 包括授予、撤銷用戶的權限，以及確保資料庫的安全性和完整性。 常見指令 CREATE USER：創建新的使用者 DROP USER：刪除現有的使用者 GRANT：授予使用者特定的權限和許可權 REVOKE：撤銷使用者的特定權限和許可權 舉例創建新的使用者 mysql1234CREATE USER [使用者名稱]@[IP位置或主機名] IDENTIFIED BY 'password';// 創建新使用者 &quot;mary&quot;，並設定密碼CREATE USER 'mary'@'localhost' IDENTIFIED BY 'password'; 健忘筆記 IDENTIFIED BY 是用於設定使用者密碼的指令，可以省略這個指令讓使用者直接進入資料庫，但這樣就有安全性的問題 刪除現有的使用者 mysql1234DROP USER [使用者名稱]@[IP位置或主機名];// 刪除資料庫使用者 &quot;mary&quot;DROP USER 'mary'@'localhost'; 授予權限 mysql1234GRANT [權限] ON [資料庫名稱].* TO [使用者名稱]@[IP位置或主機名];// 授予 &quot;john&quot; 在 my_database 搜尋和寫入和刪除的權限GRANT SELECT, INSERT, DELETE ON my_database.* TO 'john'@'localhost'; 健忘筆記 ‘john‘@’localhost’ 是用來指定使用者帳號和使用者連接的 IP，指定連接 IP 確保資料庫的安全性my_database.* 是指定 my_database 資料庫的所有資料表，也可以指定特定資料表的權限，例如 my_database.my_table 收回權限 mysql1234REVOKE [權限] ON [資料庫名稱].* FROM [使用者名稱]@[IP位置或主機名];// 收回 &quot;john&quot; 在 my_database 刪除的權限REVOKE DELETE ON my_database.* FROM 'john'@'localhost'; 結論有一次在看 MySQL 文件的時候裡面提到 DQL，但也沒有特別解釋什麼是 DQL，後來去查才知道這是資料庫語言類型，感覺很容易忘記所以有了這篇😆 DDL：定義和管理資料庫結構 DML：操作和處理資料 DQL：查詢資料庫的資料 DCL：控制資料庫的使用權限和訪問權限。 動手做做看 mysql 線上編輯器","link":"/Backend/MySQL/Analyzing-4-Types-of-Database-Language/"},{"title":"【Git】了解 git config 設定","text":"本篇重點 了解設定區域：--system, --global, --local git config 常見設定 查詢 git config 設定 刪除 git config 設定 設定的區域依需求做不同範圍的設定，在不同區域的設定影響 git 操作的範圍 當前儲存庫設定 --local在資料夾建立 git 環境後，這個資料夾就是當前儲存庫的設定區域 設定檔文件通常位於當前資料夾的 .git/config 用戶級別設定 --global系統用戶的設定區域，會影響當前用戶所建立的所有儲存庫區域。 設定檔文件通常位於用戶家目錄下的 .gitconfig 或 .config/git/config 系統級別設定 --system系統管理員的設定區域，會影響所有用戶所建立的所有儲存庫區域。 設定檔文件通常位於 /etc/gitconfig 健忘筆記 如果想查詢各個區域的設定檔，可以使用 git config --list --show-origin [區域]，例如 git config --list --show-origin --global 設定區域優先級git config 會依照固定的優先順序進行覆蓋。優先順序如下： --local：對當前資料夾的 Git 儲存庫有效，優先級最高，會覆蓋 --global 和 --system 的相同設定。 --global：對當前用戶的所有 Git 儲存庫有效，優先級次於 --local ，會覆蓋 --system 的相同設定，但不會覆蓋 --local 的。 --system：對系統上所有 Git 的儲存庫有效，優先級最低，會被 --global 和 --local 覆蓋相同的設定。 健忘筆記 優先級順序： --local &gt; --global &gt; --system git config 常見設定各個設定都可以依據需求來做不同區域的設定 舉例的中括號 [ ] 為替換字串 git1234567git config [要設定的區域] [甚麼設定] [設定值]// 設定用戶級別的區域git config --global user.name &quot;forgetfulengineer&quot;// 設定當前儲存庫的區域git config --local user.email &quot;thatforgetfulengineer@gmail.com&quot; 健忘筆記 如果沒有指定設定位置，例如：git config user.name &quot;forgetfulengineer&quot;git config 的預設位置為 -- local 設定使用者名稱和郵件地址git123456789// 設定使用者的名稱git config --global user.name &quot;[名字]&quot;git config --global user.name &quot;forgetfulengineer&quot;// 設定使用者信箱git config --local user.email &quot;[信箱]&quot;git config --local user.email &quot;thatforgetfulengineer@gmail.com&quot; 設定 Git 指令縮寫git1234567891011git config --global alias.[縮寫] [指令]// 設定 st 等於 statusgit config --global alias.st status// 設定完後使用 git st 等於 git status 的效果// 設定 br 等於 branchgit config --global alias.br branch// 設定完後使用 git br 等於 git branch 的效果 設定 Git 使用的編輯器git config –global core.editor “vim” git1234git config --global core.editor &quot;[編輯器]&quot;// 設定 vim 為 git 的編輯器git config --global core.editor &quot;vim&quot; 設定 git log 顯示各分支進度git12345// 開啟顯示各分支進度git config --global log.decorate auto// 關閉顯示各分支進度git config --global log.decorate no log.decorate 設置有幾個選項： auto：根據終端檢測決定是否顯示各分支進度。 short：顯示簡短的各分支進度。 full：顯示完整的各分支進度。 no：不顯示各分支進度。 健忘筆記 HEAD -&gt; dev 表示當前 branch 的進度，當前在 dev 這個 branch 上origin/dev 表示遠端 branch 的進度，當前 github 上的 dev branch 在 “無障礙功能優化” 這個 commit 上 當前本地 branch 還沒跟遠端 branch 的進度同步 設定 git 追蹤檔案權限預設情況下修改檔案的權限(chmod) 會影響 git 的紀錄 git12345// 開啟追蹤檔案權限git config --global core.filemode true// 關閉追蹤檔案權限git config --global core.filemode false 範例 command12345678910111213141516// chmod_test.txt 檔案權限是 644touch chmod_test.txt// 用 chmod 修改檔案權限chmod 755 chmod_test.txt// git diff 查看檔案更動紀錄git diff chmod_test.txt// git diff 結果diff --git a/chmod_test.txt b/chmod_test.txtold mode 100644new mode 100755// 不想記錄檔權限，關閉追蹤檔案權限git config --global core.filemode false 健忘筆記 三位數的檔案權限數字用來說明三種身分user(自己)、group(組別)、other(其它人)的權限，每一位數是三種權限read(4)、write(2)、execute(1)的加總。詳細說明看這裡！ 設定 git 是否忽略檔名大小寫預設情況下 git 是忽略檔名大小寫的，所以修改檔名大小寫 git 不會紀錄 git12345// 設定忽略檔名大小寫 (預設)git config core.ignorecase true// 設定追蹤檔名大小寫git config core.ignorecase false git 忽略檔名大小寫引發 github page 404 錯誤 查詢 git config 設定值及刪除設定查詢單一設定git12345// 查詢 --global 的使用者名稱git config --get --global user.name// 查詢 --local 的 log 設定git config --get --local log.decorate 查詢所有設定git12345// 查詢 --global 的所有設定git config --global --list// 也可以用縮寫 -lgit config --global -l 健忘筆記 如果沒有指定設定位置，例如：git config --list，會列出當前存儲庫的 Git 配置 --local 和當前用戶級別的 Git 配置 --global，但不包括系統級別的 Git 配置 --system 刪除設定使用以下命令來刪除 Git 的現有設定： git12345// 刪除 --global 的使用者名稱git config --unset --global user.name// 刪除 --local 的 log 設定git config --unset --local log.decorate 結論我認為 git config 中最基本也最重要的兩種設定是 user.name 和 user.email，因為使用 git commit 時會記錄名字和信箱，如果沒有設定且嘗試使用 git commit，Git 通常會給出錯誤提示。如果仍然嘗試進行提交，Git 可能會使用空值或電腦的使用者名稱作為提交者資訊，獨自開發的情況下影響不大，但多人開發專案時提交資訊就非常重要了。(才有辦法追朔誰開發出 bug 🤣) 增加一些設定也可以讓我們更加便利，像是設定快捷鍵簡短指令長度，加快打指令的速度，或是讓 git log 顯示分支進度，讓資訊更一目了然。 可能還有很多方便的設定，如果你知道就分享一下吧～ 延伸閱讀 【官方文件】git init 創建 git 倉儲環境 【官方文件】git config 介紹 【官方文件】git commit 介紹","link":"/Other/Git/Understanding-Git-Config-Settings/"},{"title":"【Git、Hexo】deploy github 檔名大小寫問題","text":"本篇重點 hexo deploy 檔名大小寫不同，導致網頁404 git 忽略檔名大小寫的原因 解決 hexo deploy github 檔名大小寫問題 hexo deploy github page 檔名大小寫不同，導致網頁404有一次無意間發現網站中的某幾個頁面會404 error，但是在本地 hexo s 測試卻是正常的，重新 deploy 還是沒有修正這個問題，仔細比對檔案和網址後發現 github 上的檔名和網址路徑不同 造成錯誤的原因是剛開始設計的 tag 名稱是大寫，但後來修改為小寫命名，deploy 到 github 並沒有更新為小寫，導致 github page 404 錯誤，也就是說 git 並未追蹤檔名的大小寫。 健忘筆記 404 錯誤是 HTTP 的其中一種「標準回應訊息」（HTTP狀態碼），表示網頁不存在 git 忽略檔名大小寫的原因git 預設是忽略追蹤檔名大小寫，所以檔名做大小寫變更時並不會記錄。原因是許多作業系統（例如 Windows 和 macOS）的檔案系統，檔名大小寫是不敏感的。例如：建立 test 資料夾後，再建立 TEST 資料夾，系統會詢問是否要取代檔案，認為兩個檔案名稱是相同的 解決 hexo deploy github 檔名大小寫問題修改檔名的當下，git 設定是忽略檔名大小寫的，因此之後的更新沒辦法改變 github 上的檔名，解決這個問題必須清空 github 上的檔案並且重新上傳。 1. 設定 git 追蹤檔名大小寫執行 hexo d 的時候，會從 .deploy_git 資料夾將檔案更新至設定好的 github，所以需要修改 .deploy_git 的 git 設定，讓 git 追蹤檔名的大小寫，以便之後修改檔名能正確更新。 command12345// 進入 .deploy_git 資料夾cd .deploy_git// 設定追蹤檔名大小寫git config --local core.ignorecase false 查看更多 git 設定 2. 清空 github 上的檔案command12345678// 移除當前目錄及其子目錄中的所有文件和文件夾，新增至暫存區git rm -rf *// 提交變更git commit -m 'clean all file'// 更新至 githubgit push https://github.com/forgetfulengineer/forgetfulengineer.github.io.git HEAD:main 健忘筆記 git push https://github.com/forgetfulengineer/forgetfulengineer.github.io.git HEAD:main https://github.com/forgetfulengineer/forgetfulengineer.github.io.git 為遠端名稱 HEAD 為當前所在的分支 main 為 github 上要更新的分支 意思是把當前所在的分支更新到遠端的 main 分支。遠端名稱可以透過 git config --local -l 查詢 3. hexo 重新生成檔案並佈署command12345678// 回到 hexo 資料夾cd ..// 清除 hexo 生成的所有檔案hexo clean// 生成檔案並佈署hexo d -g 結論無意間發現的錯誤讓我更了解 git ，原來 git 預設是忽略追蹤檔名大小寫的。檔名修正更新後 php 標籤頁就恢復正常啦😁～ 快回想看看你的 github page 有沒有曾經更改過檔名大小，如果有，可能也會遇到 404 的問題，趕快清空 github 上的檔案重新佈署吧！ 延伸閱讀 【官方文件】 Hexo 是甚麼 【官方文件】 github page 是甚麼","link":"/Other/Hexo/Handling-Case-Sensitivity-Issues-in-GitHub-Deployment/"},{"title":"【Linux】解析資料重定向","text":"本篇重點 基本重定向用法：&lt;、&lt;&lt;、&gt;、&gt;&gt;、 2&gt;、2&gt;&gt; 重定向的判讀方式 重定向符號的前後順序不影響命令的結果 特殊重定向用法：/dev/null、&amp;&gt;、 2&gt;&amp;1 、 1&gt;&amp;2 在 Linux 中，資料重定向是一個非常重要且強大的功能。它可以將命令的輸入或輸出重定向到不同的文件或設備，讓我們能更靈活地處理資料。 基本重定向用法標準輸入 stdin，代號：0 &lt; 輸入重定向將文件內容作為命令輸入 範例 number.txt1234564638511449 command12345678910# 將 number.txt 文件的內容作為 sort 命令的輸入，並對內容進行排序sort -n &lt; number.txt# 終端顯示4911446385 健忘筆記 sort -n &lt; number.txt ，-n 選項是指定對數字進行排序 &lt;&lt; 多行輸入重定向將多行文字作為命令的輸入，直到遇到指定的結束標記 範例 command123456789# 將多行文字作為 cat 命令的輸入，並將這些文字輸出到終端cat &lt;&lt; EOFHelloWorldEOF# 終端顯示HelloWorld 健忘筆記 EOF 是一個告訴 linux 開始與結束的標記，用於長文本段落或多行命令的輸入。 EOF 本身並沒有特別的含義，可以用其他任意的字串來代替，只要確保開始標記和結束標記一致即可 動手做做看 標準輸出 stdout，代號：1 實例搶先看 標準輸出 (stdout，代號：1) > 輸出重定向：將命令的標準輸出重定向到文件，會覆蓋文件的原有內容 >> 附加重定向：將命令的標準輸出附加到文件末尾 實例搶先看 &gt; 輸出重定向將命令的標準輸出重定向到文件，會覆蓋文件的原有內容 範例 command12345678# echo 命令的輸出寫入到 output.txt 文件中，如果文件已經存在，會覆蓋原有內容。echo hello world &gt; output.txt# 查看 output.txt 的內容cat output.txt# 終端顯示hello world &gt;&gt; 附加重定向將命令的標準輸出附加到文件末尾，不會覆蓋文件的原有內容 範例 command123456789# 將 echo 命令的輸出附加到 output.txt 文件的末尾 (延續上一個範例)echo hello world &gt;&gt; output.txt# 查看 output.txt 的內容cat output.txt# 終端顯示hello worldhello world 動手做做看 錯誤輸出 stderr，代號：2 實例搶先看 錯誤輸出 (stderr，代號：2) 2> 錯誤輸出重定向：將命令的錯誤輸出重定向到文件，會覆蓋文件的原有內容 2>> 錯誤輸出附加重定向：將命令的錯誤輸出附加到文件末尾，不會覆蓋文件的原有內容 實例搶先看 2&gt; 錯誤輸出重定向將命令的錯誤輸出重定向到文件，會覆蓋文件的原有內容 範例 command12345678910# non_existing_file 是一個不存在的檔案# 嘗試列出檔案資訊，並將錯誤訊息寫入到 error.logls non_existing_file 2&gt; error.log# 查看 error.log 的內容cat error.log# 因為 non_existing_file 檔案不存在，系統給予錯誤訊息，並錯誤輸出重定向到 error.log# 終端顯示ls: cannot access 'non_existing_file': No such file or directory 2&gt;&gt; 錯誤輸出附加重定向將命令的錯誤輸出附加到文件末尾，不會覆蓋文件的原有內容 範例 command1234567891011# non_existing_file 是一個不存在的檔案# 嘗試列出檔案資訊，並將錯誤訊息附加到 error.log 的末尾(延續上一個範例)ls non_existing_file 2&gt;&gt; error.log# 查看 error.log 的內容cat error.log# 因為 non_existing_file 檔案不存在，系統給予錯誤訊息，並錯誤輸出重定向到 error.log 的末尾# 終端顯示ls: cannot access 'non_existing_file': No such file or directoryls: cannot access 'non_existing_file': No such file or directory 動手做做看 綜合應用標準輸入結合標準輸出command1234567891011121314151617181920212223# 使用多行輸入重定向搭配輸出重定向# 製作 input.txtcat &lt;&lt; EOF &gt; input.txthellotest 123EOFcat input.txt# 終端顯示hellotest 123# 將 input.txt 的內容作為 cat 命令的輸入，在輸出到 output.txtcat &lt; input.txt &gt; output.txt# 查看 output.txt 的內容cat output.txt# 得到跟 input.txt 一模一樣的 output.txt# 終端顯示hellotest 123 標準輸出結合錯誤輸出command1234567891011121314# non_existing_file 是一個不存在的檔案# 嘗試列出檔案資訊，並標準輸出到 output.log，錯誤輸出到 error.logcat non_existing_file &gt; output.log 2&gt; error.log# 查看 output.log 的內容cat output.log# 終端無顯示任何東西，output.log 是空的# 查看 error.log 的內容cat error.log# 終端顯示cat: non_existing_file: No such file or directory 動手做做看 重定向的判讀方式[重定向符號] + [文件或字串] 根據重定向符號和文件或字串來判斷，因此符號的前後順序不影響命令的結果 健忘筆記 Shell 在執行命令之前會先解析所有的重定向符號，再執行命令。 Shell 是用來和操作系統進行溝通的命令行界面（CLI），允許用戶通過輸入命令來控制系統執行程序、管理文件系統等 cat &lt; input.txt &gt; output.txt 可以分解為： &lt; input.txt：這部分將 input.txt 的內容重定向到 cat 命令的標準輸入 &gt; output.txt：這部分將 cat 命令的標準輸出重定向到 output.txt Shell 會先解析重定向符號，再執行 cat 命令，從 input.txt 讀取內容並將其寫入 output.txt 因此不管是 cat &lt; input.txt &gt; output.txt 或是 cat &gt; output.txt &lt; input.txt 結果都是一樣的！符號的前後順序不影響命令的結果。 特殊重定向用法/dev/null可以視為垃圾桶，任何資料重定向給它就會丟棄 範例 command12345# non_existing_file 是一個不存在的檔案# 嘗試列出檔案資訊，並將錯誤訊息重定向到 /dev/nullls non_existing_file 2&gt; /dev/null# 終端不顯示訊息，錯誤訊息直接丟棄 健忘筆記 重定向到 /dev/null 表示丟棄所有寫入它的數據，因此無法復原要謹慎使用！ 動手做做看 &amp;&gt;將命令的標準輸出和錯誤輸出都重定向到同一個文件 範例 command12345678910111213141516171819202122# non_existing_file 是不存在的檔案# 嘗試列出檔案資訊，並將標準輸出和錯誤輸出都重定向到 output.txtcat non_existing_file &amp;&gt; output.txt# 查看 output.txt 的內容cat output.txt# 終端顯示cat: cannot access 'non_existing_file': No such file or directory# 建立 test.txtecho test &gt; test.txt# test.txt 是已存在的檔案# 嘗試列出檔案資訊，並將標準輸出和錯誤輸出都重定向到 output.txtcat test.txt &amp;&gt; output.txt# 查看 output.txt 的內容cat output.txt# 終端顯示test 健忘筆記 需要重複輸出到同一個檔案時，可以使用 &amp;&gt;&gt;，將輸出附加到檔案末尾 動手做做看 2&gt;&amp;1、1&gt;&amp;2 2&gt;&amp;1 表示將標準錯誤輸出重定向到標準輸出 1&gt;&amp;2 表示將標準輸出輸出重定向到錯誤輸出 範例 test.txt12hellotest 123 2&gt;&amp;1 command123456789101112131415161718# non_existing_file 是不存在的檔案# 列出 test.txt 和 non_existing_file 檔案資訊，並標準輸出重定向到 output.txt，最後要求標準錯誤輸出重定向到標準輸出ls test.txt non_existing_file &gt; output.txt 2&gt;&amp;1# 查看 output.txt 的內容cat output.txt# 終端顯示ls: cannot access 'non_existing_file': No such file or directorytest.txt# 如果使用 2&gt; 會導致訊息消失，因為錯誤輸出已經重定向到標準輸出了ls test.txt non_existing_file 2&gt; output.txt 2&gt;&amp;1# 查看 output.txt 的內容cat output.txt# 終端無顯示任何東西，output.txt 是空的 1&gt;&amp;2 command123456789101112131415161718# non_existing_file 是不存在的檔案# 列出 test.txt 和 non_existing_file 檔案資訊，並錯誤輸出重定向到 output.txt，最後要求標準輸出輸出重定向到錯誤輸出ls test.txt non_existing_file 2&gt; output.txt 1&gt;&amp;2# 查看 output.txt 的內容cat output.txt# 終端顯示ls: cannot access 'non_existing_file': No such file or directorytest.txt# 如果使用 &gt; 會導致訊息消失，因為標準輸出已經重定向到錯誤輸出了ls test.txt non_existing_file &gt; output.txt 1&gt;&amp;2# 查看 output.txt 的內容cat output.txt# 終端無顯示任何東西，output.txt 是空的 健忘筆記 同時重定向標準輸出和標準錯誤輸出，可以使用 command &amp;&gt; output.log command &gt; output.log 2&gt;&amp;1 command 2&gt; output.log 1&gt;&amp;2 三種方法都有一樣的效果 動手做做看 結論了解並熟悉資料輸出重定向的用法，能夠讓我們更靈活地處理和管理命令的輸入輸出。以下是一些需要注意的地方： 依不同的需求，使用不同的輸出方式 &gt; 和 2&gt; 會覆蓋輸出檔案原本的內容。 &gt;&gt; 和 2&gt;&gt; 會將輸出附加到檔案原本的內容末尾。 重定向符號的前後順序不影響命令的結果 如果你有其他有趣的用法或技巧，歡迎在下方留言分享！ 動手做做看 Linux 線上模擬器","link":"/Backend/Linux/Understanding-Data-Redirection/"},{"title":"【Hexo】多台電腦佈署 GitHub page 的問題","text":"本篇重點 了解 Hexo 佈署的流程 多台電腦佈署網站，導致 git 紀錄被覆蓋 使用腳本解決 git 紀錄被覆蓋的問題 Hexo 佈署的流程演示佈署網站的流程 command12345# 先移除原本已生成的檔案hexo clean# 生成檔案並且佈署到 githubhexo d -g 使用 hexo d 前要先到 _config.yml 中配置 GitHub 的設定 hexo d 的時候會將 public 目錄下的檔案複製到 .deploy_git 中，再從這個目錄強制推送 git push -f 到 repository，接著 github page 服務會自動偵測到推送的更新，並在一段時間內更新佈署到網站上 多台電腦佈署網站，導致 git 紀錄被覆蓋當使用 Hexo 在多台電腦上進行佈署時，可能會遇到 git 紀錄被覆蓋的問題。這是因為 hexo d 會從 .deploy_git 強制推送更新到 github，而不會先拉取最新的紀錄回 .deploy_git。因此，如果在不同的電腦上進行佈署，git 紀錄就可能會被覆蓋。 舉例來說，如果 A 電腦在 7 月 1 日更新了網站，隨後 B 電腦在 7 月 3 日也進行了更新，但由於 B 電腦的 .deploy_git 資料夾沒有拉取最新的記錄，因此 GitHub 上的記錄不會包含 7 月 1 日的更新。 雖然這對網站內容本身沒有任何影響，但版本控制的主要目的是記錄每一次的更改。因此，保留每次更新的記錄是必要的！ 解決 git 紀錄被覆蓋的問題Hexo 官方沒有針對多台電腦佈署的具體方案，因此每次佈署網站時，都需要先進入 .deploy_git 更新進度再執行 hexo d，這樣非常不方便。為了解決這個問題，我編寫了一個腳本來自動化更新進度並佈署網站。 1. 製作自動化腳本 deploy.sh在每次佈署前先檢查 .deploy_git 資料夾是否存在，並拉取最新的進度。這樣可以確保佈署過程中的進度同步，避免覆蓋提交記錄的問題。 以下是完整的腳本示例： deploy.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/bash# GitHub Pages repository 的 URLREPO_URL=&quot;https://github.com/forgetfulengineer/forgetfulengineer.github.io.git&quot;USER_NAME=&quot;forgetfulengineer&quot;USER_EMAIL=&quot;thatforgetfulengineer@gmail.com&quot;FIRST_DEPLOY=0# 檢查 .deploy_git 資料夾是否存在echo -e &quot;\\n檢查 .deploy_git 資料夾是否存在...&quot;if [ -d &quot;.deploy_git&quot; ]; then # 切換到 .deploy_git 資料夾並拉取最新進度 cd .deploy_git || { echo -e &quot;\\n切換到 .deploy_git 資料夾失敗&quot;; exit 1; } echo -e &quot;\\n拉取 github page 最新進度...&quot; git pull || { echo -e &quot;\\n拉取進度失敗&quot;; exit 1; } cd .. || { echo -e &quot;\\n返回 Hexo 資料夾失敗&quot;; exit 1; }else # 檢查 GitHub Pages repository 是否已有 commit echo -e &quot;\\n檢查 GitHub Pages repository 是否已有 commit...&quot; if git ls-remote --exit-code &quot;$REPO_URL&quot; HEAD &gt; /dev/null 2&gt;&amp;1; then echo -e &quot;\\nClone repository 到 .deploy_git 資料夾...&quot; git clone &quot;$REPO_URL&quot; .deploy_git || { echo -e &quot;\\nClone repository 失敗&quot;; exit 1; } # 設置 git config cd .deploy_git || { echo -e &quot;\\n切換到 .deploy_git 資料夾失敗&quot;; exit 1; } git config --local user.name &quot;$USER_NAME&quot; git config --local user.email &quot;$USER_EMAIL&quot; git config --local core.ignorecase false cd .. || { echo -e &quot;\\n返回 Hexo 資料夾失敗&quot;; exit 1; } else echo -e &quot;\\nGitHub Pages repository 尚無 commit，進行首次佈署&quot; FIRST_DEPLOY=1 fifi# 清理舊的生成文件echo -e &quot;\\n清理舊的生成文件...&quot;hexo clean || { echo -e &quot;\\nHexo 清理失敗&quot;; exit 1; }# 生成新的靜態文件並佈署網站echo -e &quot;\\n生成新的靜態文件並佈署網站...&quot;hexo d -g || { echo -e &quot;\\nHexo 佈署失敗&quot;; exit 1; }# 如果是首次部署，進入 .deploy_git 設置 git configif [ &quot;$FIRST_DEPLOY&quot; -eq 1 ]; then echo -e &quot;\\n首次佈署，設置 git config --local core.ignorecase false&quot; cd .deploy_git || { echo -e &quot;\\n切換到 .deploy_git 資料夾失敗&quot;; exit 1; } git config --local core.ignorecase false cd .. || { echo -e &quot;\\n返回 Hexo 資料夾失敗&quot;; exit 1; }fiecho -e &quot;\\n佈署完成&quot; 2. 執行 deploy.sh 腳本完成 deploy.sh 腳本後，將其放在執行 Hexo 的資料夾中。佈署網站時，只需執行 deploy.sh，神奇的事情就會發生囉～😝 command12# 在 hexo 資料夾的路徑執行 deploy.sh./deploy.sh 補充說明檢查 .deploy_git 資料夾是否存在使用 if [ -d &quot;.deploy_git&quot; ] 檢查 .deploy_git 資料夾是否存在。在 Shell 中，-d 選項常用來檢查資料夾是否存在。如果要檢查檔案是否存在，可以使用 -f 選項。若要檢查資料夾或是檔案是否存在，則可以使用 -e 選項。 使用 || 和 {} 處理命令執行失敗的情況|| 是邏輯 OR 操作符。它表示當前面的命令執行失敗（返回非零退出狀態碼）時，執行後面的命令。例如： command1command1 || command2 如果 command1 執行成功，那麼 command2 不會被執行。如果 command1 執行失敗，那麼 command2 會被執行。 {} 用於將多條命令組合成一個命令塊。命令塊中的命令會按順序執行。通常與邏輯操作符（如 || 或 &amp;&amp;）結合使用。例如： command1command1 || { command2; command3; } 如果 command1 執行失敗，則執行命令塊 { command2; command3; } 中的命令。 使用 echo -e 啟用反斜杠特殊字符轉義告訴 echo 啟用反斜杠特殊字符轉義，例如 \\n、\\t、\\r 。如果沒有使用 -e ，字串會直接顯示不會有特殊符號的效果。 檢查 GitHub Pages repository 是否已有 commit使用 git ls-remote --exit-code &quot;$REPO_URL&quot; HEAD 檢查 repository 。 ls-remote 用於檢查遠端儲存庫是否存在特定分支的命令，執行後終端顯示該分支最新的進度。 command1234git ls-remote --exit-code https://github.com/forgetfulengineer/forgetfulengineer.github.io.git# 終端顯示4w727c14a1260cf59a65e34de3b643d3f3bee83f HEAD --exit-code 選項 如果找到指定的引用（例如 HEAD），命令會成功執行並返回退出碼 0。 如果未找到指定的引用，命令會返回退出碼 2 不使用 -exit-code 的情況 無論是否找到指定的引用，命令都會成功執行並返回退出碼 0 &gt; /dev/null 2&gt;&amp;1; 表示不顯示 command 的輸出結果將標準輸出和錯誤輸出重定向到垃圾桶 (/dev/null)，這樣執行的結果就不會顯示在終端。 想了解更多重定向符號的使用方法，可以到【Linux】解析資料重定向 查看 if [ -d &quot;.deploy_git&quot; ]; then 和 if git ls-remote --exit-code &quot;$REPO_URL&quot; HEAD &gt; /dev/null 2&gt;&amp;1; then 兩種判斷式的差異[ ... ] 是 POSIX 標準中的測試命令，又稱 test 命令，用來檢查條件表達式是否為真，根據條件的結果返回不同的退出狀態碼。退出狀態碼為 0 表示條件為 true，非 0 表示條件為fasle，通常用於檔案或目錄的存在性、字串比較等操作。 if COMMAND; then 是基於命令執行後的退出狀態碼判斷。退出狀態碼為 0 表示 true，非 0 表示 false，通常用於判斷一個命令是否成功執行。 git config --local core.ignorecase false 設定 git 追蹤檔名大小寫有兩種情況會首次建立 .deploy_git 首次佈署，執行 hexo d 後建立 .deploy_git GitHub Pages repository 已有 commit，使用 git clone 建立 .deploy_git 建立後建議進入 .deploy_git 設定 git 追蹤檔名大小寫，不然有機會遇到 git 忽略檔名大小寫導致 github page 404 的錯誤 想了解更多 git config 的設定，可以到【Git】了解 git config 設定 查看 結論透過上述腳本，我們可以確保在多台電腦上進行 Hexo 佈署時，不會覆蓋 GitHub 上的提交記錄。這樣的解決方案不僅簡單且有效，同時也考慮到首次佈署的情況，確保每次佈署順利進行。 另外也可以使用 GitHub Actions 解決，GitHub Actions 可以設定自動化工作流程，將 Hexo 生成的靜態網站自動佈署到 GitHub Pages，但跟我的佈署習慣不同，所以就沒有使用了，使用方式可以看這篇教學。 希望這篇文章對遇到相同問題的你有所幫助～😁","link":"/Other/Hexo/Multi-Computer-Deployment-Issues-on-GitHub-Page/"},{"title":"【PHP】陣列合併應用：array + array、array_merge()、array_replace()","text":"本篇重點 陣列的自定義鍵值和流水號鍵值 array + array、array_merge()、array_replace() 的使用方式和差異 陣列的自定義鍵值和流水號鍵值陣列的鍵值可以是自定義的字符串或整數，也可以是預設的流水號鍵值 實例搶先看 陣列的自定義鍵值和流水號鍵值 自定義鍵值：使用有意義的鍵來標識陣列中的元素 流水號鍵值：從 0 開始遞增的整數鍵值，沒有指定鍵時，PHP 會自動生成預設的流水號鍵值 實例搶先看 自定義鍵值使用有意義的鍵來標識陣列中的元素 12345$customArray = [ 'name' =&gt; 'Alice', 'age' =&gt; 25, 'city' =&gt; 'New York']; 流水號鍵值從 0 開始遞增的整數鍵值。沒有指定鍵時，PHP 會自動生成預設的流水號鍵值 1$defaultArray = ['Apple', 'Banana', 'Cherry']; 同時使用自定義鍵值和流水號鍵值1234567$mixedArray = [ 'name' =&gt; 'Bob', 'age' =&gt; 30, 'colors' =&gt; ['Red', 'Green', 'Blue'], '2' =&gt; 'two', 1 =&gt; 1]; 鍵值重複同一個陣列中使用相同的鍵值，後面定義的值會覆蓋前面的值。 12345$duplicateArray = [ 'name' =&gt; 'Bob', 'name' =&gt; 'Tom', 'age' =&gt; 30,]; 動手做做看 動手做做看 陣列合併應用array + array 保留第一組陣列的所有鍵值對 添加第二組陣列中不在第一組陣列的鍵值對 如果兩個陣列有相同的鍵值(不管字串或數字的鍵值)，則保留第一組陣列的鍵值對 如果合併的時候有流水號鍵值，則保持原順序，不會重新排序 範例 實例搶先看 array + array 保留第一組陣列的所有鍵值對 添加第二組陣列中不在第一組陣列的鍵值對 如果兩個陣列有相同的鍵值，則保留第一組陣列的鍵值對 流水號鍵值保持原順序，不會重新排序 實例搶先看 12345678910111213141516171819202122232425262728293031323334353637383940414243// 自定義鍵值$array1 = ['a' =&gt; 1, 'b' =&gt; 2];$array2 = ['b' =&gt; 3, 'c' =&gt; 4];$result1 = $array1 + $array2;// 輸出結果print_r($result1);Array( [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; 4)// 流水號鍵值$array3 = [0 =&gt; 'Apple', 3 =&gt; 'Banana'];$array4 = [0 =&gt; 'Cherry', 2 =&gt; 'Grap'];$result2 = $array3 + $array4;// 輸出結果print_r($result2);Array( [0] =&gt; Apple [3] =&gt; Banana [2] =&gt; Grap)// 同時使用自定義鍵值和流水號鍵值$array5 = [0 =&gt; 'Apple', 'b' =&gt; 23, 3 =&gt; 'Banana'];$array6 = ['e' =&gt; 66, 'Cherry', 'Grap'];$result3 = $array5 + $array6;// 輸出結果print_r($result3);Array( [0] =&gt; Apple ['b'] =&gt; 23 [3] =&gt; Banana ['e'] =&gt; 66 [1] =&gt; Grap) 動手做做看 動手做做看 array_merge() 合併一組或多組陣列 保留所有參與合併陣列的鍵值對 如果有相同的鍵值 (不是數字的鍵值)，後面陣列的鍵值對會覆蓋前面的鍵值對 如果合併的時候有數字或流水號鍵值，則重新排序 (從0開始遞增) 範例 實例搶先看 array_merge() 合併一個或多個陣列 保留所有參與合併陣列的鍵值對 如果有相同的鍵值 (不是數字的鍵值)，後面陣列的鍵值對會覆蓋前面的鍵值對 如果合併的時候有數字或流水號鍵值，則重新排序 (從0開始遞增) 實例搶先看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 自定義鍵值$array1 = ['a' =&gt; 1, 'b' =&gt; 2];$array2 = ['b' =&gt; 3, 'c' =&gt; 4];$result1 = array_merge($array1, $array2);// 輸出結果print_r($result1);Array( [a] =&gt; 1 [b] =&gt; 3 [c] =&gt; 4)// 流水號鍵值$array3 = [0 =&gt; 'Apple', 3 =&gt; 'Banana'];$array4 = [0 =&gt; 'Cherry', 2 =&gt; 'Grap'];$result2 = array_merge($array3, $array4);// 輸出結果// 陣列都是數字鍵值，合併後鍵值重新排序print_r($result2);Array( [0] =&gt; Apple [1] =&gt; Banana [2] =&gt; Cherry [3] =&gt; Grap)// 同時使用自定義鍵值和流水號鍵值$array5 = [0 =&gt; 'Apple', 'b' =&gt; 23, 3 =&gt; 'Banana'];$array6 = ['e' =&gt; 66, 'Cherry', 'Grap'];$result3 = array_merge($array5, $array6);// 輸出結果print_r($result3);Array( [0] =&gt; Apple [b] =&gt; 23 [1] =&gt; Banana [e] =&gt; 66 [2] =&gt; Cherry [3] =&gt; Grap) 動手做做看 動手做做看 array_replace() 合併一組或多組陣列 添加後面陣列中不在第一組陣列的鍵值對 如果有相同的鍵值 (不管字串或數字的鍵值)，後面陣列的鍵值對會覆蓋前面的鍵值對 如果合併的時候有流水號鍵值，則保持原順序，不會重新排序 範例 實例搶先看 array_replace() 合併一個或多個陣列 添加後面陣列中不在第一組陣列的鍵值對 如果有相同的鍵值 (不管字串或數字的鍵值)，後面陣列的鍵值對會覆蓋前面的鍵值對 如果合併的時候有流水號鍵值，則保持原順序，不會重新排序 實例搶先看 12345678910111213141516171819202122232425262728293031323334353637383940414243// 自定義鍵值$array1 = ['a' =&gt; 1, 'b' =&gt; 2];$array2 = ['b' =&gt; 3, 'c' =&gt; 4];$result1 = array_replace($array1, $array2);// 輸出結果print_r($result1);Array( [a] =&gt; 1 [b] =&gt; 3 [c] =&gt; 4)// 流水號鍵值$array3 = [0 =&gt; 'Apple', 3 =&gt; 'Banana'];$array4 = [0 =&gt; 'Cherry', 2 =&gt; 'Grap'];$result2 = array_replace($array3, $array4);// 輸出結果print_r($result2);Array( [0] =&gt; Cherry [3] =&gt; Banana [2] =&gt; Grap)// 同時使用自定義鍵值和流水號鍵值$array5 = [0 =&gt; 'Apple', 'b' =&gt; 23, 3 =&gt; 'Banana'];$array6 = ['e' =&gt; 66, 'Cherry', 'Grap'];$result3 = array_replace($array5, $array6);// 輸出結果print_r($result3);Array( [0] =&gt; Cherry [b] =&gt; 23 [3] =&gt; Banana [e] =&gt; 66 [1] =&gt; Grap) 動手做做看 動手做做看 array + array、array_merge()、array_replace() 相互比較合併組數 array + array：只能合併兩組陣列 1$result = $array1 + $array2; array_merge()：可合併多組陣列 1$result = array_merge($array1, $array2, $array3, ...); array_replace()：可合併多組陣列 1$result = array_replace($array1, $array2, $array3, ...); 相同鍵值時，鍵值對的覆蓋方式 array + array： 不論是字符串鍵值還是數字鍵值，保留第一組陣列的鍵值對，不會被後面的鍵值對覆蓋 array_merge()： 字符串鍵值：後面陣列的鍵值對會覆蓋前面的鍵值對 數字鍵值：後面陣列的值會追加到結果陣列中，不覆蓋前面的鍵值對 array_replace()： 不論是字符串鍵值還是數字鍵值，後面陣列的鍵值對都會覆蓋前面的鍵值對 合併數字鍵值時，鍵值排序方式 array + array：保持數字鍵值的原順序，不會重新排序 123456789101112$array1 = [0 =&gt; 'Apple', 2 =&gt; 'Banana'];$array2 = [2 =&gt; 'Cherry', 4 =&gt; 'Grap'];$result = $array1 + $array2;// 輸出結果：print_r($result);Array( [0] =&gt; Apple [2] =&gt; Banana [4] =&gt; Grap) array_merge()：數字鍵值會重新索引，從0開始遞增 12345678910111213$array1 = [0 =&gt; 'Apple', 2 =&gt; 'Banana'];$array2 = [2 =&gt; 'Cherry', 4 =&gt; 'Grap'];$result = array_merge($array1, $array2);// 輸出結果：print_r($result);Array( [0] =&gt; Apple [1] =&gt; Banana [2] =&gt; Cherry [3] =&gt; Grap) array_replace()：保持數字鍵值的原順序，不會重新排序 123456789101112$array1 = [0 =&gt; 'Apple', 2 =&gt; 'Banana'];$array2 = [2 =&gt; 'Cherry', 4 =&gt; 'Grap'];$result = array_replace($array1, $array2);// 輸出結果：print_r($result);Array( [0] =&gt; Apple [2] =&gt; Cherry [4] =&gt; Grap) 動手做做看 PHP 線上編輯器 總結 array + array array_merge() array_replace() 合併陣列組數 兩組 多組 多組 相同鍵值的覆蓋方式 不論字符串鍵值還是數字鍵值，保留第一組陣列的鍵值對，不覆蓋 字符串鍵值：後者覆蓋前者數字鍵值：追加不覆蓋 不論字符串鍵值還是數字鍵值，後者覆蓋前者 合併數字鍵值時的排序方式 保持原順序，不重新排序 重新排序，從0開始遞增 保持原順序，不重新排序 array + array、array_merge()、array_replace() 三種合併陣列的方式，各自有相似的地方，但是執行結果有些許差異。 我很常會忘記它們各自的差異，所以需要陣列合併的時候會不知道要使用哪個方式，希望透過這篇整理可以幫助到我跟有同樣困擾的人😂","link":"/Backend/PHP/Analyzing-Three-Methods-of-Merging-Array/"},{"title":"【HTML】button 在 form 裡和在 form 以外的差別","text":"本篇重點 了解 &lt;button&gt; 在 &lt;form&gt; 裡與 &lt;form&gt; 以外的差別 了解 &lt;form&gt; 的預設 method 和預設 action &lt;button&gt; 在 &lt;form&gt; 裡與 &lt;form&gt; 以外的差別&lt;button&gt; 在 &lt;form&gt; 裡 當 &lt;button&gt; 放在 &lt;form&gt; 裡且沒有指定 type 屬性時，它的預設 type 是 submit，會提交整個表單到指定的 action URL 如果指定了 type=&quot;button&quot;，按鈕就不會觸發表單提交，只是單純的按鈕，可以透過 JavaScript 綁定其他行為 html12345&lt;!-- 按下提交按鈕會觸發表單提交，並將資料發送到 &quot;example.php&quot; --&gt;&lt;form method=&quot;post&quot; action=&quot;example.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;!-- 相當於 &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; --&gt;&lt;/form&gt; &lt;button&gt; 在 &lt;form&gt; 以外 在 &lt;form&gt; 以外的 &lt;button&gt; 元素，預設 type=&quot;button&quot;，按下時不會觸發表單提交 這種 &lt;button&gt; 通常用於執行與表單提交無關的操作，例如觸發 JavaScript 函數等 html12345&lt;!-- 按下提交按鈕甚麼事都不會發生 --&gt;&lt;form method=&quot;post&quot; action=&quot;example.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/form&gt;&lt;button&gt;提交&lt;/button&gt; &lt;!-- 相當於 &lt;button type=&quot;button&quot;&gt;提交&lt;/button&gt; --&gt; 案例說明在處理表單返回按鈕的功能時，發現一個問題，當 &lt;button&gt; 沒有設定 type 屬性時，點擊按鈕會自動送出表單，這和原本預設的行為不符。 以下範例的樣式使用 bulma html1234567891011121314151617181920212223&lt;!-- 建立一個表單，底部有兩個按鈕，一個是返回指定頁面，一個是提交表單 --&gt;&lt;form&gt; &lt;div class=&quot;field is-horizontal&quot;&gt; &lt;div class=&quot;field-label is-normal&quot;&gt; &lt;label class=&quot;label&quot;&gt;Name&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field-body&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;control&quot;&gt; &lt;input class=&quot;input&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Text input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped is-grouped-centered&quot;&gt; &lt;a href=&quot;/&quot; class=&quot;control&quot;&gt; &lt;button class=&quot;button is-link&quot;&gt;返回&lt;/button&gt; &lt;!-- 預期是返回首頁 --&gt; &lt;/a&gt; &lt;div class=&quot;control&quot;&gt; &lt;button class=&quot;button is-link&quot;&gt;提交&lt;/button&gt; &lt;!-- 預期是提交表單 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 實例 Name 返回 提交 範例中，&lt;button&gt; 位於 &lt;form&gt; 內部，當按鈕沒有設定 type 屬性時，瀏覽器會將其視為 type=&quot;submit&quot;。所以點擊「返回」按鈕時，會觸發表單的提交操作，而不是前往 href 指定的首頁。 為了正確的前往指定連結，就要將「返回」按鈕的 type 設定為 button html1234&lt;!-- &lt;button&gt; 的 type 設定為 button --&gt;&lt;a href=&quot;/&quot; class=&quot;control&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;button is-link&quot;&gt;返回&lt;/button&gt;&lt;/a&gt; 實例 Name 返回 提交 設定後，點擊「返回」按鈕會前往首頁，而不會提交表單。 健忘筆記 &lt;button&gt; 位於 &lt;form&gt; 內且未設置 type 時，默認為 type=&quot;submit&quot;，會提交表單。 &lt;form&gt; 的預設 method 和預設 action 預設 method：沒有設定 method 屬性，&lt;form&gt; 元素的預設提交方法是 GET。表單數據會被附加到 URL 中進行提交。 預設 action：沒有設定 action 屬性，表單數據會提交到當前頁面本身的 URL。 html12345678910111213141516171819202122&lt;form&gt; &lt;div class=&quot;field is-horizontal&quot;&gt; &lt;div class=&quot;field-label is-normal&quot;&gt; &lt;label class=&quot;label&quot;&gt;Name&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field-body&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;control&quot;&gt; &lt;input class=&quot;input&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Text input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped is-grouped-centered&quot;&gt; &lt;a href=&quot;/&quot; class=&quot;control&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;button is-link&quot;&gt;返回&lt;/button&gt; &lt;/a&gt; &lt;div class=&quot;control&quot;&gt; &lt;button class=&quot;button is-link&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 實例 Name 返回 提交 提交表單後會以 GET 的方式送到原網址，因此可以看到網址列最後面會加上 ?username=[填入的字串] 動手做做看 html 線上編輯器 結論這個 &lt;button&gt; 小細節是在我製作表單時不小心踩到的坑。當時因為沒有指定屬性，結果 &lt;button&gt; 在不同情境下的預設值竟然不一樣，讓我花了不少時間才找到問題。標籤的預設屬性在不同情境下可能會有很大的差異，還有甚麼在不同情境下有不同預設屬性的標籤嗎？歡迎分享給我～ 延伸閱讀 【MDN】&lt;button&gt; 介紹 【MDN】&lt;form&gt; 介紹 【medium】HTML5 新增的表單元件 &amp; 屬性","link":"/Frontend/Html/Difference-Between-button-Inside-and-Outside-of-a-form/"},{"title":"【jQuery】click 事件綁定方式比較","text":"本篇重點 $('選擇器').click() 的應用和使用時機 $(document).on('click', '選擇器', function(){}) 的應用和使用時機 .on('click', function() {}) 不是委派給 document 就無法適用在動態生成的元素 先了解這些會幫助你更快理解唷😁 【jQuery、css】解析六種組合選擇器：相連、+、～、&gt;、,、空格 在前端開發中，經常需要偵測使用者對於網頁上元素的點擊事件，jQuery 中，可以使用 .click() 或 .on('click') 事件來偵測元素的點擊事件，雖然都是偵測點擊事件，但兩者有些差異。 $(選擇器).click()應用重點 直接綁定點擊事件到指定的元素 只適用於當前 DOM 中已存在的元素 當指定元素被刪除，綁定的事件也會被刪除 使用時機 用於靜態元素，這些元素在 DOM 加載時已經存在且不會動態變更 適合簡單的事件綁定，不需要過多處理 健忘筆記 DOM（Document Object Model）是瀏覽器用來解讀和操作 HTML 或 XML 文件的結構化模型，它將 HTML 文件中的各種元素（如標籤、屬性、文本等）轉換為 JavaScript 可以操作的物件，讓開發者可以動態修改、刪除或新增內容，並控制網頁的行為。 範例 實例搶先看 $(選擇器).click() 直接綁定點擊事件到指定的元素 只適用於當前 DOM 中已存在的元素 當指定元素被刪除，綁定的事件也會被刪除 html123&lt;button class=&quot;button is-link add_button&quot;&gt; 新增按鈕&lt;/button&gt; js12345678let num = 1;$('.add_button').click(function() { let new_button = `&lt;button class=&quot;button is-success add_button&quot;&gt; 新增按鈕 ${num} &lt;/button&gt;`; $(this).after(new_button); num ++;}); 點擊 “新增按鈕” 產生新按鈕，新的按鈕雖然 class 也有 .add_button，但無法產生新的按鈕 $(document).on(‘click’, ‘選擇器’, function(){})應用重點 委派事件處理給 document，再綁定點擊事件到指定的元素 適用於當前或未來新增的元素 當指定元素被刪除，綁定的事件依然存在 使用時機 適用於動態生成的指定元素，確保事件觸發 範例 實例搶先看 $(document).on('click', '選擇器', function(){}) 委派事件處理給 document，再綁定點擊事件到指定的元素 適用於當前或未來新增的元素 當指定元素被刪除，綁定的事件依然存在 html123&lt;button class=&quot;button is-link add_button&quot;&gt; 新增按鈕&lt;/button&gt; js12345678let num = 1;$(document)on('click', '.add_button', function() { let new_button = `&lt;button class=&quot;button is-success add_button&quot;&gt; 新增按鈕 ${num} &lt;/button&gt;`; $(this).after(new_button); num ++;}); 點擊 “新增按鈕” 產生新的按鈕，新按鈕也可以產生新的按鈕 健忘筆記 早期的 jquery 是使用 .live()，但這個函數因為一些漏洞已在 jQuery 1.9 被刪除，所以請將 .live() 替換成 .on()詳情請看【geeksforgeeks】Replace live() with on() in jQuery 如果 .on('click', function() {}) 不是委派給 document 會發生甚麼事.on('click', function() {}) 不是委派給 document 就無法適用在動態生成的元素，只能綁定到當前 DOM 中已存在的元素 例如 實例搶先看 如果 .on('click', function() {}) 不是委派給 document 會發生甚麼事 不是委派給 document 就無法適用在動態生成的元素，只能綁定到當前 DOM 中已存在的元素 html123&lt;button class=&quot;button is-link add_button&quot;&gt; 新增按鈕&lt;/button&gt; js1234567891011121314151617let num = 1;$('.add_button').on('click', function() { let new_button = `&lt;button class=&quot;button is-success add_button&quot;&gt; 新增按鈕 ${num} &lt;/button&gt;`; $(this).after(new_button); num ++;});$('.add_button').click(function() { let new_button = `&lt;button class=&quot;button is-success add_button&quot;&gt; 新增按鈕 ${num} &lt;/button&gt;`; $(this).after(new_button); num ++;}); $('.add_button').on('click', function() {}) 和 $('.add_button').click(function() {}) 寫法不同，但兩者的效果是一樣的，都是綁定 click 事件到當前 DOM 中已存在的 .add_button 元素，動態生成的 .add_button 元素無法觸發事件 這兩種寫法的效果相同，但 .click(function() {}) 僅能偵測點擊事件；相比之下，使用 .on('click', function() {}) 更具彈性。除了偵測點擊事件，.on() 還能同時綁定多個事件，例如：.on('click mouseenter change', function() {})，因此在事件處理上提供了更多的靈活性。 結論 click(function() {}) 是最簡單的事件綁定方式，適合靜態元素的單一點擊事件。 $(document).on('click', function() {}) 是較複雜但更具彈性的方式，特別適合處理動態生成的元素或需要更靈活事件處理的情況。 根據具體使用場景選擇最適合的綁定方式，才能確保達到預期效果。如果你需要偵測點擊事件，不妨試試這兩種方式，看哪一種更符合你的需求！ 動手做做看 codepen 線上編輯器 延伸閱讀【jQuery 官方文件】.click() 介紹【jQuery 官方文件】.on(‘click’, function() {}) 介紹【天矽科技】DOM 是什麼?","link":"/Frontend/JQuery/Comparison-of-Click-Event-Binding-Methods/"},{"title":"【jQuery】尋找父元素、同層元素和子元素的方法","text":"本篇重點 尋找父元素的常用方法：.parent() 、.parents() 、.closest() 尋找同層元素的常用方法：.siblings() 、.next() 、.prev() 尋找子元素的常用方法：.children() 、.find() 每個尋找元素方法的具體用途和應用場景 先了解這些會幫助你更快理解唷😁 【jQuery、css】解析六種組合選擇器：相連、+、～、&gt;、,、空格 尋找父元素.parent()只尋找當前元素上一層匹配的元素，也就是尋找親身父母 範例 實例搶先看 .parent() 尋找親身父親，也就是尋找當前元素上一層元素 html123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2&gt;.parent() 的效果&lt;/h2&gt; &lt;h3&gt;使用方式一&lt;/h3&gt; &lt;ul&gt; &lt;li class=&quot;target-1 target-2&quot;&gt;取得所有 li 元素的直接父元素&lt;/li&gt; &lt;li&gt;設定父元素的文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;使用方式二&lt;/h3&gt; &lt;ul class='selected'&gt; &lt;li class=&quot;target-1 target-2&quot;&gt;取得所有 li 元素的直接父元素，並且父元素的 class 有 &quot;selected&quot;&lt;/li&gt; &lt;li&gt;設定父元素的文字顏色&lt;/li&gt; &lt;li class=&quot;selected&quot;&gt;沒有 &quot;selected&quot; 的元素不會被設定&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式一&lt;/button&gt; &lt;button class=&quot;button is-info example-2&quot;&gt;使用方式二&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js1234567891011121314// 使用方式一$('.example-1').on('click', function() { $('.target-1').parent().css('color', 'DodgerBlue');});// 使用方式二$('.example-2').on('click', function() { $('.target-2').parent('.selected').css('color', 'LightSkyBlue');});// reset$('.reset').on('click', function() { $('*').css('color', '');}); .parents()向上尋找所有匹配的祖先元素，直到根元素為止 範例 實例搶先看 .parents() 向上尋找所有祖先元素，直到根元素為止 html123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content selected&quot;&gt; &lt;h2&gt;.parents() 的效果&lt;/h2&gt; &lt;h3&gt;使用方式一&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;取得所有 li 元素的所有匹配的祖先元素，直到根元素&lt;/li&gt; &lt;li class=&quot;target-1&quot;&gt;設定所有祖先元素的背景顏色&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;使用方式二&lt;/h3&gt; &lt;ul class=&quot;selected&quot;&gt; &lt;li&gt;取得所有 li 元素的祖先元素，並且元素的 class 有 &quot;selected&quot; &lt;/li&gt; &lt;li&gt;設定匹配的祖先元素背景顏色&lt;/li&gt; &lt;li class=&quot;target-1 target-2&quot;&gt;只設定匹配的元素，因此使用方法一的ul不會被設定背景顏色&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式一&lt;/button&gt; &lt;button class=&quot;button is-info example-2&quot;&gt;使用方式二&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js1234567891011121314// 使用方式一$('.example-1').on('click', function() { $('.target-1').parents().css('background-color', 'DodgerBlue');});// 使用方式二$('.example-2').on('click', function() { $('.target-2').parents('.selected').css('background-color', 'LightSkyBlue');});// reset$('.reset').on('click', function() { $('*').css('background-color', '');}); .closest() 向上尋找所有祖先元素，直到第一個匹配的元素停止 .closest() 方法必須代入參數 (選擇器) 範例 實例搶先看 .closest() 向上尋找所有祖先元素，直到第一個匹配的元素停止 .closest() 方法必須代入參數 (選擇器) html123456789101112131415&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content selected&quot;&gt; &lt;h2&gt;.closest() 的效果&lt;/h2&gt; &lt;h3&gt;使用方式&lt;/h3&gt; &lt;ul class=&quot;selected&quot;&gt; &lt;li&gt;取得所有 li 元素向上尋找祖先元素，直到第一個 class 有 &quot;selected&quot; 的元素停止&lt;/li&gt; &lt;li class=&quot;target-1&quot;&gt;設定匹配元素的邊框&lt;/li&gt; &lt;li&gt;只設定第一個匹配的元素，因此上層的 div class 有 &quot;selected&quot;，但沒有被設定邊框&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js123456789// 使用方式一$('.example-1').on('click', function() { $('.target-1').closest('.selected').css('border', '1px solid red');});// reset$('.reset').on('click', function() { $('*').css('border', '');}); 尋找同層元素.siblings()尋找當前元素的所有同層元素 (排除自己)，也就是元素的兄弟姐妹 範例 實例搶先看 .siblings() 尋找當前元素的所有同層元素，也就是元素的兄弟姐妹 html12345678910111213141516171819202122&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content selected&quot;&gt; &lt;h2 class=&quot;selected&quot;&gt;.siblings() 的效果&lt;/h2&gt; &lt;h3&gt;使用方式一&lt;/h3&gt; &lt;ul class=&quot;target-1 selected&quot;&gt; &lt;li&gt;取得 class 有 &quot;target-1&quot; 的元素再匹配所有同層元素&lt;/li&gt; &lt;li&gt;設定所有同層元素的文字顏色&lt;/li&gt; &lt;li&gt;設定除了自己的同層元素&lt;/li&gt; &lt;/ul&gt; &lt;h3 class=&quot;target-2&quot;&gt;使用方式二&lt;/h3&gt; &lt;ul class=&quot;selected&quot;&gt; &lt;li&gt;取得 class 有 &quot;target-2&quot; 的元素再匹配所有同層 class 有 &quot;selected&quot; 元素&lt;/li&gt; &lt;li&gt;設定所有匹配同層元素的文字顏色&lt;/li&gt; &lt;li&gt;設定除了自己的同層元素&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式一&lt;/button&gt; &lt;button class=&quot;button is-info example-2&quot;&gt;使用方式二&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js1234567891011121314// 使用方式一$('.example-1').on('click', function() { $('.target-1').siblings().css('color', 'DodgerBlue');});// 使用方式二$('.example-2').on('click', function() { $('.target-2').siblings('.selected').css('color', 'LightSkyBlue');});// reset$('.reset').on('click', function() { $('ul').siblings().css('color', '');}); .next()尋找當前元素同層的下一個元素，也就是元素最大的弟弟或妹妹 範例 實例搶先看 .next() 尋找當前元素同層的下一個元素，也就是元素最大的弟弟或妹妹 html123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content selected&quot;&gt; &lt;h2&gt;.next() 的效果&lt;/h2&gt; &lt;h3 class=&quot;target-1&quot;&gt;使用方式一&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;取得 class 有 &quot;target-1&quot; 的元素再匹配同層的下一個元素&lt;/li&gt; &lt;li&gt;設定同層的下一個元素的文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;h3 class=&quot;target-2&quot;&gt;使用方式二&lt;/h3&gt; &lt;ul class=&quot;selected&quot;&gt; &lt;li&gt;取得 class 有 &quot;target-2&quot; 的元素再匹配同層下一個 class 有 &quot;selected&quot; 的元素&lt;/li&gt; &lt;li&gt;設定同層下一個匹配元素的文字顏色&lt;/li&gt; &lt;li&gt;如果同層下一個元素 class 沒有 &quot;selected&quot; 就無法設定文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式一&lt;/button&gt; &lt;button class=&quot;button is-info example-2&quot;&gt;使用方式二&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js1234567891011121314// 使用方式一$('.example-1').on('click', function() { $('.target-1').next().css('color', 'DodgerBlue');});// 使用方式二$('.example-2').on('click', function() { $('.target-2').next('.selected').css('color', 'LightSkyBlue');});// reset$('.reset').on('click', function() { $('*').css('color', '');}); .prev()尋找當前元素同層的上一個元素，也就是元素最小的哥哥或姐姐 範例 實例搶先看 .prev() 尋找當前元素同層的上一個元素，也就是元素最小的哥哥或姐姐 js123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content selected&quot;&gt; &lt;h2&gt;.prev() 的效果&lt;/h2&gt; &lt;h3 class=&quot;target-1&quot;&gt;使用方式一&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;取得 class 有 &quot;target-1&quot; 的元素再匹配同層的上一個元素&lt;/li&gt; &lt;li&gt;設定同層的上一個元素的文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;h3 class=&quot;selected&quot;&gt;使用方式二&lt;/h3&gt; &lt;ul class=&quot;target-2&quot;&gt; &lt;li&gt;取得 class 有 &quot;target-2&quot; 的元素再匹配同層上一個 class 有 &quot;selected&quot; 的元素&lt;/li&gt; &lt;li&gt;設定同層上一個匹配元素的文字顏色&lt;/li&gt; &lt;li&gt;如果同層上一個元素 class 沒有 &quot;selected&quot; 就無法設定文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式一&lt;/button&gt; &lt;button class=&quot;button is-info example-2&quot;&gt;使用方式二&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js1234567891011121314// 使用方式一$('.example-1').on('click', function() { $('.target-1').prev().css('color', 'DodgerBlue');});// 使用方式二$('.example-2').on('click', function() { $('.target-2').prev('.selected').css('color', 'LightSkyBlue');});// reset$('.reset').on('click', function() { $('*').css('color', '');}); 這段代碼會將類別為 .current 的元素的上一個同層元素字體加粗。 尋找子元素.children()只尋找當前元素下一層匹配的元素，也就是尋找元素的親生小孩 範例 實例搶先看 .children() 只尋找當前元素下一層匹配的元素，也就是尋找元素的親生小孩 html123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2&gt;.children() 的效果&lt;/h2&gt; &lt;h3&gt;使用方式一&lt;/h3&gt; &lt;ul class=&quot;target-1&quot;&gt; &lt;li&gt;取得 class 有 &quot;target-1&quot; 的元素再匹配所有下一層的元素&lt;/li&gt; &lt;li&gt;設定所有下一層元素的文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;使用方式二&lt;/h3&gt; &lt;ul class=&quot;target-2&quot;&gt; &lt;li&gt;取得 class 有 &quot;target-2&quot; 的元素再匹配所有下一層 class 有 &quot;selected&quot; 的元素&lt;/li&gt; &lt;li class=&quot;selected&quot;&gt;設定所有下一層元素的文字顏色&lt;/li&gt; &lt;li class=&quot;selected&quot;&gt;沒有 &quot;selected&quot; 的元素不會被設定&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式一&lt;/button&gt; &lt;button class=&quot;button is-info example-2&quot;&gt;使用方式二&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js1234567891011121314// 使用方式一$('.example-1').on('click', function() { $('.target-1').children().css('color', 'DodgerBlue');});// 使用方式二$('.example-2').on('click', function() { $('.target-2').children('.selected').css('color', 'LightSkyBlue');});// reset$('.reset').on('click', function() { $('*').css('color', '');}); .find() 向下尋找所有匹配的後代元素 .find() 方法必須代入參數 (選擇器) 範例 實例搶先看 .find() 向下尋找所有匹配的後代元素 .find() 方法必須代入參數 (選擇器) html123456789101112131415&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content target-1&quot;&gt; &lt;h2 class=&quot;selected&quot;&gt;.find() 的效果&lt;/h2&gt; &lt;h3&gt;使用方式&lt;/h3&gt; &lt;ul&gt; &lt;li class=&quot;selected&quot;&gt;取得 class 有 &quot;target-1&quot; 的元素再向下匹配所有 class 有 &quot;selected&quot; 的元素&lt;/li&gt; &lt;li class=&quot;selected&quot;&gt;設定匹配元素的文字顏色&lt;/li&gt; &lt;li&gt;如果元素的 class 沒有 &quot;selected&quot; 就無法設定文字顏色&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example-1&quot;&gt;使用方式&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js123456789// 使用方式一$('.example-1').on('click', function() { $('.target-1').find('.selected').css('color', 'DodgerBlue');});// reset$('.reset').on('click', function() { $('*').css('color', '');}); 結論jQuery 提供了強大的工具，能快速尋找父元素、同層元素與子元素，讓操作 DOM 結構更加靈活且高效。 尋找父元素 .parent()：尋找最近的父元素 .parents()：尋找所有祖先元素 .closest()：尋找最近且符合條件的祖先元素 尋找同層元素 .siblings()：尋找所有同層元素（不包括自身） .next()：尋找下一個同層元素 .prev()：尋找上一個同層元素 尋找子元素 .children()：尋找所有直接子元素 .find()：尋找所有符合條件的子元素 除了這些常用方法外，還有一些進階方法，如 .parentsUntil() 和 .offsetParent() 等，可以根據需求選擇最適合的方法～ 動手做做看 html 線上編輯器 延伸閱讀【天矽科技】DOM 是什麼?【jQuery 官方文件】tree-traversal 介紹","link":"/Frontend/JQuery/Methods-for-Finding-Parent-and-Sibling-and-Child-Elements/"},{"title":"【HTML】解析 &lt;a&gt; 的 rel 屬性","text":"本篇重點 了解 &lt;a&gt; 的 rel 屬性 &lt;a&gt; 常見的 rel 屬性值和用途 不同情境下 &lt;a&gt; rel 屬性的使用方式 現代瀏覽器在大部分情況下已經自動為帶有 target=&quot;_blank&quot; 的連結加上 rel=&quot;noopener&quot; 調用 window.opener 的方法 了解 &lt;a&gt; 的 rel 屬性&lt;a&gt; 元素常用於創建超連結，連結其他頁面或網站。而 rel 全名 “relationship” 用來定義當前文件和連結資源之間的關係，這個屬性不僅能夠影響 SEO，還能提升網站的安全性。 &lt;a&gt; 常見的 rel 屬性值和用途noopener當使用 target=&quot;_blank&quot; 開啟新頁面時，使用此屬性可以防止新視窗操作原本的網站，避免潛在的安全風險。noopener 和 Javascript 有關，新視窗可以使用 window.opener 來控制原視窗，藉此執行惡意行為。 健忘筆記 現代瀏覽器在大部分情況下已經自動為帶有 target=&quot;_blank&quot; 的連結加上 rel=&quot;noopener&quot;，所以有沒有設定 noopener 屬性，在新視窗使用 window.opener 都會得到 null，但為了確保相容性和覆蓋到所有情況，依然建議明確地設定 rel=&quot;noopener&quot;。【Chrome Platform Status】自動為所有使用 target=”_blank” 的連結加上 rel=”noopener” 例如js12345678// 原視窗重新導向到首頁window.opener.location.href = &quot;https://forgetfulengineer.github.io/&quot;;// 開啟原視窗的 alertwindow.opener.alert('你點到惡意連結了');// 操作原視窗的 DOMwindow.opener.document.querySelector('body').innerHTML='&lt;b style=&quot;color: red; font-size: 100px; margin: auto;&quot;&gt;你點到惡意連結了&lt;/b&gt;'; noreferrer阻止瀏覽器在新頁面中傳送 Referer 標頭，從而保護當前頁面 URL 不被暴露給目標網站。這個屬性也會自動包含 noopener 的效果。 健忘筆記 網站內部連結時，千萬別加上 noreferrer 這個屬性值，否則會影響 SEO！ nofollow告訴搜尋引擎忽視兩個網站間的關聯，不要追蹤此連結，對於原視窗沒有影響，但會影響新視窗的流量分析和 SEO。這個屬性通常應用在廣告或不信任的外部連結上，以防止影響網站的 SEO 排名。 健忘筆記 backlink 是 SEO 計算排名的指標之一，如果某知名網站推廣了健忘工程師網站，並且沒有使用 nofollow，就可能提高網站的 SEO 分數。 external告訴瀏覽器或一些輔助工具（如 SEO 工具或網頁分析工具），這個連結指向的是一個外部網站。 ugc（User Generated Content）用於標示用戶生成的內容，常見於評論、留言等。 sponsored表示該連結為付費推廣或廣告內容，這有助於透明地告知搜尋引擎該連結的性質。 不同情境下 &lt;a&gt; rel 屬性的使用方式 rel 屬性可以疊加使用 外部連結針對外部連結可以使用 rel=&quot;noopener noreferrer nofollow external&quot; html1&lt;a href=&quot;&lt;https://www.google.com&gt;&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow external&quot;&gt;google&lt;/a&gt; 提升 SEO 針對付費推廣連結時可以使用rel=&quot;sponsored&quot; 針對用戶自行提交的連結可以使用 rel=&quot;ugc nofollow&quot; html123&lt;a href=&quot;&lt;https://ads.com&gt;&quot; rel=&quot;sponsored&quot;&gt;Ads&lt;/a&gt;&lt;a href=&quot;&lt;https://user-content.com&gt;&quot; rel=&quot;ugc nofollow&quot;&gt;User Content&lt;/a&gt; 調用 window.opener 的方法隨著瀏覽器安全性的提升，現代瀏覽器已經自動為所有帶有 target=&quot;_blank&quot; 的連結加上 rel=&quot;noopener&quot;，這是為了防止新視窗通過 window.opener 對原視窗進行操作，避免可能的安全漏洞（如釣魚攻擊）。 如果在某些情境下需要測試或使用 window.opener，這邊提供兩種方法～ 設置 rel=&quot;opener&quot; 使用 window.open() 開啟新連結 需要注意的是，這只能在原視窗與新視窗位於相同域名的情況下使用，如果是跨域情況，則無法操作 window.opener。 html12345&lt;!-- 設置 rel=&quot;opener&quot; --&gt;&lt;a href=&quot;https://example.com&quot; target=&quot;_blank&quot; rel=&quot;opener&quot;&gt;測試 window.opener&lt;/a&gt;&lt;!-- 使用 window.open() 開啟新連結 --&gt;&lt;button onclick=&quot;javascript:window.open('https://example.com');&quot;&gt;測試 window.opener&lt;/button&gt; 😈 惡意連結實例 原視窗重新導向到首頁 開啟原視窗的 alert 操作原視窗的 DOM 結論rel 屬性雖然簡單，但在網站的安全性、SEO 扮演著重要角色。 noopener：阻擋新視窗操作原視窗 (現代瀏覽器已經自動為所有帶有 target=&quot;_blank&quot; 的連結加上 rel=&quot;noopener&quot;) noreferrer：阻止瀏覽器在新頁面中傳送 Referer 標頭，影響新視窗的 SEO nofollow：告訴搜尋引擎忽視兩個網站間的關聯，影響新視窗的 SEO external：告訴瀏覽器此連結是外部連結 ugc：標示用戶生成的內容 sponsored：標示此連結為付費推廣或廣告內容 延伸閱讀【MDN】rel 屬性介紹【MDN】Window: opener 屬性介紹【Chrome Platform Status】自動為所有使用 target=”_blank” 的連結添加 rel=”noopener”","link":"/Frontend/Html/Understanding-the-rel-Attribute-of-the-a-Tag/"},{"title":"【Linux】使用 less 查看檔案","text":"本篇重點 less 基本使用方法 less 的實用選項：-N、-S、+F、-p、-i、-m less 檢視模式內的快捷鍵：/pattern、?pattern、&amp;pattern、n、N、g、G、F、q、h 比較 less 和 more 的差異 在 Linux 中，經常需要查看文字檔案的內容，例如系統日誌、設定檔等。當查看大檔案時，使用 cat 會一次顯示全部內容，這不僅會造成閱讀困難，也可能因為資料龐大而影響載入速度。這時，less 就是一個非常實用的工具，能夠讓使用者輕鬆瀏覽檔案內容，不會一次性載入全部資料，並按需求檢視，接下來介紹 less 命令的使用方法。 less 基本使用方法在終端輸入 less 加上檔案名稱即可檢視檔案 command123# less ［檔案名稱］less example.txt less 的實用選項當使用 less 查看檔案時，可以透過不同的選項來提升檢視效率 動手做做看 -N：顯示行號讓每一行都顯示行號，方便定位具體行數。 command123# less -N ［檔案名稱］less -N example.txt -S：長行單行顯示預設情況下，超過螢幕寬度的長行會自動換行，使用此選項可以保持單行顯示。 command123# less -S ［檔案名稱］less -S example.txt +F：追蹤檔案最後一行的變動類似 tail -f，適合查看動態更新的日誌文件，會自動顯示新增的內容。 command123# less +F ［檔案名稱］less +F example.txt 健忘筆記 less +F 是追蹤檔案最後一行的變動，如果透過編輯器修改文件的中間部分或重寫文件的某些區塊，可能會導致 less +F 無法正確解析或錯誤更新，因為它只關注尾端的變化。 -p &quot;pattern&quot;: 直接搜尋特定字串打開檔案的同時，直接搜尋特定字串，並跳轉到該字串的位置。 command123# less -p &quot;pattern&quot; ［檔案名稱］less -p &quot;test&quot; example.txt -i：搜尋時忽略大小寫查看文件時，搜尋關鍵字忽略大小寫。 command123# less -i ［檔案名稱］less -i example.txt -m：顯示查看進度查看文件時，底部顯示當前進度。 command123# less -m ［檔案名稱］less -m example.txt 選項疊加使用各選項可以疊加使用，增加靈活度 command12# 查看文件時，顯示行號、長行單行顯示、顯示查看進度less -NSm example.txt 檢視模式內的快捷鍵進入 less 的檢視模式後，可以使用一些快捷鍵來操作檔案。 動手做做看 /pattern：向下搜尋字串，輸入 / 後跟著填入要搜尋的字串，less 會跳轉到該字串第一次出現的地方，按 n 可以跳到下一個匹配 ?pattern：向上搜尋字串，? 會向上搜尋，跟 / 搜尋相反 &amp;pattern：只顯示匹配的字串行 n：跳轉到下一個匹配結果 N (shift + n)：跳轉到上一個匹配結果 g：跳轉到檔案開頭 G (shift + g)：跳轉到檔案結尾 F (shift + f)：追蹤檔案最後一行的變動，和 less +F 的效果相同 q：退出 less h：顯示幫助頁面，列出所有快捷鍵 比較 less 和 more 的差異more 較早的工具，功能相對簡單 一次性加載整個檔案，當檔案很大時，可能會花較長時間加載 關閉 more 後，終端會保留顯示過的檔案內容 less more 的增強版本，具備更靈活的操作功能 分段加載檔案，僅顯示需要的部分 關閉 less 後，終端不會顯示檔案內容，回到執行 less 前的狀態 結論less 透過選項與快捷鍵可以靈活地檢視大檔案、日誌文件或程式碼，如果有其他有趣的選項或快捷鍵，歡迎在下方留言分享！ 動手做做看 Linux 線上模擬器","link":"/Backend/Linux/Using-less-to-View-Files/"},{"title":"【Css】解析五種常見的相對單位","text":"本篇重點 常見的相對單位：%、em、rem、vh、vw 相對單位的使用方式和時機 在 CSS 中，除了固定的像素單位（px）之外，還有許多相對單位可以根據父元素比例或視窗大小或元素字體自動調整，是現代響應式設計（RWD）不可或缺的工具。 %：父元素的相對比例最基本的相對單位，常用來設定元素尺寸（例如 width、height、margin、padding 等），其值是相對於父元素對應屬性的比例，表示當父元素的尺寸改變時，使用百分比的子元素會隨之縮放。 範例利用百分比設計圖片區塊，讓圖片隨著不同的螢幕寬度自適應 實例搶先看 %：父元素的相對比例 相對於父元素對應屬性的比例 html123&lt;div class=&quot;responsive-wrapper&quot;&gt; &lt;img src=&quot;https://forgetfulengineer.github.io/gallery/covers/Understanding-five-Common-Relative-Units.png&quot;&gt;&lt;/div&gt; css123456789/* 寬度預設為 width: 100%，寬度隨螢幕寬度改變 */.responsive-wrapper { background-color: blue;}.responsive-wrapper img { width: 80%; /* 圖片佔父容器 80% */ height: auto; /* 維持圖片比例 */} em：字體大小的相對單位相對於當前元素或父元素字體大小的單位，常用於需要隨字體大小變化調整元素大小的排版，例如調整字體和內邊距，讓內、外邊距跟隨字體大小調整，保持整體視覺一致，或是設置多層次樣式，呈現層級關係時使用。 假設一個父容器的字體大小為 20px，子元素的 padding 設為 1.5em，則子元素實際的 padding 值為 30px，因為 1.5em * 20px = 30px。 健忘筆記 em 的參照順序： 當前元素有設置 font-size，則 em 以當前元素的字體大小為基準。 若當前元素沒有設定 font-size，會沿著 DOM 樹逐層向上找，直到找到最近一個有 font-size 的父元素。 如果沒有找到設置的字體大小，則最終會參照根元素 &lt;html&gt; 的 font-size。根元素默認值通常是 16px（但可透過 CSS 調整，例如 html { font-size: 10px; }）。 範例 實例搶先看 em：字體大小的相對單位 相對於當前元素或父元素字體大小的單位 html1234&lt;div class=&quot;parent&quot;&gt; 測試內容 &lt;button class=&quot;child&quot;&gt;我是按鈕&lt;/button&gt;&lt;/div&gt; css12345678.parent { font-size: 30px;}button { font-size: 0.5em; padding: 0.5em 1em;} 健忘筆記 em 是相對於當前元素或父元素字體大小的單位，如果父元素和當前元素同時使用 em，則當前元素屬性的大小會隨著層級增加而累積 rem：根元素字體大小的相對單位rem（root em）是相對於根元素（通常是 &lt;html&gt;）字體大小的單位，統一的相對大小能確保在頁面中一致性設計。 假設根元素的字體大小為 20px，其子元素的 padding 設為 1.5rem，則子元素實際的 padding 值為 30px，因為 1.5rem * 20px = 30px。 範例 實例搶先看 rem：根元素字體大小的相對單位 相對於根元素（通常是 &lt;html&gt;）字體大小的單位 html1234&lt;div class=&quot;container&quot;&gt; 容器文字大小為 24px &lt;div class=&quot;child&quot;&gt;子元素文字大小為 32px&lt;/div&gt;&lt;/div&gt; css1234567/* 根元素 font-size 預設 16px */.container { font-size: 1.5rem; /* 1.5 * 16px = 24px */}.child { font-size: 2rem; /* 2 * 16px = 32px */} vh 和 vw：用戶視窗高和寬的比例相對於用戶視窗高度和寬度的單位，適合設計需要相對於視窗尺寸而調整的布局，讓元素能隨著不同裝置和瀏覽器窗口大小動態縮放，常用於設置全螢幕背景或全螢幕容器，例如：lightbox。 1vh 表示視窗高度的 1% 20vw 表示視窗寬度的 20% 範例 實例搶先看 vh 和 vw：用戶視窗高和寬的比例 相對於用戶視窗高度和寬度的單位 html1&lt;img src=&quot;https://forgetfulengineer.github.io/gallery/covers/Understanding-five-Common-Relative-Units.png&quot;&gt; css1234img { height: 30vh; /* 視窗高度的 30% */ width: 50vw; /* 視窗寬度的 50% */} 健忘筆記 裝置旋轉的影響：vh 和 vw 會根據視窗實際顯示區的高度和寬度來計算，因此旋轉裝置時，元素可能會突然變大或縮小。 捲軸條影響：若瀏覽器視窗出現垂直或水平捲軸條，會佔據一定的寬度或高度，影響到 vw 和 vh 的實際計算結果。 本網站的 lightbox 使用 vw 來控制寬度，可以點擊 實例搶先看 或 文章圖片 查看元素的寬度～ 結論這些相對單位可以更靈活得設計響應式佈局，並確保網頁在不同設備和視窗大小上都能有適當的呈現。 %：父元素的相對比例 em：當前元素或父元素字體大小的相對單位 rem：根元素字體大小的相對單位 vh 和 vw：用戶視窗高和寬的比例 動手做做看 codepen 線上編輯器 延伸閱讀【W3Schools】單位大全【愛貝斯網路】RWD是甚麼?","link":"/Frontend/Css/Understanding-five-Common-Relative-Units/"},{"title":"【GitHub】追蹤檔案修改紀錄","text":"本篇重點 查看檔案的 commit 紀錄 依作者或時間查詢 commit 紀錄 使用 blame 查看檔案的逐行修改紀錄 blame 模式下，還原檔案至指定 commit 前的狀態，查看修改前的內容 Git 的 git blame 查看檔案的逐行修改紀錄 在軟體開發中，版本控制是用來追蹤檔案修改紀錄的重要工具，不僅能掌握專案的歷史變更，還能快速查找特定的修改。GitHub 提供了多種實用工具來幫助開發者追蹤檔案變更，blame 功能就是其中一個非常實用的功能，可以逐行檢視修改詳情，接下來來了解 GitHub 上幾種查看檔案修改紀錄的方法。 查看檔案的 commit 紀錄每當檔案修改並提交 commit 後，會記錄修改人、修改時間以及提交內容說明。 1. 查找檔案透過目錄尋找檔案 透過路徑或檔名尋找檔案 2. 點擊檔案右上方的 History 顯示檔案的所有 commit 歷程（新到舊） 此頁面顯示所有與該檔案相關的提交紀錄，包括每次提交的 SHA 值、提交者、提交時間及提交說明，並且可以點擊 commit，進一步檢視 commit 的修改內容。 依作者或時間查詢 commit 紀錄在 commit 歷史頁面，GitHub 提供了篩選功能，可以依據作者、日期查詢 commit 紀錄。 依作者查詢因為這個專案只有我在維護，所以能查詢的作者只有 forgetfulengineer 依日期查詢 查詢功能能快速找到特定修改者或在特定時間範圍內更動紀錄，特別適合用於大型專案或長期維護的專案。 使用 blame 查看檔案的逐行修改紀錄blame 是 GitHub 上一項強大的功能，用於查看檔案每一行的修改紀錄，能精確地了解每一行的最新修改者及其修改時間，對於排查問題和追溯修改原因很有幫助。 1. 查找檔案 2. 點擊檔案左方的 Blame 3. 查看檔案的逐行修改紀錄可以看到每一行左側顯示了最新修改此行的 commit 記錄、作者和時間 在 blame 模式下，可以直接點擊每行的 commit 說明來檢視該提交的詳細內容，進一步追蹤更動的原因和細節。 還原檔案至指定 commit 前的狀態，查看修改前的內容有時可能想查看檔案某一行或某一個 commit 前的檔案內容，例如確認修改前的檔案狀況或排查錯誤。在 blame 模式下，可以點擊每行 commit ID 旁邊的按鈕達到還原的效果。 1. 點擊檔案左方的 Blame 2. 點擊 commit ID 旁邊的按鈕 點擊後，檔案將會還原到指定 commit 前的狀態！ Git 的 git blame 查看檔案的逐行修改紀錄Git 提供 git blame 指令，追蹤檔案每一行的修改紀錄，這個指令會顯示出每行程式碼的最新修改資訊，包括提交的作者、日期和 commit ID。 123git blame [檔案名稱]git blame example.txt 結論blame 功能非常實用，尤其在排查問題和追溯修改原因時效果顯著。我個人在追蹤檔案的修改紀錄時經常使用 blame，不僅更清晰地了解修改細節，也提升了整體追蹤效率。如果 GitHub 有其他方便的功能，歡迎在下方留言分享！ 延伸閱讀 【GitHub 官方文件】Viewing a file 【git 官方文件】git blame 說明","link":"/Other/GitHub/Tracking-File-Modification-History/"},{"title":"【PHP、JavaScript】陣列自定義排序","text":"本篇重點 PHP 的 usort() 陣列自定義排序 JavaScript 的 .sort() 陣列自定義排序 自定義排序比較函數的規則 PHP usort() 和 JavaScript .sort() 的反向排序 陣列自定義排序應用範例 PHP 的 usort()根據自定義的邏輯對陣列進行排序，不保留鍵名，僅針對值進行排序，並且直接修改原陣列 usort($array, $callback); php123usort($array, function($a, $b) { return $a &lt;=&gt; $b;}); $array 為欲排序的陣列 $callback 為比較函數 比較函數的規則 return &lt; 0：$a 排在 $b 前 return &gt; 0：$a 排在 $b 後 return === 0：$a 和 $b 順序保持不變 &lt;=&gt; 介紹&lt;=&gt; 是 PHP 7 引入的「太空船運算子」（Spaceship Operator），用來比較兩個值的大小，返回三種結果 返回 -1：左邊的值小於右邊的值 返回 0：左邊的值等於右邊的值 返回 1：左邊的值大於右邊的值 範例 情境一，對一組隨機亂數的陣列，依小到大做排序 (升序) php1234567891011121314151617$array = [5, 2, 9, 1, 3];// 方法一usort($array, function($a, $b) { return $a - $b; // 差值決定排序順序});// 方法二usort($array, function($a, $b) { return $a &lt;=&gt; $b;});// 方法三 (單層的陣列可以直接使用 sort() 排序，預設排序是小到大)sort($array);print_r($array);// 輸出: [1, 2, 3, 5, 9] 動手做做看 對一組隨機亂數的陣列，依小到大做排序 動手做做看 情境二，假設得到一組陣列資料，裡面有各個活動的資訊，依需求對陣列排序。 整體順序是 1.未到期活動 2.已到期活動，且皆以最新到最舊活動排序，執行方式為判斷活動結束時間 end_date 是否小於現在時間 (是否到期)，未到期活動排在已到期活動前面，再以活動開始時間 start_date 大到小排序 實例搶先看 假設得到一組陣列資料，裡面有各個活動的資訊，對陣列做排序 整體順序是 1. 未到期活動 2.已到期活動，且皆以最新到最舊活動排序 php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 活動資訊陣列$array = [ [ &quot;id&quot; =&gt; 1, &quot;event_time&quot; =&gt; [ &quot;start_date&quot; =&gt; 1730084400, // 2024-10-28 11:00:00 &quot;end_date&quot; =&gt; 1731513659 // 2024-11-14 00:00:59 ] ], [ &quot;id&quot; =&gt; 2, &quot;event_time&quot; =&gt; [ &quot;start_date&quot; =&gt; 1729512000, // 2024-10-21 20:00:00 &quot;end_date&quot; =&gt; 1731254400 // 2024-11-11 00:00:00 ] ], [ &quot;id&quot; =&gt; 3, &quot;event_time&quot; =&gt; [ &quot;start_date&quot; =&gt; 1730102400, // 2024-10-28 16:00:00 &quot;end_date&quot; =&gt; 1731686400 // 2024-11-16 00:00:00 ] ]];// 排序函數usort($array, function ($a, $b) { $current_time = time(); $a_end_date = $a['event_time']['end_date']; $b_end_date = $b['event_time']['end_date']; $a_start_date = $a['event_time']['start_date']; $b_start_date = $b['event_time']['start_date']; // 首先判斷是否過期 $a_is_expired = $a_end_date &lt; $current_time; $b_is_expired = $b_end_date &lt; $current_time; // 如果一個過期一個未過期，將未過期的排前面 if ($a_is_expired !== $b_is_expired) { return $a_is_expired &lt;=&gt; $b_is_expired; } // 否則依據 start_date 從大到小排序 return $b_start_date &lt;=&gt; $a_start_date;});print_r($array); 動手做做看 動手做做看 JavaScript 的 .sort().sort() 是 JavaScript 提供的陣列排序方法，與 PHP 的 usort() 規則非常相似，允許傳入自定義的比較函數，並且直接修改原陣列。 array.sort([compareFunction]) js123array.sort(function (a, b) { return a - b;}); array 為欲排序的陣列 compareFunction 為比較函數 比較函數的規則： return &lt; 0：a 排在 b 前 return &gt; 0：a 排在 b 後 return === 0：順序保持不變 健忘筆記 JavaScript 沒有 &lt;=&gt; 運算子 範例 情境一，對一組隨機亂數的陣列，依小到大做排序 (升序) js123456789101112let array = [5, 2, 9, 1, 3];// 方法一，.sort() 預設就是以小排到大array.sort();// 方法二，差值決定排序順序array.sort(function (a, b) { return a - b;});console.log(array);// 輸出: [1, 2, 3, 5, 9] 情境二，假設需要依照指定順序照片排序 陣列內是指定順序的照片編號 實例搶先看 假設需要依照指定順序照片排序 陣列內是指定順序的照片編號 html12345&lt;div class=&quot;images_container&quot;&gt; &lt;img data-id=&quot;1&quot; src=&quot;https://forgetfulengineer.github.io/gallery/covers/Tracking-File-Modification-History.png&quot;&gt;&lt;/img&gt; &lt;img data-id=&quot;2&quot; src=&quot;https://forgetfulengineer.github.io/gallery/covers/Understanding-five-Common-Relative-Units.png&quot;&gt;&lt;/img&gt; &lt;img data-id=&quot;3&quot; src=&quot;https://forgetfulengineer.github.io/gallery/covers/Using-less-to-View-Files.png&quot;&gt;&lt;/img&gt;&lt;/div&gt; js1234567891011let images_sorting_arr = [3, 1, 2];let images_container = $(&quot;.images_container&quot;);let images = $(&quot;.images_container [data-id]&quot;).toArray();category_news.sort(function (a, b) { return ( images_sorting_arr.indexOf($(a).data(&quot;id&quot;)) - images_sorting_arr.indexOf($(b).data(&quot;id&quot;)) );});images_container.empty();$(images).appendTo(images_container); PHP usort() 的反向排序php12345678910111213141516171819202122$array = [5, 2, 9, 1, 3];// 方法一usort($array, function($a, $b) { return $b - $a;});// 方法二usort($array, function($a, $b) { return $b &lt;=&gt; $a;});// 方法三 (使用負號來反轉比較結果)usort($array, function($a, $b) { return -($a &lt;=&gt; $b);});// 方法四 (單層的陣列可以直接使用 rsort() 排序)rsort($array);print_r($array);// 輸出: [9, 5, 3, 2, 1] 動手做做看 得到一組隨機亂數的陣列，依小到大做排序 動手做做看 JavaScript .sort() 的反向排序js12345678910111213let array = [5, 2, 9, 1, 3];// 方法一，先用 .sort() 小排到大，再用 .reverse() 把陣列順序反轉array.sort();array.reverse();// 方法二，差值決定排序順序array.sort(function (a, b) { return b - a;});console.log(array);// 輸出: [9, 5, 3, 2, 1] 結論PHP 的 usort() 和 JavaScript 的 .sort() 是功能非常相似的自定義排序工具，並遵循相同的比較函數邏輯判斷 return &lt; 0：$a 排在 $b 前 return &gt; 0：$a 排在 $b 後 return === 0：$a 和 $b 順序保持不變 自定義排序可以更靈活的依照需求得到想要的陣列，在開發上很有幫助！ 延伸閱讀 【PHP 官方文件】usort 介紹 【w3schools】PHP Sorting Arrays 【w3schools】PHP Operators (邏輯運算子) 【w3schools】JavaScript Sorting Arrays","link":"/Backend/PHP/Custom-Sorting-an-Array/"},{"title":"【Git】強制更新遠端分支進度到本地分支","text":"本篇重點 強制更新遠端分支進度到本地分支的方法 git checkout -B 強制更新本地分支 刪除並重新建立本地分支 git reset --hard 強制更新本地分支 強制更新本地分支進度到遠端分支的方法 git push -f 強制更新遠端分支 在版本控制的過程中，有時會遇到本地分支的進度與遠端分支不同步的情況，而當遠端分支的進度才是正確版本時，需要強制更新本地分支來與遠端保持同步。以下提供三種方法來完成本地分支的強制更新！ 強制更新遠端分支進度到本地分支方法一：git checkout -B（推薦）git12git fetch origingit checkout -B local-branch origin/remote-branch 使用 git fetch 更新遠端分支的資訊。 接著執行 git checkout -B，該指令會執行以下操作： 切換到指定的本地分支（若不存在，會自動建立）。 強制將本地分支重置為遠端分支的最新進度。 不管當前位於哪個分支，都可以直接使用 git checkout -B 來切換並更新指定分支 範例 遠端分支為 origin/develop，本地分支為 develop git12git fetch origingit checkout -B develop origin/develop 方法二：刪除並重新建立分支git123git fetch origingit branch -D local-branchgit checkout -b local-branch origin/remote-branch 使用 git fetch 更新遠端分支的資訊。 使用 git branch -D 刪除本地分支。 透過 git checkout -b 重新建立一個與遠端分支同步的本地分支。 範例遠端分支為 origin/develop，本地分支為 develop git1234git fetch origingit checkout mastergit branch -D developgit checkout -b develop origin/develop 健忘筆記 使用 git branch -D 刪除分支時，要先離開欲刪除的分支 git checkout -b 只能建立當前不存在的分支 方法三：git reset --hardgit123git fetch origingit checkout local-branchgit reset --hard origin/remote-branch 使用 git fetch 更新遠端分支的資訊。 使用 git checkout -b 切換到欲更新的分支。 使用 git reset --hard 將當前的本地分支強制重置為遠端分支的最新進度。 範例遠端分支為 origin/develop，本地分支為 develop git123git fetch origingit checkout developgit reset --hard origin/develop 健忘筆記 git reset --hard 會丟失本地的變更，本地未提交的更改將會消失 強制更新本地分支進度到遠端分支git push -fgit12git checkout local-branchgit push -f origin remote-branch 使用 git checkout -b 切換到要推送的分支。 使用 git push -f 強制更新遠端分支進度。 範例遠端分支為 origin/develop，本地分支為 develop git12git checkout developgit push -f origin develop 健忘筆記 如果遠端分支的名稱和本地分支的名稱不同（遠端分支為 origin/develop，本地分支為 dev），可以使用 git push -f origin dev:develop 做更新 結論我認為使用 git checkout -B 是最方便且直觀的方式，能快速完成本地分支與遠端分支的同步，且無需額外刪除或重建分支，適合大多數情況。不過，選擇哪種方式還是取決於當前分支的狀況與需求。需要特別注意的是，強制更新可能會無法復原，所以執行時要特別注意，確認無誤再更新，避免重要紀錄遺失。 延伸閱讀【Git 官方文件】git checkout -B 介紹【Git 官方文件】git push -f 介紹【Git 官方文件】git reset –hard 介紹【Git 官方文件】git fetch 介紹","link":"/Other/Git/Force-Update-Local-Branch-with-Remote-Branch-Progress/"},{"title":"【NPM、GitHub】解決 npm 版本落後 GitHub 版本的問題","text":"本篇重點 如果發現 npm 套件的版本有 bug，但 GitHub 上的版本已修正，應該如何安裝修正版套件？ 怎麼處理 npm 版本落後於 GitHub 版本的狀況 怎麼使用 npm 安裝 GitHub 套件的指定版本？ 怎麼使用 npm 更新 GitHub 套件？ hexo-generator-sitemap 的 3.0.1 版本存在 bug，導致沒有指定 sitemap 檔案，影響網站 seo 本網站使用 hexo-generator-sitemap 自動生成站點地圖（sitemap.xml），但透過 npm 安裝後，套件沒有正常運作，檢查後發現 npm 套件的版本存在 bug，而套件的 GitHub 儲存庫已修正問題，但修正版尚未發佈至 npm。 本篇文章將以 hexo-generator-sitemap 為例，分享如何處理 npm 版本落後於 GitHub 版本的狀況。 使用 npm 安裝 GitHub 套件指定版本在 GitHub 找到相對應的套件，查找正確的版本（特定分支或 commit id 或 tag 版號） 方法一：使用 npm 指令安裝套件npm12345678# 安裝指定 branch 版本npm install &lt;github-username&gt;/&lt;repository-name&gt;#&lt;branch&gt;# 安裝指定 commit 版本npm install &lt;github-username&gt;/&lt;repository-name&gt;#&lt;commit-hash&gt;# 安裝指定 tag 版本npm install &lt;github-username&gt;/&lt;repository-name&gt;#&lt;tag&gt; 健忘筆記 也可以使用 npm install git+https://github.com/&lt;github-username&gt;/&lt;repository-name&gt;.git，這同等於 npm install &lt;github-username&gt;/&lt;repository-name&gt;。會使用 git+https://... 的情境可能是如果儲存庫在自建 Git 伺服器上或非 GitHub 平台，需要更高的靈活性或精確指定完整 URL。 範例npm12345678# 安裝最新的 master 分支版本npm install hexojs/hexo-generator-sitemap#master# 安裝指定 commit 版本npm install hexojs/hexo-generator-sitemap#3ac80ce7a3c2506e99b7bf69010ac00b363e6222# 安裝指定 tag 版本npm install hexojs/hexo-generator-sitemap#v3.1.0 健忘筆記 如果沒有指定版本 npm install hexojs/hexo-generator-sitemap，預設安裝該 GitHub 儲存庫 default branch 的最新提交（通常是 main 或 master 分支） 方法二：修改 package.json 檔案並安裝將套件的寫入 package.json 並指定版本1234// 安裝指定 branch 或 tag 或 commit 版本&quot;dependencies&quot;: { &quot;&lt;package-name&gt;&quot;: &quot;github:&lt;username&gt;/&lt;repository&gt;#&lt;tag-or-commit&gt;&quot;} 執行 npm install 安裝套件npm1npm install 範例1234// 安裝指定 branch 或 tag 或 commit 版本&quot;dependencies&quot;: { &quot;hexo-generator-sitemap&quot;: &quot;github:hexojs/hexo-generator-sitemap#master&quot;} npm1npm install 健忘筆記 如果沒有指定版本 &quot;hexo-generator-sitemap&quot;: &quot;github:hexojs/hexo-generator-sitemap#master&quot;，預設安裝該 GitHub 儲存庫的 default branch 的最新提交（通常是 main 或 master 分支） 使用 npm 更新 GitHub 套件重新安裝覆蓋原本的版本npm12# 安裝儲存庫預設分支的最新版本npm install &lt;github-username&gt;/&lt;repository-name&gt; 範例npm12# 安裝 hexojs/hexo-generator-sitemap 的最新版本npm install hexojs/hexo-generator-sitemap 如果 package.json 的設定是 &quot;hexo-generator-sitemap&quot;: &quot;github:hexojs/hexo-generator-sitemap&quot;，可以直接使用 npm install 就會安裝套件的最新版本！ 健忘筆記 npm update 只針對 package.json 中指向 NPM 註冊表的套件進行檢查與更新，所以無法使用 npm update 來更新 GitHub 安裝的套件。 hexo-generator-sitemap 3.0.1 版本的 bug 【NPM】hexo-generator-sitemap 3.0.1 套件 錯誤說明套件的 lib/rel.js 負責將 &lt;link rel=&quot;sitemap&quot; href=&quot;...&quot; /&gt; 插入到 HTML 檔案的 &lt;head&gt; 標籤內。 lib/rel.jsnpm套件123// 將 sitemap 設定插到 &lt;head&gt; 的最後面const relSitemap = `&lt;link rel=&quot;sitemap&quot; type=&quot;application/xml&quot; title=&quot;Sitemap&quot; href=&quot;${url_for.call(this, path)}&quot;&gt;`;data.replace(/&lt;head&gt;(?!&lt;\\/head&gt;).+?&lt;\\/head&gt;/, str =&gt; str.replace('&lt;/head&gt;', `${relSitemap}&lt;/head&gt;`)); 當前正規表達式只能匹配到 &lt;head&gt; 標籤單行存在的狀況 html1&lt;head&gt;...&lt;/head&gt; 如果 &lt;head&gt; 標籤是多行排列時，正規表達式無法正確匹配，導致 sitemap 設定未寫入，影響網站 seo html1234// 正規表達式無法匹配&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt; 修正錯誤hexo-generator-sitemap 的 GitHub 儲存庫已修正 &lt;head&gt; 標籤多行排列，正規表達式無法正確匹配的錯誤。 lib/rel.jsGitHub修改紀錄12- return data.replace(/&lt;head&gt;(?!&lt;\\/head&gt;).+?&lt;\\/head&gt;/, str =&gt; str.replace('&lt;/head&gt;', `${relSitemap}&lt;/head&gt;`));+ return data.replace(/&lt;head&gt;(?!&lt;\\/head&gt;).+?&lt;\\/head&gt;/s, str =&gt; str.replace('&lt;/head&gt;', `${relSitemap}&lt;/head&gt;`)); 啟用修飾詞 s 讓特殊字元 . 可以匹配所有字元，包括換行符（\\n 或 \\r\\n）。 結論在開發過程中發現 hexo-generator-sitemap 的錯誤，進一步了解到 NPM 套件版本有時無法完全跟上 GitHub 上的最新版本。為了解決這個問題，可以直接從 GitHub 安裝最新修正的版本，讓套件正常運行。但需要注意的是這種方法只是暫時性的解決方案，未來還是需要關注 NPM 的正式版本更新，確保專案的長期穩定性和可維護性。如果你有其他解決方法或建議，也歡迎在下方留言分享～ 延伸閱讀【NPM 官方文件】npm install 介紹【NPM】hexo-generator-sitemap 套件【GitHub】hexo-generator-sitemap 套件【Fooish 程式技術】Regex 正規表示法 - 修飾詞","link":"/Other/NPM/Resolving-the-Issue-of-npm-Version-Lagging-Behind-the-GitHub-Version/"},{"title":"【Git】使用 git commit 修改提交（commit）的資訊或是內容","text":"本篇重點 git commit --amend 修改最新一次提交的資訊或是內容 git commit --amend --author 修改提交的作者和信箱 git commit --amend --reset-author 重置提交的作者和信箱 git commit --amend -m 修改提交訊息 git commit --amend --no-editor 提交修改但不修改提交訊息 每次修改提交 git commit --amend 都會變更提交 ID 在使用 Git 時，提交（commit）後才發現需要修改提交的資訊或內容。Git 提供了 git commit --amend 指令，能夠修改最新一次提交的內容或資訊，這樣能夠避免新增額外的提交，保持乾淨的提交歷史。 修改提交資訊修改提交的作者和信箱提交的作者和信箱是透過 git config 指令來設定的 git git12git config --global user.name &quot;你的名稱&quot;git config --global user.email &quot;你的信箱&quot; 詳細設定方式可查看 【Git】了解 git config 設定 修改最新一次提交的作者名稱和信箱方法一，git commit --amend --reset-author 設定正確的作者名稱和信箱資訊 git12git config --local user.name &quot;forgetfulengineer&quot;git config --local user.email &quot;thatforgetfulengineer@gmail.com&quot; 重置作者名稱和信箱資訊 git1git commit --amend --reset-author 方法二，git commit --amend --author git1234git commit --amend --author=&quot;新作者名稱 &lt;新信箱&gt;&quot;# 修改最新一次提交的作者名稱和信箱git commit --amend --author=&quot;forgetfulengineer &lt;thatforgetfulengineer@gmail.com&gt;&quot; 健忘筆記 信箱的 &lt;&gt; 一定要加上 如果要修改多個提交的資訊，可以使用 git rebase -i 加上操作指令 e, edit 達到目的，詳細可查看 【Git】使用 git rebase 整理提交歷史 修改提交訊息修改最新一次提交的訊息 git1git commit --amend -m &quot;修改後的提交訊息&quot; 範例原本的提交訊息為「修正錯誤」，修改改成「修正登入功能錯誤」 git1git commit --amend -m &quot;修正登入功能錯誤&quot; 如果要修改多個提交訊息，可以使用 git rebase -i 加上操作指令 r, reword 達到目的，詳細可查看 【Git】使用 git rebase 整理提交歷史 修改提交內容使用 Git 時，我的提交習慣是根據遠端分支的狀態來決定處理方式。如果提交尚未推送到無法強制修改的遠端分支（例如 master 或 main），我會保持每個提交精簡且整潔，避免有修正型的提交。例如，在設計網站的樣式並進行提交時，如果尚未更新到這些重要的遠端分支，仍處於自己的開發分支中，發現有需要修正的部分時，我不會新增一個修正提交，而是直接修正後再合併到原提交中，確保分支保持整潔。 但是當提交已經推送到無法強制修改的遠端分支時，為了避免影響該分支的穩定性，我會選擇透過提交一個新的修正分支，保留修改記錄的完整性。 新增內容到最新一次的提交在最新一次提交中加入新的修改，並使用 git commit --amend --no-edit 更新提交，這樣會將新添加的內容更新到最新一次的提交中，並保留原提交訊息跟資訊（作者、信箱） git12git add example.jsgit commit --amend --no-edit 如果要修改多個提交的內容，可以使用 git rebase -i 加上操作指令 e, edit 達到目的，詳細可查看 【Git】使用 git rebase 整理提交歷史 不更改提交訊息如果不需要修改提交訊息，可以加上 --no-edit 選項，保持原提交訊息不變： git12345# 提交當前檔案git commit --amend --no-edit# 提交當前檔案並且修改作者名稱和信箱git commit --amend --no-edit --author=&quot;forgetfulengineer &lt;thatforgetfulengineer@gmail.com&gt;&quot; 結論git commit --amend 是非常靈活的指令，用於修正最新一次提交的錯誤資訊或內容。然而需要注意的是，每次執行 git commit --amend 都會產生一個新的提交 ID，因此在使用時務必確認不會影響遠端分支的進度，尤其是在多人開發的專案中更需謹慎，以免造成分支衝突或其他協作問題。 延伸閱讀 【Git 官方文件】git commit --amend 介紹 【Git 官方文件】git commit --amend --no-edit 介紹 【Git 官方文件】git config 介紹","link":"/Other/Git/Using-git-commit-to-Modify-Commit-Data-or-Content/"},{"title":"【Tool】Unix 時間戳（Unix timestamp）轉換","text":"本篇重點 Unix timestamp 轉換工具 什麼是 Unix 時間戳（Unix timestamp） JavaScript 的 Date() 應用 如何建立日期物件、日期格式化、計算日期差 取得日期與時間的資訊、當前時區偏移量 #timestamp::-webkit-inner-spin-button, #timestamp::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } #timestamp { -moz-appearance: textfield; } .field .icon { z-index: 5 !important; } .control.has-icons-left .input:focus~.icon { color: rgb(146, 127, 108); } .icon.is-right .icon-text { display: none; } .timestamp_help { visibility: hidden; } .card { transition: opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out; opacity: 1; transform-origin: center top; } Unix 時間戳（Unix timestamp）轉換工具 時間戳（timestamp） 秒 毫秒 timestamp invalid 日期時間（date） 直接輸入時間或點擊右方月曆選取時間 $(document).ready(function () { let timeout; // 設定 #timestamp 預設為當下時間戳（秒） const now = Math.floor(Date.now() / 1000); $(\"#timestamp\").val(now); // 顯示當前時區 const timezoneOffset = -new Date().getTimezoneOffset() / 60; const gmtString = `GMT ${timezoneOffset >= 0 ? \"+\" : \"\"}${timezoneOffset}`; $(\"#gmt\").text(gmtString); // 監聽 #timestamp 和 #unit 的變化 $(\"#timestamp\").on(\"input\", updateCalendar); $(\"#unit\").on(\"change\", updateCalendar); // 監聽 #calendar 的變化 $(\"#calendar\").on(\"input\", updateTimestamp); // 手動觸發一次輸入事件，顯示當下日期時間 $(\"#timestamp\").trigger(\"input\"); // 更新 #calendar 的日期 function updateCalendar() { const timestamp = parseInt($(\"#timestamp\").val(), 10); const unit = parseInt($(\"#unit\").val(), 10); const date = new Date(timestamp * unit); if (!isNaN(date.getTime())) { const formattedDate = date.getFullYear() + \"-\" + String(date.getMonth() + 1).padStart(2, \"0\") + \"-\" + String(date.getDate()).padStart(2, \"0\") + \"T\" + String(date.getHours()).padStart(2, \"0\") + \":\" + String(date.getMinutes()).padStart(2, \"0\") + \":\" + String(date.getSeconds()).padStart(2, \"0\"); $(\"#calendar\").val(formattedDate); timestampFeedback(true); } else { timestampFeedback(false); } } // 更新 #timestamp 的數值 function updateTimestamp() { const dateStr = $(\"#calendar\").val(); const date = new Date(dateStr); var timestamp = date.getTime(); if (!isNaN(timestamp)) { const unit = parseInt($(\"#unit\").val(), 10); timestamp = Math.floor(timestamp / unit); $(\"#timestamp\").val(timestamp); } } function timestampFeedback(isValid) { let timestamp = $(\"#timestamp\"), help = $(\".timestamp_help\"), check = timestamp.siblings(\".icon.is-right\").find(\".has-text-success\"), error = timestamp.siblings(\".icon.is-right\").find(\".has-text-danger\"); clearTimeout(timeout); if (isValid) { check.fadeIn(); error.hide(); help.fadeTo(300, 0, function () { $(this).css(\"visibility\", \"hidden\"); }); } else { error.fadeIn(); check.hide(); help.css({\"visibility\":\"visible\", \"opacity\":\"1\"}); } timeout = setTimeout(function() { check.fadeOut(300); error.fadeOut(300); help.fadeTo(300, 0, function () { $(this).css(\"visibility\", \"hidden\"); }); }, 1500); } }); 查看原始碼 Unix 時間戳（Unix timestamp）轉換工具 健忘筆記 input 元素可以使用 type=&quot;datetime-local&quot; 產生 HTML5 內建的日期時間選擇器，想了解可以查看 【Html】實用的 &lt;input&gt; 表單屬性 什麼是 Unix 時間戳（Unix timestamp）Unix 時間戳（Unix timestamp）是一種時間表示方式，定義為從格林威治時間 1970 年 01 月 01 日 00 時 00 分 00 秒起到現在的總秒數。時間戳的特性是，不管在哪個時區，當下算出的時間戳都會是同樣的數值。這點對於應用程式非常有用，不管是要追蹤時間、計算時間差或是對日期進行排序，都可以利用時間戳來進行。在將時間戳轉換為時間時，也可以根據時區計算出當地的時間，是一種在程式中廣泛應用的技術。 JavaScript 的 Date() 應用Date 是 JavaScript 中內建的物件，專門用來處理日期和時間的工具。 建立日期物件Date 可以根據不同的方式建立日期物件 當前日期與時間javascript12const now = new Date();console.log(now); // Mon Jan 27 2025 16:20:45 GMT+0800 (台北標準時間) 指定日期javascript123// 2025 年 1 月 15 日const specificDate = new Date(2025, 0, 15);console.log(specificDate); // Wed Jan 15 2025 00:00:00 GMT+0800 (台北標準時間) 健忘筆記 JavaScript 的 Date() 月份（Month）是從 0 到 11 進行編號，0 表示 1 月、1 表示 2 月以此類推，因此指定月份的時候要手動減一 指定日期與時間javascript123// 2025/01/15 14:30:00const dateTime = new Date(2025, 0, 15, 14, 30, 0);console.log(dateTime); // Wed Jan 15 2025 14:30:00 GMT+0800 (台北標準時間) 透過字串建立javascript123// 解析 ISO 格式日期字串const fromString = new Date(&quot;2025-01-15T14:30:00&quot;);console.log(fromString); // Wed Jan 15 2025 14:30:00 GMT+0800 (台北標準時間) 透過時間戳建立javascript12const fromTimestamp = new Date(1673820000000);console.log(fromTimestamp); // Mon Jan 16 2023 06:00:00 GMT+0800 (台北標準時間) 健忘筆記 直接寫入時間戳的話，要以毫秒為單位 動手做做看 取得日期與時間的資訊Date 提供了多個方法來獲取特定的日期或時間資訊 javascript123456789101112131415const now = new Date();// 取得年份console.log(&quot;年:&quot;, now.getFullYear()); // 年: 2025// 取得月份（0-11，需要 +1）console.log(&quot;月:&quot;, now.getMonth() + 1); // 月: 1// 取得日期console.log(&quot;日:&quot;, now.getDate()); // 日: 27// 取得小時console.log(&quot;時:&quot;, now.getHours()); // 時: 16// 取得分鐘console.log(&quot;分:&quot;, now.getMinutes()); // 分: 26// 取得秒數console.log(&quot;秒:&quot;, now.getSeconds()); // 秒: 9// 取得星期幾（0 = 星期日）console.log(&quot;星期:&quot;, now.getDay()); // 星期: 1 健忘筆記 JavaScript 的 .getDay() 取得星期幾是從 0 到 6 進行編號，0 表示 星期日、1 表示 星期一以此類推。 *PHP 的 date('w') 也是如此，想了解 date('w') 可以查看 【PHP】五種實用的日期時間函數 動手做做看 時間戳應用Date 中的時間戳是以毫秒為單位，如果要取得以秒為單位的時間戳需要做轉換 javascript12345const now = new Date();// 取得毫秒時間戳console.log(&quot;毫秒時間戳:&quot;, now.getTime()); // 毫秒時間戳: 1737967042147// 換算成秒console.log(&quot;秒時間戳:&quot;, Math.floor(now.getTime() / 1000)); // 秒時間戳: 1737967042 動手做做看 日期格式化JavaScript 的 Date 沒有提供原生的格式化方法，但可以用字串拼接的方式實現 javascript12345678910111213141516// Date-Time Format：YYYY/MM/DD HH:MM:SSconst now = new Date();const formattedDate = now.getFullYear() + &quot;/&quot; + String(now.getMonth() + 1).padStart(2, &quot;0&quot;) + &quot;/&quot; + String(now.getDate()).padStart(2, &quot;0&quot;) + &quot; &quot; + String(now.getHours()).padStart(2, &quot;0&quot;) + &quot;:&quot; + String(now.getMinutes()).padStart(2, &quot;0&quot;) + &quot;:&quot; + String(now.getSeconds()).padStart(2, &quot;0&quot;);console.log(&quot;格式化日期:&quot;, formattedDate); // 格式化日期: 2025/01/27 16:43:21 健忘筆記 padStart() 用來在字串的開頭填充指定的字元，以確保字串達到特定的長度。 str.padStart(targetLength , padString) targetLength：目標字串的長度，如果原字串長度已經大於或等於 targetLength，則不會進行填充。 padString：用來填充的字串。如果未指定，預設會用空白字元 (“ “) 填充。 動手做做看 取得當前時區偏移量new Date().getTimezoneOffset() 回傳當前時區的偏移量（以分鐘為單位），偏移量表示本地時間與 GMT 的差異，且為相反數。 如果是 UTC+8，則偏移量為 -480（本地時間比 GMT 快 480 分鐘）。 如果是 UTC-5，則偏移量為 300（本地時間比 GMT 慢 300 分鐘）。 javascript123456// 計算當前時區相對於 GMT 的時差（以小時為單位）const timezoneOffset = -new Date().getTimezoneOffset() / 60; // 根據時差生成對應的 GMT 字串const gmtString = `GMT ${timezoneOffset &gt;= 0 ? &quot;+&quot; : &quot;&quot;}${timezoneOffset}`;console.log(gmtString); // GMT +8 動手做做看 計算日期差利用 Date 的時間戳，計算兩個日期的差值 javascript1234567const date1 = new Date(&quot;2025-01-01&quot;);const date2 = new Date(&quot;2025-01-15&quot;);const diffInMilliseconds = date2 - date1;const diffInDays = diffInMilliseconds / (1000 * 60 * 60 * 24);console.log(`日期相差 ${diffInDays} 天`); // 日期相差 14 天 動手做做看 延伸閱讀 【wikipedia】UNIX 時間 【MDN】Date() 介紹","link":"/Other/Tool/Unix-imestamp-Conversion/"},{"title":"【Git】使用 git rebase 整理提交歷史","text":"本篇重點 如果有尚未提交的變更，無法使用 git rebase git rebase 合併不會產生額外的合併提交，但是會變更原本的提交 ID git rebase -i（互動式 rebase）編輯功能 使用 git rebase -i 調整提交順序、修改提交訊息、修改提交內容、合併提交、刪除提交 git rebase 的注意事項 動手做做看 我建了一個範例 repository，可以 clone 下來後跟著文章操作！git clone https://github.com/forgetfulengineer/git-rebase-example.git Git 拒絕執行 rebase使用 git rebase 的前提是工作區（working directory）必須是乾淨的，也就是不能有尚未提交的變更，否則 Git 會拒絕執行 rebase，並顯示錯誤訊息 git error12Cannot rebase: You have unstaged changes.Please commit or stash them. 因為 git rebase 會重寫提交歷史，而未提交的變更可能會導致衝突或遺失，因此 Git 會強制要求先處理這些變更。 解決方法1. 使用 git stash 暫存變更如果目前的變更還不想提交，可以使用 git stash 暫存起來，執行 rebase 後再取回，適合暫時性變更，不影響提交歷史 git12345678# 暫存變更git stash# 進行 rebasegit rebase ...# 取回變更git stash pop 2. 使用 git rebase --autostash（自動暫存變更）可以使用 --autostash 讓 Git 在 rebase 前自動暫存變更，完成後再自動取回，適合經常遇到這個問題的人，減少手動 stash 的步驟 git1git rebase --autostash ... 3. 先提交變更暫時提交變更，執行 rebase 後再撤銷提交，適合暫時性變更，不影響提交歷史 git123git add .git commit -m &quot;暫存變更以執行 rebase&quot;git rebase ... 如果不想保留暫存提交，可以在 rebase 後使用 git reset HEAD~1 撤銷提交，讓變更回到工作區 git1git reset HEAD~1 git rebase 的基本功能將當前分支的提交銜接到另一個分支的最新進度上，與 git merge 不同，git rebase 不會產生額外的合併提交（merge commit），讓提交歷史保持乾淨且條理。 健忘筆記 如果兩分支變更的檔案有衝突，沒辦法 Fast-forward 合併，就需要重新調整提交內容 範例當前 main 分支最新進度開發到 C 節點，但 dev 分支是從 main 分支 B 節點開始開發，因此出現分支衝突的狀況。 git tree123A --- B --- C (main) \\ D (dev) 使用 git rebase 合併 main 分支進度，將 dev 分支的提交銜接到 main 的最新進度上 git12git checkout devgit rebase main git tree12# D 的提交 ID 會和原本不一樣A --- B --- C --- D' (dev) 這樣可以確保 dev 基於 main 的最新進度，並且提交記錄保持清晰，不產生額外的合併提交。 健忘筆記 git rebase 合併分支，銜接到最新進度的提交（commit），提交 ID 會和原本不一樣 git rebase -i（互動式 rebase）git rebase -i 用於編輯提交歷史，可以整理提交順序、修改提交內容或合併提交等，-i 是 interactive 的意思。 git1234567891011# 對最近的 N 次提交執行 rebase (N 替換成數字)git rebase -i HEAD~[N]# 對最近的 3 次提交執行 rebasegit rebase -i HEAD~3# 對 commit id 之後的提交執行 rebasegit rebase -i [commit id]# 對 a1b2c3d 之後的提交執行 rebasegit rebase -i a1b2c3d 互動式 rebase 編輯介面執行 git rebase -i [指定提交] 後會進入編輯介面，上到下以最舊到最新列出提交資訊，並且每個提交的前面會顯示操作指令 git rebae -i123pick a1b2c3d 初始提交pick d4e5f6g 修正錯誤pick h7i8j9k 增加新功能 git rebae -i1234# 設定操作方式可以直接使用縮寫指令也可以使用完整指令r a1b2c3d 初始提交reword d4e5f6g 修正錯誤d h7i8j9k 增加新功能 這些是我覺得比較重要的選項： 選項 功能描述 p（pick） 保留提交 r（reword） 修改提交訊息 e（edit） 修改提交內容 s（squash） 與前一個提交合併，並且設定提交訊息 f（fixup） 與前一個提交合併，並且直接使用前一個提交的提交訊息 d（drop） 刪除提交 完整操作指令說明可以在編輯介面查看 git rebae -i123456789101112131415161718# Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous# commit's log message, unless -C is used, in which case# keep only this commit's message; -c is same as -C but# opens the editor# x, exec &lt;command&gt; = run command (the rest of the line) using shell# b, break = stop here (continue rebase later with 'git rebase --continue')# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# . create a merge commit using the original merge commit's# . message (or the oneline, if no original merge commit was# . specified); use -c &lt;commit&gt; to reword the commit message 調整提交順序如果提交的順序不符合邏輯，或希望讓提交記錄更清晰，可以調整提交的順序。 範例git rebae -i1234pick a1b2c3d test4pick d4e5f6g test2pick h7i8j9k test1pick y3i1j7r test3 重新調整提交歷史的順序，讓提交是 test1 到 test4 git rebae -i1234pick h7i8j9k test1pick d4e5f6g test2pick y3i1j7r test3pick a1b2c3d test4 調整完成後儲存，Git 就會按照新的順序排列。 健忘筆記 我的編輯介面是使用 vim 做編輯器，所以直接使用 :x（:x 等於 :wq）即可儲存後退出 git rebase -i，如果想把編輯器設定成 vim，可以參考 【Git】了解 git config 設定 修改提交訊息如果某次提交的訊息不夠清楚或有錯誤，可以使用 r, reword 來修改提交訊息。 範例git rebae -i1234pick h7i8j9k test1pick d4e5f6g test2pick y3i1j7r test3r a1b2c3d test4 儲存後，Git 會提示你輸入新的提交訊息 reword12# test4 -&gt; test4 &amp; test5test4 &amp; test5 修改完成後儲存，就會更新成新的提交訊息 git12345$ git logh7i8j9k test1d4e5f6g test2y3i1j7r test3a1b413d test4 &amp; test *補充：也可以一次修改多個提交訊息 git rebae -i1234r h7i8j9k test1r d4e5f6g test2pick y3i1j7r test3r a1b2c3d test4 健忘筆記 如果只是要修改當前最新的提交訊息，可以使用 git commit --amend -m &quot;提交訊息&quot; 做調整，詳細可以參考 【Git】使用 git commit 修改提交（commit）的資訊或是內容 修改提交內容如果某個提交有錯誤，或想要補充內容，或是想修改提交的資訊（作者、信箱等），可以使用 e, edit 來修改提交內容。 git rebae -i1234pick h7i8j9k test1e d4e5f6g test2pick y3i1j7r test3pick a1b2c3d test4 儲存後，Git 會暫停在該提交，即可對該提交進行修改 edit1234567891011121314# 修改檔案vim example.txt# 加入修改內容git add example.txt# 重新提交（覆蓋最新一次提交）git commit --amend --no-edit# 修改最新一次提交的作者名稱和信箱git commit --amend --author=&quot;forgetfulengineer &lt;thatforgetfulengineer@gmail.com&gt;&quot;# 繼續 rebasegit rebase --continue *補充：也可以一次修改多個提交 git rebae -i1234pick h7i8j9k test1e d4e5f6g test2e y3i1j7r test3e a1b2c3d test4 健忘筆記 如果只是要修改當前最新的提交資訊，可以使用 git commit --amend 做調整，詳細可以參考 【Git】使用 git commit 修改提交（commit）的資訊或是內容 合併提交如果多個提交的內容屬於同一個邏輯並且想整理成一個提交，可以使用 s, squash 或是 f, fixup 來合併提交，使歷史記錄更加簡潔。 git rebae -i1234pick h7i8j9k test1s d4e5f6g test2pick y3i1j7r test3f a1b2c3d test4 儲存後，Git 會讓你選擇合併後的提交訊息，或是自行修改 squash12# 設定合併後的提交訊息add test1 &amp; test2 git123$ git logh7i8j7k add test1 &amp; test2d4e2f6g test3 完成後，提交將合併成一個 健忘筆記 s, squash 與前一個提交合併，並且設定提交訊息f, fixup 與前一個提交合併，並且直接使用前一個提交的提交訊息 刪除提交如果提交已經不需要或是有錯誤，可以使用 d, drop 來刪除 git rebae -i1234pick h7i8j9k test1pick d4e5f6g test2d y3i1j7r test3pick a1b2c3d test4 儲存後，Git 會該提交從歷史中刪除 git1234$ git logpick h7i8j9k test1pick d4e5f6g test2pick a1b2c3d test4 結論git rebase -i 提供了很多功能整理歷史提交，讓紀錄更清晰、整潔，這邊整理我常使用到的功能： 調整提交順序 修改提交訊息（r, reword） 修改提交內容（e, edit） 合併提交（s, squash 或 f, fixup） 刪除提交（d, drop） 雖然 git rebase 很好用，但使用時有一些需要注意的地方： 工作區不能有尚未提交的變更，否則 Git 會拒絕執行 rebase git rebase 的操作可能會改變歷史提交的提交 ID，導致發生分支衝突 多人開發時，要避免直接在公共分支使用 git rebase，可能導致和其他人分支衝突 熟悉需要注意的地方後，善用 git rebase 就可以讓 Git 提交歷史更整潔，提升專案的可讀性與維護性！ 動手做做看 我建了一個範例 repository，可以 clone 下來後跟著文章操作！git clone https://github.com/forgetfulengineer/git-rebase-example.git 延伸閱讀 【Git 官方文件】git rebase 介紹 【為你自己學 Git】合併發生衝突了，怎麼辦？ 【Git 官方文件】git stash 介紹 【Git 官方文件】git reset 介紹","link":"/Other/Git/Using-Git-Rebase-to-Organize-Commit-History/"},{"title":"【PHP】五種實用的日期時間函數","text":"本篇重點 time() 取得當前時間戳記 date() 格式化時間 strtotime() 將字串轉換為時間戳記 mktime() 建立時間戳記 checkdate() 驗證日期是否有效 如果想把日期時間換成時間戳或是時間戳換成日期時間，歡迎使用本站的 timestamp 轉換工具 time() - 取得當前時間戳記回傳從 Unix 紀元（1970-01-01 00:00:00 UTC）至今的秒數。 範例： php123// 輸出當前的 Unix 時間戳記$timestamp = time();echo &quot;目前的 Unix 時間戳記：&quot; . $timestamp; 動手做做看 time() - 取得當前時間戳記 回傳從 Unix 紀元（1970-01-01 00:00:00 UTC）至今的秒數。 動手做做看 date() - 格式化時間可用來格式化時間戳記，讓時間以可讀的方式顯示。 實例搶先看 date() - 格式化時間 可用來格式化時間戳記，讓時間以可讀的方式顯示。 實例搶先看 php12// 預設為輸出當下的格式化時間，可指定需格式化的時間點date(string $format, int $timestamp = time()) 常用格式： 格式 說明 範例 Y 完整四位數西元年份，使用 - 表示公元前 2025、-0055、0787 m 兩位數月份，沒有十位數會補零 02、07、12 d 兩位數日期，沒有十位數會補零 14、25、06 H 24 小時制兩位數小時，沒有十位數會補零 00 到 23 i 分鐘，沒有十位數會補零 00 到 59 s 秒，沒有十位數會補零 00 到 59 w 星期幾，數字表示 0（表示星期天） 到 6（表示星期六） 健忘筆記 PHP 的 date('w') 取得星期幾是從 0 到 6 進行編號，0 表示 星期日、1 表示 星期一以此類推。 *JavaScript 的 .getDay() 也是如此，想了解 .getDay() 可以查看 【Tool】Unix 時間戳（Unix timestamp） 轉換 範例：php123456// 以 YYYY-MM-DD HH:MM:SS 格式輸出當下時間echo date('Y-m-d H:i:s');// 以 YYYY/MM/DD HH:MM:SS 格式輸出時間戳 1739690772echo date('Y/m/d H:i:s', 1739690772);// 2025/02/16 15:26:12 查看所有格式設定 動手做做看 動手做做看 strtotime() - 將字串轉換為時間戳記將各種時間字串（如 yesterday、+1 week）轉換為 Unix 時間戳。 健忘筆記 如果執行日期運算的環境沒有設定自己的時區或是想指定時區，可以使用 date_default_timezone_set() 調整。 實例搶先看 strtotime() - 將字串轉換為時間戳記 1. 將各種時間字串（如 yesterday、+1 week）轉換為 Unix 時間戳 2. 如果執行日期運算的環境沒有設定自己的時區或是想指定時區，可以使用 date_default_timezone_set() 調整。 3. 具體的日期時間取得時間戳不受 strtotime() 的第二個參數 $baseTimestamp 影響 4. 相對時間的時間字串會受 strtotime() 的第二個參數 $baseTimestamp 影響 實例搶先看 php12// 預設基礎時間點為當下的時間戳，可指定基礎時間點strtotime(string $datetime, int $baseTimestamp = time()) 常見日期時間字串應用：絕對時間（Absolute Dates）具體的日期時間，這個類型的關鍵字會忽略 strtotime() 的第二個參數 $baseTimestamp 時間字串 解析時間（假設今天是 2025-02-14） 2025-01-01 2025-01-01 00:00:00 2025-04-31 08:11 2025-04-31 08:11:00 2025-12-06 noon 2025-12-06 12:00:00 範例： php1234567891011// 取得 2025-01-01 的時間戳echo strtotime('2025-01-01');// 1735660800 - 2025-01-01 00:00:00// 取得 2025-04-31 08:11 的時間戳echo strtotime('2025-04-31 08:11');// 1746058260 - 2025-05-01 08:11:00// 取得 2025-12-06 12:00:00 的時間戳 (不受 1740047219 影響)echo strtotime('2025-12-06 noon', 1740047219);// 1764993600 - 2025-12-06 12:00:00 健忘筆記 具體的日期時間取得時間戳不受 strtotime() 的第二個參數 $baseTimestamp 影響 相對時間（Relative Dates）基於 $baseTimestamp 進行計算，預設為當下的時間（time()） 時間字串 解析時間（假設現在是 2025-02-14 15:30:45） +1 day 2025-02-15 15:30:45 -1 day 2025-02-13 15:30:45 +2 weeks 2025-02-28 15:30:45 -3 months 2024-11-14 15:30:45 +5 years 2030-02-14 15:30:45 today 2025-02-14 00:00:00 yesterday 2025-02-13 00:00:00 tomorrow 2025-02-15 00:00:00 now 2025-02-14 15:30:45 midnight 2025-02-14 00:00:00 noon 2025-02-14 12:00:00 範例： php123456789101112131415161718192021// 假設現在是 2025-02-21 17:54:45// 取得當下時間兩年後前一天的時間戳echo strtotime('+2 years -1 day');// 1803117258 - 2027-02-20 17:54:18// 取得明天的 00:00:00 的時間戳echo strtotime('tomorrow');// 1740153600 - 2025-02-22 00:00:00// 以 1740047219 (2025/02/20 18:26:59) 時間戳為基準點，取得兩年又兩星期後的時間戳echo strtotime('+2 weeks +1 years', 1740047219);// 1772792819 - 2026-03-06 18:26:59// 以 1737368819 (2025/01/20 18:26:59) 時間戳為基準點，取得四天後正中午的時間戳echo strtotime('+4 days noon', 1737368819);// 1737691200 - 2025-01-24 12:00:00// 以 1739960316 (2025/02/19 18:18:36) 時間戳為基準點，取得當天 00:00:00 的時間戳echo strtotime('today', 1739960316)// 1739894400 - 2025-02-19 00:00:00 健忘筆記 相對時間的時間字串會受 strtotime() 的第二個參數 $baseTimestamp 影響 查看所有可解析的日期時間字串 動手做做看 動手做做看 mktime() - 建立時間戳記建立特定時間的 Unix 時間戳。 健忘筆記 如果執行日期運算的環境沒有設定自己的時區或是想指定時區，可以使用 date_default_timezone_set() 調整。 php1mktime(int $hour, int $minute, int $second, int $month, int $day, int $year) 範例： php123456789// 取得 2025-02-14 00:00:00 的時間戳echo mktime(0, 0, 0, 2, 14, 2025);// 1739462400// 取得當前日期 20 天後 12:00:00 的時間戳echo mktime(12, 0, 0, date('m'), date('d') + 20, date('Y'));// 取得當前日期 3 個月前 14:03:00 的時間戳echo mktime(14, 3, 0, date('m') - 3, date('d'), date('Y')); mktime() - 建立時間戳記 建立特定時間的 Unix 時間戳。 動手做做看 動手做做看 checkdate() - 驗證日期是否有效檢查一個日期是否有效，回傳布林值（boolean）。 php123456789101112131415// 2024-02-29 是否為有效日期var_dump(checkdate(2, 29, 2024));// true，閏年 2024，2 月有 29 天// 2024-02-30 是否為有效日期var_dump(checkdate(2, 30, 2024));// false，2 月最多 29 天// 2023-04-31 是否為有效日期var_dump(checkdate(4, 31, 2023));// false，4 月只有 30 天// 2023-12-25 是否為有效日期var_dump(checkdate(12, 25, 2023));// true checkdate() - 驗證日期是否有效 檢查一個日期是否有效，回傳布林值（boolean）。 動手做做看 動手做做看 結論這邊整理了我常用的的日期時間函數，後端記錄資料的時候很常需要日期時間、timestamp 的轉換，或是執行排程可能也會需要計算時間來撈取資料等。 time() - 取得當前時間戳記 date() - 格式化時間 strtotime() - 將字串轉換為時間戳記 mktime() - 建立時間戳記 checkdate() - 驗證日期是否有效 平常也會使用日期時間函數嗎？有甚麼更方便的函數嗎？歡迎留言跟大家分享！ 如果想把日期時間換成時間戳或是時間戳換成日期時間，歡迎使用本站的 timestamp 轉換工具 延伸閱讀 【PHP官方文件】日期時間格式介紹 【PHP官方文件】可解析的日期時間字串 【PHP官方文件】Date/Time 函数介紹","link":"/Backend/PHP/Five-Useful-Date-and-Time-Functions/"},{"title":"【Html】自定義屬性：data-* 的命名規則和取值方法","text":"本篇重點 屬性必須以 data- 為前綴 建議使用 kebab-case 命名 data-* 的常見應用時機 JavaScript 使用 dataset. 取值 jQuery 使用 .data() 或是 .attr() 取值 HTML5 引入了 data-* 屬性，讓開發者可以在標籤上自訂屬性，儲存額外的資訊，並能夠被 JavaScript 獲取與操作。 命名規則html1&lt;div id=&quot;example&quot; data-user-id=&quot;12345&quot; data-role=&quot;admin&quot; data-info='{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}'&gt;&lt;/div&gt; 必須以 data- 為前綴 data- 是固定的屬性前綴，用於告訴瀏覽器這是一個自定義數據屬性。 後續名稱只能包含 小寫字母（a-z） 數字（0-9） 中橫線（-） 建議使用「kebab-case（短橫線命名法）」，例如 data-user-id，避免使用 data_user_id 或 dataUserId，這可能會影響取值的操作 data-* 屬性值可以是 字串 數字 JSON 格式 常見應用時機 前端與後端溝通的小型數據 html1&lt;li data-product-id=&quot;101&quot; data-price=&quot;25.99&quot;&gt;商品名稱&lt;/li&gt; 控制前端行為 html1&lt;button data-toggle=&quot;modal&quot;&gt;開啟模態窗&lt;/button&gt; 統計與分析 html1&lt;a href=&quot;example.html&quot; data-track=&quot;nav-link&quot;&gt;點擊我&lt;/a&gt; 讀取 data-* 屬性的方法Javascript使用 dataset 物件讀取 data-* 屬性： dataset 會將 data-* 的 kebab-case 轉換為 camelCase（駝峰式命名法），例如 data-user-id 使用 dataset.userId 讀取 如果屬性名稱包含大寫（不建議這樣做），JavaScript 仍然會轉為小寫處理。例如 data-User-Name 使用 dataset.userName 讀取 實例搶先看 Javascript 讀取 data 屬性的方法 dataset 會將 data-* 的 kebab-case 轉換為 camelCase（駝峰式命名法），例如 data-user-id 變成 dataset.userId 如果屬性名稱包含大寫（不建議這樣做），JavaScript 仍然會轉為小寫處理。例如 data-User-Name 使用 dataset.userName 讀取 html12345678&lt;div id=&quot;example&quot; data-user-id=&quot;12345&quot; data-User-Name=&quot;Alice&quot; data-role=&quot;admin&quot; data-info='{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}'&gt;&lt;/div&gt;&lt;p id=&quot;output&quot;&gt;&lt;/p&gt; js123456789101112131415const div = document.getElementById(&quot;example&quot;);const output = document.getElementById(&quot;output&quot;);// 取得 data-* 屬性值const userId = div.dataset.userId;const userName = div.dataset.userName;const role = div.dataset.role;const info = JSON.parse(div.dataset.info); // 解析 JSON 字串output.innerHTML = ` 使用者 ID: ${userId} &lt;br&gt; 使用者名稱: ${userName} &lt;br&gt; 角色: ${role} &lt;br&gt; 額外資訊: 名字 - ${info.name}, 年齡 - ${info.age}`; 健忘筆記 駝峰式命名（Camel case）是一種將單字相連的命名方式，並根據開頭字母的大小寫進一步細分為兩種類型。小駝峰命名（lower camel case）的開頭字母為小寫，例如 userId，而大駝峰命名（upper camel case）的開頭字母則為大寫，例如 UserId。 烤肉串命名（Kebab case）是一種使用 - 來分隔單字的命名方式，例如：user-id。這種命名方式常見於網頁開發中，特別是在 CSS 類別名稱與部分 URL 結構中。 JQuery可以使用 .data() 或是 attr() 存取 data-* 屬性： 使用 .data() 讀取 data-*，無論屬性名稱使用 kebab-case 或 camelCase，都能正確獲取對應的值 如果 data-* 的值是有效的 JSON，且在 HTML 載入時已經存在，.data() 會自動將其解析為 JavaScript 物件 實例搶先看 JQuery 讀取 data 屬性的方法 使用 .data() 讀取 data-*，無論屬性名稱使用 kebab-case 或 camelCase，都能正確獲取對應的值 如果 data-* 的值是有效的 JSON，且在 HTML 載入時已經存在，.data() 會自動將其解析為 JavaScript 物件 html123456789&lt;div id=&quot;example&quot; data-user-id=&quot;12345&quot; data-User-Name=&quot;Alice&quot; data-role=&quot;admin&quot; data-info='{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}'&gt;&lt;/div&gt;&lt;p id=&quot;output&quot;&gt;&lt;/p&gt; js1234567891011121314151617const div = $(&quot;#example&quot;);const output = $(&quot;#output&quot;);// 取得 data-* 屬性值const userId = div.data('user-id'); // kebab-case 也可讀取const userId2 = div.data('userId');const userName = div.data('userName');const role = div.attr('data-role');const info = div.data('info');$(&quot;#output&quot;).html(` 使用者 ID: ${userId} &lt;br&gt; 使用者 ID 2: ${userId2} &lt;br&gt; 使用者名稱: ${userName} &lt;br&gt; 角色: ${role} &lt;br&gt; 額外資訊: 名字 - ${info.name}, 年齡 - ${info.age}`); 結論HTML 的 data-* 屬性是一種靈活且易用的方式，用於存儲自定義數據，方便前端操作，但有幾個需要注意的地方： 避免存放敏感信息data-* 屬性數據是公開的，任何人都可以通過檢視原始碼或瀏覽器開發工具查看，避免存放密碼、API 金鑰等敏感資訊。 適度使用data-* 屬性適合存放小型且靜態的數據。如果數據過於龐大或動態，建議改用其他方式，例如 API 或 JavaScript 物件。 了解後能夠大幅提升程式碼的可讀性與維護性！ 延伸閱讀 【MDN】data-* 介紹 【MDN】dataset 介紹 【jQuery 官方文件】.data() 介紹 【Camel ‘s blog】常見的命名規則","link":"/Frontend/Html/Data-Attribute-Naming-Conventions-and-Retrieval-Methods/"},{"title":"【MySQL】DQL 指令的執行順序與效能優化","text":"本篇重點 了解 DQL 指令的執行順序，從 FROM 到 LIMIT/OFFSET 每個步驟會產生一張虛擬表供下一步驟使用，透過執行順序，可以減少不必要的資料處理，提升查詢效能 各個 DQL 指令的使用重點 在 MySQL 查詢語言（DQL，Data Query Language）中，每條 SELECT 查詢語句包含多個不同的指令。了解執行順序，能幫助理解查詢如何處理，並且優化 SQL 查詢，減少不必要的篩選與計算，提高效能。 想了解其他資料庫語言類型，可以參考 【MySQL】解析資料庫語言類型 DDL、DML、DCL、DQL DQL 指令的執行順序雖然撰寫 SQL 語句時通常按照 SELECT … FROM … WHERE … GROUP BY … HAVING … ORDER BY … LIMIT … 的順序，但實際上 MySQL 的執行順序是不同的，主要執行順序如下： FROM → JOIN … ON → WHERE → GROUP BY → AGG_FUNC → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT/OFFSET 每執行一個步驟都會產生一張虛擬表給下一個步驟使用，但實際上虛擬表是看不到的，只能看到最終的搜尋結果。 範例資料mysql1234567891011121314151617181920212223242526-- 創建資料表CREATE TABLE users (uid INT AUTO_INCREMENT PRIMARY KEY,name VARCHAR(50),age VARCHAR(50),team VARCHAR(50),email VARCHAR(100));CREATE TABLE orders (order_id INT AUTO_INCREMENT PRIMARY KEY,uid INT,commodity_id INT,price INT);-- 新增資料INSERT INTO users (name, age, team, email) VALUES ('John', 17, 'a', 'john@example.com');INSERT INTO users (name, age, team, email) VALUES ('tom', 22, 'b', 'tom@example.com');INSERT INTO users (name, age, team, email) VALUES ('cindy', 35, 'a', 'cindy@example.com');INSERT INTO users (name, age, team, email) VALUES ('tom', 30, 'a', 'tom2@example.com');INSERT INTO orders (uid, commodity_id, price) VALUES (2, 5, 50);INSERT INTO orders (uid, commodity_id, price) VALUES (2, 8, 30);INSERT INTO orders (uid, commodity_id, price) VALUES (3, 1, 100);INSERT INTO orders (uid, commodity_id, price) VALUES (4, 16, 50); (1) FROMmysql1SELECT [欄位名稱] FROM [表格名稱]; 來源資料表的讀取 範例： mysql123SELECT * FROM users;SELECT * FROM orders; (1) FROM 來源資料表的讀取 動手做做看 動手做做看 (2) JOIN … ONmysql12SELECT [欄位名稱] FROM [表格1]JOIN [表格2] ON [表格1].[欄位] = [表格2].[欄位]; 當有 JOIN 操作時，MySQL 會先依據 ON 條件來篩選需要 JOIN 的資料，這有助於減少不必要的數據傳輸，提升查詢效能 JOIN … ON 比 WHERE 更早執行，因此 ON 條件能過濾掉不必要的資料，提高效能 JOIN 還有分 LEFT JOIN、RIGHT JOIN，可以參考 【w3schools】SQL Joins 範例： mysql123SELECT u.uid, u.name, o.order_id, o.commodity_id, o.priceFROM users uJOIN orders o ON u.uid = o.uid AND o.price &gt;= 50; -- 在 JOIN 的時候先做篩選 (2) JOIN … ON 當有 JOIN 操作時，MySQL 會先依據 ON 條件來篩選需要 JOIN 的資料，這有助於減少不必要的數據傳輸，提升查詢效能 這比 WHERE 更早執行，因此 ON 條件能過濾掉不必要的資料，提高效能 動手做做看 動手做做看 (3) WHEREmysql1SELECT [欄位名稱] FROM [表格名稱] WHERE [篩選條件]; 在 FROM 抓取完表之後，會根據 WHERE 條件來篩選符合條件的資料 WHERE 會在 GROUP BY 之前執行，因此 WHERE 不能對聚合函數 (SUM、COUNT) 進行篩選 範例： mysql12345678910SELECT u.uid, u.name, o.order_id, o.commodity_id, o.priceFROM users uJOIN orders o ON u.uid = o.uidWHERE u.uid = 2;-- 因為 JOIN … ON 比 WHERE 更早執行，所以執行 WHERE u.uid = 2 的時候，已經只剩 price &gt;= 50 的資料SELECT u.uid, u.name, o.order_id, o.commodity_id, o.priceFROM users uJOIN orders o ON u.uid = o.uid AND o.price &gt;= 50WHERE u.uid = 2; (3) WHERE 在 FROM 抓取完表之後，會根據 WHERE 條件來篩選符合條件的資料 WHERE 會在 GROUP BY 之前執行，因此 WHERE 不能對聚合函數 (SUM、COUNT) 進行篩選 動手做做看 動手做做看 (4) GROUP BYmysql12SELECT [分組欄位], [聚合函數] FROM [表格名稱]GROUP BY [分組欄位]; 將符合 WHERE 條件的資料分組 GROUP BY 後只能 SELECT 分組的欄位或聚合函數 (如 SUM、COUNT、AVG)，如果 SELECT 分組以外的欄位會是同一分組中任意一行的值，因此可能會與預期結果不符 範例： 實例搶先看 mysql123456789SELECT teamFROM usersGROUP BY team;-- 因為 WHERE 比 GROUP BY 更早執行，所以執行 GROUP BY team 的時候，已經只剩 age &gt;= 30 的資料SELECT teamFROM usersWHERE age &gt;= 30GROUP BY team; 在查詢每個群組中的最新或特定條件的資料時，可以使用 GROUP BY 搭配聚合函數來篩選出所需的關鍵值（例如最新的 ID 或日期），再透過 JOIN 將篩選出的關鍵值與原表進行關聯，確保獲取完整的詳細資訊。這種方式適用於各種情境，例如查詢每位使用者的最新留言、每個產品的最高價格紀錄、每個客戶的最近一次購買紀錄等。 範例： 查詢每個 uid 的最新訂單可以使用 GROUP BY 搭配 MAX() 先找出 orders 表中每個 uid 最新的 order_id（假設 order_id 越大代表越新） 然後 JOIN 回 orders 表，獲取完整的訂單資訊 mysql12345678SELECT o.*FROM orders oJOIN ( SELECT uid, MAX(order_id) AS latest_order FROM orders GROUP BY uid) latest_ordersON o.uid = latest_orders.uid AND o.order_id = latest_orders.latest_order; (4) GROUP BY 將符合 WHERE 條件的資料分組 GROUP BY 後只能 SELECT 分組的欄位或聚合函數 (如 SUM、COUNT、AVG)，如果 SELECT 分組以外的欄位會是同一分組中任意一行的值，因此可能會與預期結果不符 動手做做看 動手做做看 (5) AGG_FUNCmysql12SELECT [分組欄位], [聚合函數]([欄位]) FROM [表格名稱]GROUP BY [分組欄位]; 聚合函數計算（如 SUM、AVG、COUNT） 搭配 GROUP BY 可針對每組資料進行聚合計算 如果沒有 GROUP BY，是將整張資料表當作一組來計算 可使用 AS 為結果欄位命名，增加可讀性 範例： mysql1234567891011121314SELECT team, COUNT(*) AS team_count, AVG(age) AS age_avgFROM usersGROUP BY team;-- 因為 WHERE 比 GROUP BY 更早執行，所以執行 GROUP BY team 的時候，已經只剩 age &gt;= 30 的資料SELECT team, COUNT(*) AS team_count, AVG(age) AS age_avgFROM usersWHERE age &gt;= 30GROUP BY team;-- age &gt;= 30 的使用者總數SELECT COUNT(*) AS user_countFROM usersWHERE age &gt;= 30; (5) AGG_FUNC 聚合函數計算（如 SUM、AVG、COUNT） GROUP BY 分組後，才能使用聚合函數 可以使用 AS 將欄位重新命名 動手做做看 動手做做看 (6) HAVINGmysql123SELECT [分組欄位], [聚合函數]([欄位]) FROM [表格名稱]GROUP BY [分組欄位]HAVING [條件]; 針對聚合函數的結果篩選 範例： mysql12345-- 針對聚合函數的結果篩選 team_count &gt; 1 的資料SELECT team, COUNT(*) AS team_countFROM usersGROUP BY teamHAVING team_count &gt; 1; (6) HAVING 針對聚合函數的結果篩選 動手做做看 動手做做看 (7) SELECTmysql1SELECT [欄位名稱] FROM [表格名稱]; 選擇要顯示的欄位（* 為選擇所有欄位） 所有條件已經套用，查詢結果已經確定 範例： mysql123456789101112131415SELECT * FROM users;SELECT * FROM orders;SELECT u.uid, u.name, o.order_id, o.commodity_id, o.priceFROM users uJOIN orders o ON u.uid = o.uid AND o.price &gt;= 50;SELECT u.uid, u.name, o.order_id, o.commodity_id, o.priceFROM users uJOIN orders o ON u.uid = o.uidWHERE u.uid = 2;SELECT team, COUNT(*) AS team_count, AVG(age) AS age_avgFROM usersGROUP BY team; (7) SELECT 選擇要顯示的欄位（* 為選擇所有欄位） 所有條件已經套用，查詢結果已經確定 動手做做看 動手做做看 (8) DISTINCTmysql1SELECT DISTINCT [欄位名稱] FROM [表格名稱]; 和 SELECT 搭配使用，在 SELECT 完成後過濾掉重複的資料 DISTINCT 是對整個查詢結果去除重複資料 DISTINCT 用於多個欄位是根據這些欄位的組合值來判斷是否重複，不是單獨判斷某一欄位 範例： mysql123456SELECT DISTINCT uid FROM orders;SELECT DISTINCT name FROM users;-- 根據多欄位去除重複項SELECT DISTINCT name, age, email FROM users; (8) DISTINCT 和 SELECT 搭配使用，在 SELECT 完成後過濾掉重複的資料 DISTINCT 用於多個欄位是根據這些欄位的組合值來判斷是否重複，不是單獨判斷某一欄位 DISTINCT 是對整個查詢結果去除重複資料 動手做做看 動手做做看 (9) ORDER BYmysql12SELECT [欄位名稱] FROM [表格名稱]ORDER BY [欄位名稱] [ASC|DESC]; 在 SELECT 完成後，結果會按照 ORDER BY 進行排序 未指定排序，預設為 ASC 升冪，順序由小排到大，使用 DESC 為降冪，順序由大排到小 排序可能會影響效能，特別是在大量數據時，要確保排序欄位有索引 範例： mysql12345SELECT * FROM orders ORDER BY price;SELECT * FROM users ORDER BY team ASC;SELECT * FROM users ORDER BY age DESC; (9) ORDER BY 在 SELECT 完成後，結果會按照 ORDER BY 進行排序 未指定排序，預設為升冪 ASC，順序由小排到大，使用 DESC 為降冪，順序由大排到小 排序可能會影響效能，特別是在大量數據時，要確保排序欄位有索引 動手做做看 動手做做看 (10) LIMIT / OFFSETmysql12SELECT [欄位名稱] FROM [表格名稱]LIMIT [筆數] OFFSET [跳過筆數]; 取出特定範圍的資料 LIMIT 用於限制返回的筆數，如果 LIMIT 使用兩個參數，第一個參數為資料跳過的筆數，第二個參數為跳過後選取的筆數 OFFSET 用於跳過前幾筆資料，不能單獨使用，必須與 LIMIT 搭配使用 健忘筆記 LIMIT 使用兩個參數，例如 LIMIT 20, 10，解讀為跳過 20 筆記錄後，再取 10 筆記錄 範例： mysql123456SELECT * FROM users LIMIT 3;-- 以下兩個查詢的結果相同SELECT * FROM users LIMIT 1, 2;SELECT * FROM users LIMIT 2 OFFSET 1; (10) OFFSET / LIMIT 取出特定範圍的資料 LIMIT 用於限制返回的筆數，如果 LIMIT 使用兩個參數，第一個參數為資料跳過的筆數，第二個參數為跳過後選取的筆數 OFFSET 用於跳過前幾筆資料，不能單獨使用，必須與 LIMIT 搭配使用 動手做做看 動手做做看 提升查詢效能的方式建立適當的索引 WHERE、JOIN、ORDER BY 相關的欄位應建立索引，減少資料庫掃描時間。 例如： mysql12-- 對 users 表的 age 欄位建立索引CREATE INDEX idx_users_age ON users(age); 先篩選再分組 WHERE 會在 GROUP BY 之前執行，因此應確保 WHERE 先過濾掉不必要的數據，減少 GROUP BY 的負擔。 避免 SELECT *，只選取需要的欄位 只選擇必要的欄位可以減少 I/O 負擔，提高查詢效能。 結論了解 DQL 指令的執行順序能編寫更高效的 SQL 查詢。透過優化 WHERE 篩選順序、善用索引、避免 SELECT * 等方式，可以顯著提升查詢效能。","link":"/Backend/MySQL/DQL-Execution-Order/"},{"title":"【PHP、JavaScript】三種實用的符號運算子 ?:、??、??&#x3D;","text":"本篇重點 介紹 ?: 、??、??= 的使用方式 JavaScript 沒有 ?: 符號相鄰的簡化用法，但可以使用 || 來達到類似效果 PHP 和 JavaScript 判斷假值標準不完全相同 了解符號運算子的可使用版本 先了解這些會幫助你更快理解唷😁 【PHP】4種判斷變數或陣列是否存在的方法【PHP】解析邏輯運算子 and、or、&amp;&amp;、|| 之間的差異 在開發中，常常會遇到要檢查變數是否有值、是否被設定的情況。為了讓程式碼更簡潔，PHP 和 JavaScript 提供了三種「簡化條件運算子」： ?:（三元運算子） ??（Null 合併運算子） ??=（Null 合併賦值運算子） ?: 三元運算子PHP常見用法（PHP 4+）?: 是條件運算子（if...else...）的簡寫 php1條件式 ? 成立時的值 : 不成立時的值; 範例： 動手做做看 ?: 三元運算子 常見用法：使用 ?: 符號間隔達到 if-else 的效果 簡化用法：當「條件」與「成立時的值」相同時可省略重複語句 動手做做看 php1$age = isset($_POST['age']) &amp;&amp; intval($_POST['age']) &gt; 0 ? intval($_POST['age']) : 0; 如果使用者有傳入 age，且值大於 0，就使用該值 否則預設為 0 簡化用法（PHP 5.3+）當「條件」與「成立時的值」相同時可省略重複語句 php1條件式 ?: 不成立時的值; 範例： 動手做做看 動手做做看 php123456789// $nickname 未設定值$nickname = '';$name = $nickname ?: '訪客';echo $name; // 訪客// $nickname 有設定值$nickname = 'John';$name = $nickname ?: '訪客';echo $name; // John 如果 $nickname 的值存在，返回 $nickname 如果 $nickname 的值為假值（falsy，如空字串、0、null、false），返回後方的 '訪客' 等同於： php1$name = $nickname ? $nickname : '訪客' 判斷條件是否成立、是否為假值，可參考 【PHP】4種判斷變數或陣列是否存在的方法 判斷差異表 if ($x) 的那一行 JavaScript?: 是條件運算子（if...else...）的簡寫 js1條件式 ? 成立時的值 : 不成立時的值; 範例： js1234567let inputAge = null;let age = inputAge &gt; 0 ? inputAge : 0;console.log(age); // 0inputAge = 10;age = inputAge &gt; 0 ? inputAge : 0;console.log(age); // 10 如果使用者有傳入 age，且值大於 0，就使用該值 否則預設為 0 健忘筆記 JavaScript 沒有 ?: 符號相鄰的簡化用法，但可以使用 || 來達到類似效果 let nickname = inputNickname || '訪客'; 不過 JavaScript 假值的定義和 PHP 不完全相同，詳情可見【MDN】JavaScript 假值介紹 動手做做看 ?? Null 合併運算子PHP（ 7+）用來檢查變數是否「被設定」且「不為 null」，如果條件不符，則使用後方預設值，和 isset() 的判斷結果相同 php1$變數 ?? $預設值; 範例： 動手做做看 ?? Null 合併運算子 用來檢查變數是否有「設定」，且不是 null，和 isset() 的判斷結果相同 動手做做看 php12$user = $_GET['user_name'] ?? 'noName';echo $user; 如果 $_GET['user_name'] 存在且不為 null，就返回 $_GET['user_name'] 否則返回 'noName' 等同於： php1$user = isset($_GET['user']) ? $_GET['user'] : '預設使用者'; 判斷是否存在且不為 null，可參考 【PHP】4種判斷變數或陣列是否存在的方法 判斷差異表 isset($x) 的那一行 ?: 和 ?? 的差異比較?: 和 ?? 兩者都有檢查變數是否有值、是否被設定的功用，但判斷標準不完全相同 php12345678$value1 = 0 ?: 100; // 100 （因為 0 是假值）$value2 = 0 ?? 100; // 0 （因為 0 不是 null）$value1 = '' ?: 100; // 100 （因為 '' 是假值）$value2 = '' ?? 100; // '' （因為 '' 不是 null）$value1 = null ?: 100; // 100 （因為 null 是假值）$value2 = null ?? 100; // 100 （因為是 null） 動手做做看 ?: 和 ?? 的差異比較 ?: 和 ?? 兩者都有檢查變數是否有值、是否被設定的功用，但判斷標準不完全相同 動手做做看 JavaScript（ES2020+）用來檢查變數是否「被設定」且「不為 null 或 undefined」，如果條件不符，則使用後方預設值 js1$變數 ?? $預設值; 範例： js1234567let inputUserName = null;let user = inputUserName ?? &quot;noName&quot;;console.log(user); // noNameinputUserName = &quot;John&quot;;user = inputUserName ?? &quot;noName&quot;;console.log(user); // John 如果 inputUserName 存在且不為 null 或 undefined，就返回 inputUserName 否則返回 'noName' 動手做做看 ??= Null 合併賦值運算子PHP（7.4+）?? 的延伸寫法，如果變數未設定或為 null 自動賦予預設值，否則賦予原值 php1$變數 ??= $預設值; 範例： php12$_GET['user_name'] ??= 'noName';echo $_GET['user_name']; 如果 $_GET['user_name'] 未設定或為 null，就賦值為 'noName' 如果已經有設定值（例如 'John'），則不做任何改變 等同於： php123if (!isset($_GET['user_name'])) { $_GET['user_name'] = 'noName';} 動手做做看 ??= Null 合併賦值運算子 ?? 的進階寫法，若變數未設定或為 null，進行賦值，否則保留原本的值 動手做做看 JavaScript（ES2021+）?? 的延伸寫法，如果變數為 null 或 undefined 自動賦予預設值，否則賦予原值 js1$變數 ??= $預設值; 範例： js1234567let user_name = null;user_name ??= &quot;noName&quot;;console.log(user_name);user_name = &quot;John&quot;;user_name ??= &quot;noName&quot;;console.log(user_name); 如果 user_name 為 null 或 undefined，就賦值為 'noName' 如果已經有設定值（例如 'John'），則不做修改 動手做做看 結論在 PHP 和 JavaScript 中，可以使用 ?:、??、??= 提升程式的簡潔性和可讀性，適合應用在表單接收、API 處理等場景！ 延伸閱讀 【PHP 官方文件】三元運算子介紹 【PHP 官方文件】Null 合併運算子介紹 【MDN】JavaScript 三元運算子介紹 【MDN】JavaScript Null 合併運算子介紹 【MDN】JavaScript 假值介紹","link":"/Backend/PHP/Three-Useful-Symbol-Operators/"},{"title":"【HTML】解決 Lazy loading 導致滾動定位不準的問題","text":"本篇重點 解決 Lazy loading 導致 .scrollIntoView() 滾動定位不準的問題 檢查目標元素是否進入視窗的方式 .getBoundingClientRect()、window.innerHeight、.clientHeight 的應用 在開發「點擊回覆文章按鈕後自動滾動至留言區」的功能時，原本使用 .scrollIntoView({ behavior: 'smooth' }) 來實現平滑滾動的效果。但在實際測試時發現，滾動的位置沒有準確對齊留言區。檢查後發現，因為頁面中的圖片使用了 loading=&quot;lazy&quot; 機制，導致圖片尚未載入時不會佔據實際高度，進而影響瀏覽器對滾動位置的計算，造成滾動偏移的問題。 js1234$('#reply').click(function scrollToComment() { const commentSection = document.getElementById(&quot;comment&quot;); commentSection.scrollIntoView({ behavior: 'smooth' });}); 動手做做看 Lazy loading 導致滾動定位不準的問題 動手做做看 健忘筆記 以前都是使用套件來實現 Lazy loading 機制，現在 HTML 已經內建此機制，詳細可查看 【MDN】Lazy loading 介紹 解決方法檢查目標是否進入視窗在滾動後使用 setTimeout，並檢查目標元素是否進入視窗。如果未進入視窗範圍，則重新執行滾動，確保用戶能夠正確移動到留言區。 js123456789101112131415161718$('#reply').click(function scrollToComment() { const commentSection = document.getElementById(&quot;comment&quot;); commentSection.scrollIntoView({ behavior: 'smooth' }); setTimeout(() =&gt; { if (!isElementInViewport(commentSection)) { scrollToComment(); } }, 300);});function isElementInViewport(el) { const rect = el.getBoundingClientRect(); return ( rect.top &gt;= 0 &amp;&amp; rect.top &lt;= (window.innerHeight || document.documentElement.clientHeight) );} 初次滾動：scrollIntoView({ behavior: 'smooth' }) 觸發滾動效果。 延遲檢查：使用 setTimeout 延遲 300ms，讓瀏覽器有時間載入 Lazy Load 圖片並重新計算頁面高度。 可視範圍判斷：透過 isElementInViewport() 檢查 comment 是否確實進入視窗範圍。 二次滾動：如果 comment 仍未進入視窗，則再次執行 scrollToComment()，確保滾動到正確位置。 動手做做看 Lazy loading 導致滾動定位不準的問題 動手做做看 健忘筆記 .getBoundingClientRect()：取得某個元素相對於視窗的位置和元素大小（單位：px），可用來判斷元素是否出現在畫面中 top：元素頂部與視窗頂部的距離 bottom：元素底部與視窗頂部的距離 left / right：元素左右邊與視窗邊界的距離 width / height：元素的寬度與高度 window.innerHeight：取得目前瀏覽器「視窗可視區域」的高度（單位：像素 px），包括了內容區域 + 捲軸的高度（如果有捲軸），無論有沒有捲動網頁值都不會變 document.documentElement.clientHeight：取得目前瀏覽器「視窗可視區域」的高度（單位：像素 px），和 window.innerHeight 最大的差異是不包含捲軸的厚度及相容性較好 固定圖片的高度固定圖片的高度後，瀏覽器在計算滾動位置能提前保留圖片所佔的空間，避免圖片載入後高度變化影響整體排版和捲動位置，進而解決滑動定位不準確的問題。但這個方法也有問題存在，若網站中的圖片尺寸不一（例如橫圖、直圖混排），全部統一設定固定高度可能造成畫面留白、不均衡，影響整體版面；若在 RWD（響應式網頁設計）中，圖片的顯示尺寸通常會根據螢幕寬度自動調整，強制設定固定高度（例如 height: 300px），會讓圖片失去原有比例，產生壓縮或拉伸的問題。 結論我目前是用 setTimeout 搭配檢查目標元素是否進入視窗的方式，來解決 Lazy loading 導致滾動定位不準的問題。雖然這方法暫時能用，但感覺不是最佳解😅 如果有更聰明、簡單、穩定的解法，麻煩一定要留言分享給我！🙏🏻 延伸閱讀 【MDN】Lazy loading 介紹 【MDN】getBoundingClientRect() 介紹 【MDN】window.innerHeight 介紹 【MDN】.clientHeight 介紹","link":"/Frontend/Html/Fixing-Scroll-Effect-Misalignment-Caused-by-Lazy-Loading/"},{"title":"【jQuery】解析六種添加元素方法","text":"本篇重點 常見的添加元素方法 添加到指定元素內部：.append()、.prepend()、.appendTo()、.prependTo() 添加到指定元素外部：.after()、.before() 介紹各方法的使用效果及適用情境 開發網頁互動功能或動態內容時，動態新增 HTML 元素是常見的需求，例如：點擊按鈕時添加圖片、在特定區塊加入提示訊息等。 在 jQuery 中，為了讓這些操作更簡潔有效率，提供了多種用來「新增元素」的方法，如 .append()、.prepend()、.after()、.before()、.appendTo() 與 .prependTo()，雖然功能相似，但添加的位置與語法的寫法略有不同！ 添加到指定元素內部.append()在選取元素內部的最後方添加新內容 js1$(目標元素).append(要添加的內容); 範例： 實例搶先看 .append() 在選取元素內部的最後方添加新內容 html123456789&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;box&quot;&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example&quot;&gt;.append() 添加元素&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js123456789// .append()$('.example').on('click', function() { $('#box').append('&lt;p&gt;World&lt;/p&gt;');});// reset$('.reset').on('click', function() { $('.content').html('&lt;div id=&quot;box&quot;&gt;Hello&lt;/div&gt;');}); 結果： html1234&lt;div id=&quot;box&quot;&gt; Hello &lt;p&gt;World&lt;/p&gt;&lt;/div&gt; .prepend()在選取元素內部的最前方添加新內容 js1$(目標元素).prepend(要添加的內容); 範例： 實例搶先看 .prepend() 在選取元素內部的最後方添加新內容 html123456789&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;box&quot;&gt;World&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example&quot;&gt;.prepend() 添加元素&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js123456789// prepend()$('.example').on('click', function() { $('#box').prepend('&lt;p&gt;Hello&lt;/p&gt;');});// reset$('.reset').on('click', function() { $('.content').html('&lt;div id=&quot;box&quot;&gt;World&lt;/div&gt;');}); 結果： html1234&lt;div id=&quot;box&quot;&gt; &lt;p&gt;Hello&lt;/p&gt; World&lt;/div&gt; .appendTo()把新內容添加到目標元素內部的最後方 js1$(要添加的內容).appendTo(目標元素); 範例： 實例搶先看 .appendTo() 把新內容添加到目標元素內部的最後方 html123456789&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;box&quot;&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example&quot;&gt;.appendTo() 添加元素&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js12345678910// .appendTo()$('.example').on('click', function() { $('&lt;p&gt;World&lt;/p&gt;').appendTo('#box'); // 效果和 $('#box').append('&lt;p&gt;World&lt;/p&gt;'); 相同});// reset$('.reset').on('click', function() { $('.content').html('&lt;div id=&quot;box&quot;&gt;Hello&lt;/div&gt;');}); 結果： html1234&lt;div id=&quot;box&quot;&gt; Hello &lt;p&gt;World&lt;/p&gt;&lt;/div&gt; .prependTo()把新內容添加到目標元素內部的最前方 js1$(要添加的內容).prependTo(目標元素); 範例： 實例搶先看 .prependTo() 把新內容添加到目標元素內部的最前方 html123456789&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;box&quot;&gt;World&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example&quot;&gt;.prependTo() 添加元素&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js12345678910// .prependTo()$(&quot;.example&quot;).on(&quot;click&quot;, function () { $(&quot;&lt;p&gt;Hello&lt;/p&gt;&quot;).prependTo(&quot;#box&quot;); // 效果和 $('#box').prepend('&lt;p&gt;Hello&lt;/p&gt;'); 相同});// reset$(&quot;.reset&quot;).on(&quot;click&quot;, function () { $(&quot;.content&quot;).html('&lt;div id=&quot;box&quot;&gt;World&lt;/div&gt;');}); 結果： html1234&lt;div id=&quot;box&quot;&gt; &lt;p&gt;Hello&lt;/p&gt; World&lt;/div&gt; 添加到指定元素外部.after()在選取元素外部的後面添加新內容 js1$(目標元素).after(要添加的內容); 範例： 實例搶先看 .after() 在選取元素外部的後面添加新內容 html123456789&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;box&quot;&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example&quot;&gt;.after() 添加元素&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js123456789// .after()$('.example').on('click', function() { $('#box').after('&lt;p&gt;World&lt;/p&gt;');});// reset$('.reset').on('click', function() { $('.content').html('&lt;div id=&quot;box&quot;&gt;Hello&lt;/div&gt;');}); 結果： html1234&lt;div id=&quot;box&quot;&gt; Hello&lt;/div&gt;&lt;p&gt;World&lt;/p&gt; .before()在選取元素外部的前面添加新內容 語法： js1$(目標元素).before(要添加的內容); 範例： 實例搶先看 .before() 在選取元素外部的前面添加新內容 html123456789&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;box&quot;&gt;World&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field is-grouped&quot;&gt; &lt;button class=&quot;button is-link example&quot;&gt;.before() 添加元素&lt;/button&gt; &lt;button class=&quot;button reset&quot;&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; js123456789// .before()$('.example').on('click', function() { $('#box').before('&lt;p&gt;Hello&lt;/p&gt;');});// reset$('.reset').on('click', function() { $('.content').html('&lt;div id=&quot;box&quot;&gt;World&lt;/div&gt;');}); 結果： html12&lt;p&gt;Hello&lt;/p&gt;&lt;div id=&quot;box&quot;&gt;World&lt;/div&gt; 添加位置比較 方法 添加位置 .append() 目標元素內部最後 .prepend() 目標元素內部最前 .appendTo() 目標元素內部最後 .prependTo() 目標元素內部最前 .after() 目標元素外部後面 .before() 目標元素外部前面 結論我常常忘記哪些方法是添加到元素內部，哪些是添加到元素外部，所以用這篇文章來做個整理，方便自己記憶😆。這些添加元素的方法在做前端互動時非常實用，如果有其他更簡單、方便的添加方法，歡迎留言分享～ 延伸閱讀 【jQuery 官方文件】.append() 介紹 【jQuery 官方文件】.prepend() 介紹 【jQuery 官方文件】.appendTo() 介紹 【jQuery 官方文件】.prependTo() 介紹 【jQuery 官方文件】.after() 介紹 【jQuery 官方文件】.before() 介紹","link":"/Frontend/JQuery/Analyzing-Six-Methods-for-Adding-Elements/"},{"title":"【Tool】cron 表達式（排程時間）轉換","text":"本篇重點 cron 表達式（排程時間）生成工具 cron 表達式轉換工具 介紹 cron 和 cron 表達式 cron 表達式符號語法使用方式 查詢所有/指定排程（crontab）的方法 新增/修改/刪除排程（crontab）的方法 .card { transition: opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out; opacity: 1; transform-origin: center top; } input[type=number]::-webkit-outer-spin-button, input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; } input[type=number] { -moz-appearance: textfield; } cron 表達式（排程時間）生成工具 從每個時間分類頁籤挑選要設定時間 依分類規則輸入 顯示 5 欄位格式的 cron 表達式，分別是分鐘（minute）、小時（hour）、日期（DOM - dayOfMonth）、月份（month）、星期（DOW - dayOfWeek），例如：5 0 * * 1 分鐘 小時 日期 月份 星期 固定間隔 區間範圍 指定時刻 設定「從哪個時間點開始」每隔多少單位執行一次，產生 起始值/間隔 的 cron 語法 * 表示每個可能的時間點，如果設定 * 並輸入執行間隔，* 表示從最小值開始 某時刻 執行間隔 設定一個區間，表示排程任務會在這段時間內「每個單位都執行一次」，產生 最小值-最大值 的 cron 語法 最小值 最大值 設定執行任務的「具體時間點」，可使用「逗號 ,」同時選擇多個時間，產生 時間點,時間點,時間點 的 cron 語法 某時刻 可使用 \",\" 選擇多個時間 固定間隔 區間範圍 指定時刻 設定「從哪個時間點開始」每隔多少單位執行一次，產生 起始值/間隔 的 cron 語法 * 表示每個可能的時間點，如果設定 * 並輸入執行間隔，* 表示從最小值開始 某時刻 執行間隔 設定一個區間，表示排程任務會在這段時間內「每個單位都執行一次」，產生 最小值-最大值 的 cron 語法 最小值 最大值 設定執行任務的「具體時間點」，可使用「逗號 ,」同時選擇多個時間，產生 時間點,時間點,時間點 的 cron 語法 某時刻 可使用 \",\" 選擇多個時間 固定間隔 區間範圍 指定時刻 設定「從哪個時間點開始」每隔多少單位執行一次，產生 起始值/間隔 的 cron 語法 * 表示每個可能的時間點，如果設定 * 並輸入執行間隔，* 表示從最小值開始 某時刻 執行間隔 設定一個區間，表示排程任務會在這段時間內「每個單位都執行一次」，產生 最小值-最大值 的 cron 語法 最小值 最大值 設定執行任務的「具體時間點」，可使用「逗號 ,」同時選擇多個時間，產生 時間點,時間點,時間點 的 cron 語法 某時刻 可使用 \",\" 選擇多個時間 固定間隔 區間範圍 指定時刻 設定「從哪個時間點開始」每隔多少單位執行一次，產生 起始值/間隔 的 cron 語法 * 表示每個可能的時間點，如果設定 * 並輸入執行間隔，* 表示從最小值開始 某時刻 執行間隔 設定一個區間，表示排程任務會在這段時間內「每個單位都執行一次」，產生 最小值-最大值 的 cron 語法 最小值 最大值 設定執行任務的「具體時間點」，可使用「逗號 ,」同時選擇多個時間，產生 時間點,時間點,時間點 的 cron 語法 某時刻 可使用 \",\" 選擇多個時間 固定間隔 區間範圍 指定時刻 設定「從哪個時間點開始」每隔多少單位執行一次，產生 起始值/間隔 的 cron 語法 * 表示每個可能的時間點，如果設定 * 並輸入執行間隔，* 表示從最小值開始 0 表示星期日、1 表示星期一以此類推 某時刻 執行間隔 設定一個區間，表示排程任務會在這段時間內「每個單位都執行一次」，產生 最小值-最大值 的 cron 語法 0 表示星期日、1 表示星期一以此類推 最小值 最大值 設定執行任務的「具體時間點」，可使用「逗號 ,」同時選擇多個時間，產生 時間點,時間點,時間點 的 cron 語法 0 表示星期日、1 表示星期一以此類推 某時刻 可使用 \",\" 選擇多個時間 cron 表達式 * * * * * 說明 中文 English 下次執行時間 cron 表達式轉換工具 支援基本 5 欄位格式，分別是分鐘（minute）、小時（hour）、日期（DOM - dayOfMonth）、月份（month）、星期（DOW - dayOfWeek），例如：5 0 * * 1 星期欄位（第 5 個欄位），0 表示星期日、1 表示星期一以此類推 cron 表達式 說明 中文 English 下次執行時間 $(function() { let timeout; const userLang = (navigator.language || navigator.userLanguage || '').toLowerCase(); if (userLang.startsWith('en')) { $('#translation').val('en'); $('#translation_input').val('en'); cronParser(); } else { cronParser(); } $(\"#translation, #translation_input\").on(\"change\", function(e) { if (e.target.id == 'translation') { cronParser(); } else { cronParser(true); } }); const tabContents = document.querySelectorAll('.tabs ~ .tab-content'); const observer = new MutationObserver((mutationsList) => { for (const mutation of mutationsList) { if (mutation.type === 'attributes' && mutation.attributeName === 'class') { const target = mutation.target; if (!target.classList.contains('is-hidden')) { update_cron_expression(target.id); } } } }); tabContents.forEach(el => { observer.observe(el, { attributes: true, attributeFilter: ['class'] }); }); $('#cron_expression_input').on('input', function () { const currentCron = $('#cron_expression_input').val().trim(); let cronParts = currentCron.split(' '); if (cronParts.length != 5) { return; } cronParser(true); }); $('[data-unit]').on('input', function () { const unit = $(this).data('unit'); const activeTabId = $(`#${unit} > .tab-content:not(.is-hidden)`).attr('id'); update_cron_expression(activeTabId); }); later.date.localTime(); function update_cron_expression(tabId) { const currentCron = $('#cron_expression').text().trim() || '* * * * *'; let cronParts = currentCron.split(' '); if (tabId.substr(0, 3) === 'min') { cronParts = update_expression_unit(tabId, cronParts, 0, 'min_', validMin) } else if (tabId.substr(0, 1) === 'h') { cronParts = update_expression_unit(tabId, cronParts, 1, 'h_', validHour) } else if (tabId.substr(0, 1) === 'd') { cronParts = update_expression_unit(tabId, cronParts, 2, 'd_', validDay) } else if (tabId.substr(0, 3) === 'mon') { cronParts = update_expression_unit(tabId, cronParts, 3, 'mon_', validMon) } else if (tabId.substr(0, 1) === 'w') { cronParts = update_expression_unit(tabId, cronParts, 4, 'w_', validWeek) } $('#cron_expression').text(cronParts.join(' ')); cronParser(); } function update_expression_unit(tabId, cronParts, unitIndex, unitPrefix, validator) { let value = cronParts[unitIndex]; if (tabId === `${unitPrefix}step`) { const every = $(`#${unitPrefix}step_every`).val().trim(); const step = $(`#${unitPrefix}step_step`).val().trim(); if (every == '') { value = '*'; } else if (every === '*' || validator(every)) { value = validator(step) && Number(step) > 0 ? `${every}/${step}` : every; } } else if (tabId === `${unitPrefix}range`) { const min = $(`#${unitPrefix}range_min`).val().trim(); const max = $(`#${unitPrefix}range_max`).val().trim(); if (min == '' || max == '') { value = '*'; } else if (validator(min) && validator(max) && Number(min) < Number(max)) { value = `${min}-${max}`; } } else if (tabId === `${unitPrefix}choices`) { const raw = $(`#${unitPrefix}choices_choices`).val().trim(); const parts = raw.split(','); const valid = parts.every(v => validator(v)); if (raw == '') { value = '*'; } else if (raw && valid) { value = raw; } } cronParts[unitIndex] = value ? value : '*'; return cronParts; } function validMin(val) { return /^\\d+$/.test(val) && val >= 0 && val = 0 && val = 1 && val = 1 && val = 0 && val { $('').text(date.toString()).appendTo(ol); }); $(next_times).empty().append(ol) } catch (err) { if (input) { check = $(\".icon-text.has-text-success\"); error = $(\".icon-text.has-text-danger\"); clearTimeout(timeout); error.fadeIn(); check.hide(); timeout = setTimeout(function() { check.fadeOut(300); error.fadeOut(300); }, 1500); } $(cron_parser).text(err).addClass('has-text-danger'); $(next_times).html('無效的 Cron 表達式'); } } }); cron 表達式工具有錯誤或建議歡迎留言告訴我😁 cron 表達式工具使用範例這邊示範如何使用 cron 表達式生成工具～ 每天十二點半執行排程 切換到分鐘頁籤的固定間隔，某時刻輸入 30 切換到小時頁籤的固定間隔，某時刻輸入 12 每個星期六，每小時每15分鐘執行排程 切換到分鐘頁籤的固定間隔，某時刻輸入 *，執行間隔輸入 15 切換到星期頁籤的固定間隔，輸入 6 一到三月的一號和十五號，00:00 執行排程 切換到分鐘頁籤的固定間隔，某時刻輸入 0 切換到小時頁籤的固定間隔，某時刻輸入 0 切換到日期頁籤的指定時刻，某時刻輸入 1,15 切換到月份頁籤的區間範圍，最小值輸入 1，最大值輸入 3 什麼是 cron？cron 是 Linux/Unix 系統中的一種排程工具，用來自動執行指定時間的任務，例如定時備份資料、寄送報表、執行維護腳本等。而 cron 的排程是透過 cron 表達式來定義執行的時間與頻率 cron 表達式的基本格式bash12345678* * * * * &lt;command&gt;- - - - -| | | | || | | | +---- 星期幾 (0 - 6)（0 是星期日）| | | +------ 月份 (1 - 12)| | +-------- 日 (1 - 31)| +---------- 時 (0 - 23)+------------ 分 (0 - 59) 星號（*）表示每個可能的時間點。 例如 * * * * * 表示每分鐘都執行。 逗號（,）表示多個時間點。 例如：0 9,18 * * * 表示每天 9 點與 18 點各執行一次。 減號（-）表示時間的範圍。 例如：0 8-10 * * * 表示每天 8 點、9 點、10 點執行一次。 斜線（/）表示每個時間點間隔多少單位。 例如：0 */3 * * * 表示每 3 小時整點執行一次。 範例 cron 表達式 說明 0 10 * * * 每天早上 10:00 執行一次 */15 * * * * 每 15 分鐘執行一次 0 */2 * 1,10 * 一月和十月每兩小時整點執行一次 0 12 * * 1-5 每週一到五中午 12:00 執行 (平日) 0 0 1 * * 每月 1 號的午夜 00:00 執行 0 22 * * 0,6 每週六、日晚上 10:00 執行 (假日) 查詢 crontab 排程查詢所有排程bash12345crontab -l# 結果0 10 * * 0,6 /home/user/scripts/backup.sh0 8 * * * /home/user/scripts/deploy.sh 查詢指定排程bash1234crontab -l | grep deploy# 結果0 8 * * * /home/user/scripts/deploy.sh 新增/修改/刪除 crontab 排程使用指令後會打開編輯器，直接在編輯器裡面新增/修改/刪除排程 bash1crontab -e 延伸閱讀 【wikipedia】cron 介紹 【bradymholt/cRonstrue】cron 表達式解析工具 【bunkat/later】計算排程的執行時間","link":"/Other/Tool/Cron-Expression-Conversion/"},{"title":"【PHP】解析 break 和 continue 對迴圈的控制","text":"本篇重點 認識 break 和 continue 可用在哪些地方 說明 break 和 continue 的基本語法 介紹 break n; 和 continue n; 在巢狀迴圈中的應用 終止或跳過的層數不能超過實際的巢狀層數，否則會有錯誤訊息 在 switch 裡控制外層迴圈 可用在哪些地方？ foreach 迴圈 for 迴圈 while 迴圈 do...while 迴圈 這些結構都可以透過 break 來跳出整個迴圈，或是透過 continue 來略過本次執行，直接進入下一輪 基本語法break立即結束目前的迴圈，從迴圈區塊外繼續執行 php12345678for ($i = 0; $i &lt; 5; $i++) { // 當 $i 為 3 時跳出迴圈 if ($i == 3) { break; } echo $i . &quot;\\n&quot;;}echo &quot;迴圈結束&quot;; result1234012迴圈結束 動手做做看 break 基本語法 立即結束目前的迴圈，從迴圈區塊外繼續執行 動手做做看 continue跳過目前迴圈的後續內容，直接進入下一輪 php12345678for ($i = 0; $i &lt; 5; $i++) { // 當 $i 為 3 時略過輸出 if ($i == 3) { continue; } echo $i . &quot;\\n&quot;;}echo &quot;迴圈結束&quot;; result123450124迴圈結束 動手做做看 continue 基本語法 跳過目前迴圈的後續內容，直接進入下一輪 動手做做看 在巢狀迴圈中使用 break n; 與 continue n;多層迴圈（巢狀結構）中可以在 break 或 continue 後加上數字，控制要跳出或跳過幾層迴圈 break n;多層迴圈（巢狀結構）中，在 break 後加上數字，立即結束 n 層的迴圈，從迴圈區塊外繼續執行 php123456789for ($i = 0; $i &lt; 3; $i++) { for ($j = 0; $j &lt; 3; $j++) { echo &quot;i = $i, j = $j\\n&quot;; if ($j == 1) { break 2; // 跳出 $j 和 $i 這兩層迴圈 } }}echo &quot;迴圈結束&quot;; result123i = 0, j = 0i = 0, j = 1迴圈結束 動手做做看 巢狀迴圈中使用 break n; 多層迴圈（巢狀結構）中，在 break 後加上數字，立即結束 n 層的迴圈，從迴圈區塊外繼續執行 動手做做看 continue n;多層迴圈（巢狀結構）中，在 continue 後加上數字，跳過 n 層迴圈的後續內容，直接進入下一輪 php123456789for ($i = 0; $i &lt; 3; $i++) { for ($j = 0; $j &lt; 3; $j++) { echo &quot;i = $i, j = $j\\n&quot;; if ($j == 1) { continue 2; // 跳過目前 $i 的迴圈，直接到 $i++ } }}echo &quot;迴圈結束&quot;; result1234567i = 0, j = 0i = 0, j = 1i = 1, j = 0i = 1, j = 1i = 2, j = 0i = 2, j = 1迴圈結束 動手做做看 巢狀迴圈中使用 continue n; 多層迴圈（巢狀結構）中，在 continue 後加上數字，跳過 n 層迴圈的後續內容，直接進入下一輪 動手做做看 在 switch 裡控制外層迴圈switch 通常搭配 break 使用來結束 case 區塊（不能使用 continue）。但如果 switch 是寫在迴圈（如 foreach 或 for）裡，有時會希望在 switch 中直接跳出外層的迴圈，這時可以使用 break 2 或 continue 2。 switch 基本用法正確範例 動手做做看 錯誤跳出 switch switch 不是迴圈，因此不能直接使用 continue 或 break 動手做做看 php12345678910$switch = 'A'; switch ($switch) { case 'A': echo &quot;處理 $switch\\n&quot;; break; default: echo &quot;處理 $switch\\n&quot;; break; }echo &quot;switch 結束\\n&quot;; result12處理 Aswitch 結束 錯誤範例 動手做做看 錯誤跳出 switch switch 不是迴圈，因此不能直接使用 continue 或 break 動手做做看 php12345$x = 1;switch ($x) { case 1: continue;} result1PHP Warning: &quot;continue&quot; targeting switch is equivalent to &quot;break&quot; 控制外層迴圈break 2 動手做做看 switch 控制外層迴圈 - break 2 如果 switch 是包在一個迴圈裡，就可以用 break 2; 跳出 switch 及外層迴圈，繼續往下執行 動手做做看 php12345678910$list = ['A', 'break', 'B'];foreach ($list as $item) { switch ($item) { case 'break': break 2; default: echo &quot;處理 $item\\n&quot;; }}echo &quot;break 2&quot;; result12處理 Abreak 2 continue 2 動手做做看 switch 控制外層迴圈 - continue 2 如果 switch 是包在一個迴圈裡，就可以用 continue 2; 跳出 switch 並到外層迴圈的下一輪 動手做做看 php12345678910$list = ['A', 'continue', 'B'];foreach ($list as $item) { switch ($item) { case 'continue': continue 2; default: echo &quot;處理 $item\\n&quot;; }}echo &quot;continue 2&quot;; result123處理 A處理 Bcontinue 2 注意事項 break n; 和 continue n; 中的 n 不能超過實際的巢狀層數，否則會產生錯誤： error1Fatal error: Cannot break/continue N levels 動手做做看 不能超過實際的巢狀層數 break n; 和 continue n; 中的 n 不能超過實際的巢狀層數，否則會產生錯誤 動手做做看 break 或 continue 僅適用於「可中斷」的控制結構，因此不能用在 if 等條件式中 結論 continue; 與 continue 1; 一樣，僅跳過當前迴圈的剩餘程式碼，進入下一次迴圈。 continue n; 跳過 n 層迴圈，直接讓更外層迴圈的當前次數終止並開始下一次迴圈。 避免濫用 continue n;，特別是在多層迴圈，程式的可讀性會降低。 延伸閱讀 【PHP 官方文件】continue 介紹 【PHP 官方文件】break 介紹","link":"/Backend/PHP/How-break-and-continue-Control-the-Flow-of-Loops/"},{"title":"【Html】實用的 &lt;input&gt; 表單屬性","text":"本篇重點 了解各個場景適合的 &lt;input&gt; 屬性 移除 &lt;input type=&quot;number&quot;&gt; 上下箭頭的方法 如何依需求控制行動裝置的鍵盤類型 開發表單時，善用 &lt;input&gt; 的屬性可以讓輸入更直覺，並且提升使用者體驗，特別是行動裝置效果顯著 type=&quot;number&quot;：限制只能輸入數字限制輸入數值，可搭配 min、max、step 控制範圍與增減幅度，部分瀏覽器會顯示上下箭頭，可控制輸入的數值，適合用於金額、數量等欄位。 html1234&lt;label &gt;type=&quot;number&quot;： &lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;100&quot; step=&quot;5&quot; /&gt;&lt;/label&gt; 移除上下箭頭的方法如果不想要有上下箭頭，可以使用 css 移除 html1234&lt;label &gt;移除上下箭頭： &lt;input class=&quot;remove_arrow&quot; type=&quot;number&quot; min=&quot;1&quot; max=&quot;100&quot; step=&quot;5&quot; /&gt;&lt;/label&gt; css123456789input[type=&quot;number&quot;].remove_arrow::-webkit-outer-spin-button,input[type=&quot;number&quot;].remove_arrow::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0;}input[type=&quot;number&quot;].remove_arrow { -moz-appearance: textfield;} type=&quot;tel&quot;：在手機上顯示數字鍵盤不會驗證格式，但在行動裝置上會顯示數字輸入鍵盤，適合輸入電話。 html1234&lt;label &gt;type=&quot;tel&quot;： &lt;input type=&quot;tel&quot;/&gt;&lt;/label&gt; type=&quot;email&quot;：基本 Email 格式驗證不會主動驗證格式，執行送出表單才會驗證信箱格式，適合輸入信箱。 html1234&lt;label&gt;type=&quot;email&quot;： &lt;input type=&quot;email&quot; /&gt;&lt;/label&gt;&lt;button&gt;送出&lt;/button&gt; type=&quot;url&quot;：基本 url 格式驗證不會主動驗證格式，執行送出表單才會驗證網址格式，適合輸入網址。 html12345&lt;label &gt;type=&quot;url&quot;： &lt;input type=&quot;url&quot;/&gt;&lt;/label&gt;&lt;button&gt;送出&lt;/button&gt; type=&quot;date&quot;：日期選擇器提供內建的月曆選擇器，可搭配 min、max 控制日期範圍，適合輸入日期。 html1234&lt;label &gt;type=&quot;date&quot;： &lt;input type=&quot;date&quot; min=&quot;2023-01-01&quot; max=&quot;2025-12-31&quot;/&gt;&lt;/label&gt; type=&quot;month&quot;：月份選擇器提供內建的月份選擇器，可搭配 min、max 控制日期範圍，適合輸入月份。 html1234&lt;label &gt;type=&quot;month&quot;： &lt;input type=&quot;month&quot; min=&quot;2024-01&quot; max=&quot;2025-12&quot;/&gt;&lt;/label&gt; type=&quot;datetime-local&quot;：日期時間選擇器提供內建的日期時間選擇器，可搭配 min、max 控制日期範圍，step 增加秒數選項，適合輸入日期時間。 html1234&lt;label &gt;type=&quot;datetime-local&quot;： &lt;input type=&quot;datetime-local&quot; min=&quot;2025-01-01T08:00&quot; max=&quot;2025-12-31T18:00&quot;/&gt;&lt;/label&gt; 增加秒數選項html1234&lt;label &gt;type=&quot;datetime-local&quot;： &lt;input type=&quot;datetime-local&quot; step=&quot;1&quot;/&gt;&lt;/label&gt; type=&quot;time&quot;：時間選擇器提供內建的時間選擇器，可搭配 step 增加秒數選項，適合輸入時間。 html1234&lt;label &gt;type=&quot;time&quot;： &lt;input type=&quot;time&quot; /&gt;&lt;/label&gt; 增加秒數選項html1234&lt;label &gt;type=&quot;time&quot;： &lt;input type=&quot;time&quot; step=&quot;1&quot;/&gt;&lt;/label&gt; type=&quot;range&quot;：滑桿式數字輸入提供內建的滑桿，搭配 min、max 控制數值範圍，適合用在音量、亮度、分數等場景。 html1234&lt;label &gt;type=&quot;range&quot;： &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;10&quot; /&gt;&lt;/label&gt; type=&quot;color&quot;：色彩選擇器提供內建的色彩選擇工具，回傳 hex 色碼，適合輸入色彩。 html1234&lt;label &gt;type=&quot;color&quot;： &lt;input type=&quot;color&quot;/&gt;&lt;/label&gt; inputmode：行動裝置上切換適合的鍵盤不改變輸入型態（type），使用 inputmode 也可以在行動裝置顯示對應的鍵盤類型，例如 numeric、email 鍵盤等。 html12345678&lt;label &gt;inputmode=&quot;numeric&quot;： &lt;input type=&quot;text&quot; inputmode=&quot;numeric&quot; /&gt;&lt;/label&gt;&lt;label &gt;inputmode=&quot;email&quot;： &lt;input type=&quot;text&quot; inputmode=&quot;email&quot; /&gt;&lt;/label&gt; 健忘筆記 使用 Can I use 查詢屬性在每個瀏覽器的相容性 結論HTML5 提供了多種實用的 &lt;input&gt; 屬性，可以減少 JavaScript 驗證的需求，並且提升使用者操作上的便利性。特別是在行動裝置上，不同的 type 搭配 inputmode 能提供對應的輸入鍵盤，打造更直覺、流暢的表單體驗。 延伸閱讀 【MDN】input 屬性介紹 【Can I use】查詢瀏覽器相容性","link":"/Frontend/Html/Useful-Attributes-for-Input-Elements/"},{"title":"【API】使用 Google Analytics Data API 架設網站流量查詢 API","text":"本篇重點 如何使用 Google Analytics Data API 在 GA 中新增服務帳號，授權 API 存取 GA 數據 Fork GitHub 專案並部署至 Netlify，快速建立網站流量查詢 API 掌握 forgetfulengineer/google-analytics-data-api-netlify 專案使用方式 本篇紀錄如何使用 forgetfulengineer/google-analytics-data-api-netlify 網站流量查詢 API，取得網站的 總瀏覽量（PV）、不重複訪客（UV） 以及 單頁瀏覽量（page PV），並且部署在 Netlify 無伺服器環境中。 GA 設定與取得 API 金鑰啟用 Google Analytics Data API前往 Google Cloud Platform 控制台： 建立一個專案 前往「API 與服務 &gt; 程式庫」，搜尋並啟用：Google Analytics Data API 建立服務帳號 前往「IAM &amp; 管理 &gt; 服務帳號」建立新帳號 權限選擇：擁有者 建立金鑰（JSON） 為服務帳號新增金鑰，格式選擇：JSON 儲存該 JSON 檔案內容，等等會用在 API 認證 加入 GA 資源前往 Google Analytics 控制台： 前往 GA 管理後台：管理 &gt; 資源設定 &gt; 資源存取管理 新增剛才建立的服務帳號信箱（xxx@xxx.iam.gserviceaccount.com），授權 分析人員 取得 GA 的 Property ID GA 的資源 ID 可於 管理 &gt; 資源設定 &gt; 資源詳細資料 取得 Fork 專案並部署到 NetlifyFork GitHub 專案 fork forgetfulengineer/google-analytics-data-api-netlify 到自己的 github 將專案部署到 Netlify 前往 Netlify 建立新專案 選擇「Projects &gt; Add new project &gt; Import an existing project」，並連結剛剛 fork 的 repo 設定環境變數 選擇「Add environment variables &gt; Import from a .env file」 設定 API 所需的環境變數 名稱 說明 PROPERTYID GA Property ID STARTDATE 開始統計的日期，如 2023-12-31 ENDDATE 結束統計的日期，如 today GOOGLE_APPLICATION_CREDENTIALS_JSON GA 服務帳號金鑰內容（請勿公開） .env file1234PROPERTYID=123456789STARTDATE=2023-12-31ENDDATE=todayGOOGLE_APPLICATION_CREDENTIALS_JSON={&quot;type&quot;:&quot;service_account&quot;,...} 健忘筆記 日期格式為 YYYY-MM-DD，系統也接受 NdaysAgo、yesterday 或 today 格式，系統會根據資源的回報時區推斷日期，詳細可查看文件 如果環境變數未被正確讀取，可以查看【Netlify】環境變數更新無效的除錯流程 API 使用方式參數說明 參數名稱 是否必填 說明 範例 path 否 欲查詢的單篇頁面路徑 /Backend/MySQL/DQL-Execution-Order/ 查詢全站 PV/UVGET https://{your-site}.netlify.app/.netlify/functions/pageview 回傳格式 json1234{ &quot;pv&quot;: string, &quot;uv&quot;: string} 範例GET https://ga-api-demo.netlify.app/.netlify/functions/pageview 回傳格式 json1234{ &quot;pv&quot;: &quot;8888&quot;, &quot;uv&quot;: &quot;1234&quot;} 查詢特定路徑 PVGET https://{your-site}.netlify.app/.netlify/functions/pageview?path={your-path} 回傳格式 json123456{ &quot;pv&quot;: string, &quot;uv&quot;: string, &quot;path&quot;: string, &quot;pageViews&quot;: string} 範例GET https://ga-api-demo.netlify.app/.netlify/functions/pageview?path=/Backend/MySQL/DQL-Execution-Order/ 回傳格式 json123456{ &quot;pv&quot;: &quot;8888&quot;, &quot;uv&quot;: &quot;1234&quot;, &quot;path&quot;: &quot;/Backend/MySQL/DQL-Execution-Order/&quot;, &quot;pageViews&quot;: &quot;100&quot;} 補充：專案說明 部署在 Netlify Functions，採用 Node.js 撰寫，並且 .js 檔案會被 Netlify 包裝成可被呼叫的 API 端點（Function Endpoint），當收到請求時，自動呼叫匯出的 handler 函式，不需要額外設定伺服器或手動執行函式。 使用 npm 的 @google-analytics/data 套件串接 Google Analytics Data API，使用套件的 batchRunReports 搭配環境變數讀取設定來查詢 GA 的資料。 使用 async/await 語法來處理非同步資料請求。await 可暫停函式執行直到 Promise 結果回傳，讓程式接近同步流程。 回應中包含 HTTP 標頭 { 'Access-Control-Allow-Origin': '*' }，用來允許跨來源請求（CORS），這樣能夠從不同網域（例如部署在 GitHub Pages 的前端網站）向此 API 發送請求，否則瀏覽器會因同源政策（Same-Origin Policy）而阻擋請求。 結論從 google analytics data api 的使用、 GA 的設定、Fork 專案到 Netlify 上線，打造自己的 網站流量查詢 API，支援全站 PV/UV 與單頁 PV 查詢。 可以將這支 API 應用在： 網頁上即時顯示瀏覽量 自訂網站儀表板 自動化分析與報表工具 如果對 API 有甚麼建議歡迎留言或是開 issue 讓我知道～ Google Analytics Data API 的應用 【API】使用 Google Analytics Data API 架設網站流量查詢 API【Hexo】Icarus 主題串接 GA 顯示網站 PV 和 UV 延伸閱讀 【Google 官方文件】Google Analytics Data API 總覽 【Netlify 官方文件】Netlify Functions 介紹","link":"/Backend/API/Building-a-Traffic-API-with-GA-Data-API/"},{"title":"【Hexo】Icarus 主題串接 GA 顯示網站 PV 和 UV","text":"本篇重點 如何修改 Icarus 主題、新增自訂插件 Icarus 主題串接 Google Analytics 顯示網站 PV 和 UV 使用 forgetfulengineer/google-analytics-data-api-netlify API 顯示網站數據 使用 countUp.js 建立數字的動畫效果 先了解API的使用可以幫助你更快理解唷😁 【API】使用 Google Analytics Data API 架設網站流量查詢 API Icarus 主題原生僅支援不蒜子提供的 PV 計數功能，無法串接 Google Analytics 的瀏覽數據。為了顯示來自 GA 的數據，我建立了 forgetfulengineer/google-analytics-data-api-netlify 作為 API 接口，並修改 Icarus 主題，使其能透過該 API 顯示網站數據。本文紀錄如何修改 Icarus 主題、新增自訂插件，並串接 API 顯示網站的 PV 與 UV。 1. 架設網站 PV/UV 查詢 APIfork forgetfulengineer/google-analytics-data-api-netlify 並部署到 Netlify，建立一個可查詢網站 PV/UV 的 API，詳細部屬流程請查看【API】使用 Google Analytics Data API 架設網站流量查詢 API。 2. 添加自定義插件Icarus 主題大部分的通用布局文件已被移至 repository hexo-component-inferno，因此可以在不影響主題更新的情況下添加自定義插件，布局文件的詳細說明可查看官方文件。 建立 ga_count 的 schema新增 icarus 設定檔參數的概要 檔案路徑12345678themes/├── icarus/│ └── include/│ └── schema/│ └── plugin/│ └── ga_count.json ← 新增參數概要│ └── common/│ └── plugins.json ← 增加引用路徑 新增參數概要 /include/schema/plugin/ga_count.json查看123456789101112131415{ &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;, &quot;$id&quot;: &quot;/plugin/ga_count.json&quot;, &quot;description&quot;: &quot;Ga count plugin&quot;, &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;ga_count_api&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Google Analytics Data API&quot;, &quot;nullable&quot;: true, &quot;examples&quot;: [&quot;https://ga-api-demo.netlify.app/.netlify/functions/pageview&quot;] } }, &quot;required&quot;: [&quot;ga_count_api&quot;]} 增加引用路徑 /include/schema/common/plugins.json查看12345{ ... &quot;ga_count&quot;: &quot;plugin/ga_count.json&quot; ...} 主題設定啟用 ga_count填入 API 路徑 https://{your-site}.netlify.app/.netlify/functions/pageview _config.icarus.yml123plugins: ga_count: ga_count_api: https://ga-api-demo.netlify.app/.netlify/functions/pageview 建立 ga_count 元件新增 /layout/plugin/ga_count.jsx 作為 Hexo 客製化插件，用於前端呼叫 GA API，並顯示瀏覽數。 jsx查看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const { Component, Fragment } = require('inferno');const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');class GACount extends Component { render() { const { head, apiUrl, countUpJs } = this.props; if (head) return null; let gaCountJs = `(function() { var url = &quot;${apiUrl}&quot;; fetch(url, { method: 'get' }) .then(response =&gt; response.json()) .then(json =&gt; { var sitePvElement = document.getElementById('ga_value_site_pv'); var siteUvElement = document.getElementById('ga_value_site_uv'); var pvElement = document.getElementById('ga_value_page_pv'); if (sitePvElement) { const sitePv = new countUp.CountUp('ga_value_site_pv', json.pv, { enableScrollSpy: true, scrollSpyOnce: true }); } if (siteUvElement) { const siteUv = new countUp.CountUp('ga_value_site_uv', json.uv, { enableScrollSpy: true, scrollSpyOnce: true }); } if (pvElement) { const pagePv = new countUp.CountUp('ga_value_page_pv', json.pageViews, { enableScrollSpy: true, scrollSpyOnce: true }); } }); })();`; return &lt;Fragment&gt; &lt;script src={countUpJs}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: gaCountJs }}&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}GACount.Cacheable = cacheComponent(GACount, 'plugin.ga_count', props =&gt; { const { helper, head, page, plugin } = props; const { url_for, cdn } = helper; const apiBase = plugin.ga_count_api; const path = url_for(page.path); const apiUrl = (page.layout == 'post') ? `${apiBase}?path=${encodeURIComponent(path)}` : apiBase; const countUpJs = cdn('countup.js', '2.9.0', 'dist/countUp.umd.js'); return { head, apiUrl, countUpJs };});module.exports = GACount; 元件快取機制 cacheComponent： Icarus 主題特有的效能優化方式，避免不必要的重複渲染，每個組件會依據頁面內容快取。 API 路徑動態處理： 根據是否為文章頁，決定是否要加上 ?path= 查詢字串，讓後端能計算單篇 PV。 jsx查看1const apiUrl = (page.layout == 'post') ? `${apiBase}?path=${encodeURIComponent(path)}` : apiBase; 使用 countUp.js 呈現數字動畫： 利用 cdn() 方法載入 CountUp 套件，再透過 enableScrollSpy 與 scrollSpyOnce 讓動畫僅在畫面滾動到數字時觸發一次。 jsx查看1new countUp.CountUp('ga_value_page_pv', json.pageViews, { enableScrollSpy: true, scrollSpyOnce: true }) plugin 載入處理： Icarus 主題中，layout/common/head.jsx 和 layout/common/scripts.jsx 都會載入 plugin，但 ga_count.jsx 只需載入一次，且必須等頁面元素渲染完成後再執行，避免抓不到 PV 元素，因此加入判斷，當處於 &lt;head&gt; 區塊時跳過渲染： jsx查看1if (head) return null; 資料顯示區塊：透過 getElementById 取得 3 個容器（site PV、site UV、單篇 PV），再用 CountUp 顯示動畫數字。 詳細修改紀錄 3. 修改模板：顯示 PV / UV 數字修改 article.jsx（文章 PV）在文章內容（layout/common/article.jsx）中新增顯示該篇文章瀏覽數（PV）的區塊。 jsx查看12345678{/* Visitor counter */}{!index &amp;&amp; plugins &amp;&amp; plugins.ga_count.ga_count_api ? ( &lt;span class=&quot;level-item&quot; id=&quot;ga_container_page_pv&quot;&gt; &lt;i class=&quot;far fa-eye&quot;&gt;&lt;/i&gt; &lt;span id=&quot;ga_value_page_pv&quot;&gt;-&lt;/span&gt; &lt;/span&gt; ) : null;} 修改 footer.jsx （全站 PV/UV）在頁尾（layout/common/footer.jsx）中新增顯示全站瀏覽及訪客數（PV/UV）的區塊。 取得 ga_count 設定並修改瀏覽數據顯示內容 jsx查看1234- showVisitorCounter: plugins &amp;&amp; plugins.busuanzi === true,- visitorCounterTitle: _p('plugin.visitor_count', '&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;0&lt;/span&gt;')+ showVisitorCounter: plugins &amp;&amp; plugins.ga_count.ga_count_api,+ visitorCounterTitle: '&lt;i class=&quot;far fa-eye&quot;&gt;&lt;/i&gt;總瀏覽數：&lt;span id=&quot;ga_value_site_pv&quot;&gt;-&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;i class=&quot;fa-solid fa-person-walking&quot;&gt;&lt;/i&gt;總訪客數：&lt;span id=&quot;ga_value_site_uv&quot;&gt;-&lt;/span&gt;' 將原本 Busuanzi 使用的容器 ID 改為 GA 專用的容器 jsx查看12- {showVisitorCounter ? &lt;span id=&quot;busuanzi_container_site_uv&quot;+ {showVisitorCounter ? &lt;span id=&quot;ga_container_site_pvuv&quot; 詳細修改紀錄 結論透過修改 Icarus 主題與串接 forgetfulengineer/google-analytics-data-api-netlify，就能在網站中顯示來自 Google Analytics 的瀏覽數據，即時掌握網站的流量情況。 如果在串接過程中遇到問題，或有任何建議，歡迎留言讓我知道～接下來計畫新增「熱門文章排行榜」，敬請期待！ Google Analytics Data API 的應用 【API】使用 Google Analytics Data API 架設網站流量查詢 API【Hexo】Icarus 主題串接 GA 顯示網站 PV 和 UV 延伸閱讀 【健忘工程師網站主題】forgetfulengineer/hexo-theme-icarus repository 【網站流量查詢 API】forgetfulengineer/google-analytics-data-api-netlify repository 【數字動畫套件】inorganik/countUp.js repository","link":"/Other/Hexo/Icarus-Integrate-Ga-Api-Pv-Uv/"},{"title":"【JavaScript】字串比大小的型別陷阱","text":"本篇重點 JavaScript 中「字串」與「數字」如何進行比較？ 字串之間的大小比較是依 Unicode 編碼，不是數值 字串與數字混合使用進行比較 避免型別產生的錯誤，提供處理方式 字串與數字在加減乘除的差異 字串比大小結果「不符合預期」在 JavaScript 中，當你使用 &lt; 、 &gt; 、 &lt;= 、 &gt;= 比較兩個字串時，並不會把字串當作數字來比較，而是根據字串的 Unicode 編碼值 進行逐字比較。 範例： js123console.log(&quot;2&quot;.charCodeAt(0)); // 50console.log(&quot;10&quot;.charCodeAt(0)); // 49console.log(&quot;2&quot; &lt; &quot;10&quot;); // false “2” 的 Unicode 是 50 “1” 的 Unicode 是 49 字串逐字比較，因此比較的是 &quot;2&quot; vs &quot;1&quot; → 50 &gt; 49，所以 &quot;2&quot; &lt; &quot;10&quot; 結果是 false 健忘筆記 使用 .charCodeAt() 可以查詢字串的 Unicode 動手做做看 字串與數字混合使用進行比較當你用 &lt;, &gt; 比較 一個字串和一個數字 時，JavaScript 會嘗試將字串轉成數字再比較。 範例： js12console.log(&quot;2&quot; &lt; 10); // true → 字串 &quot;2&quot; 被轉成數字 2console.log(&quot;10&quot; &lt; 2); // false → 字串 &quot;10&quot; 被轉成數字 10 動手做做看 避免型別產生的錯誤確保 &lt;、&gt; 的兩邊是相同型別，使用 parseInt()、Number() 將字串轉為數字。 範例： js1234567891011let str1 = '2';let str2 = '10';// 字串轉為數字後再做比較console.log(typeof parseInt(str1, 10)); // numberconsole.log(typeof parseInt(str2, 10)); // numberconsole.log(parseInt(str1, 10) &lt; parseInt(str2, 10)); // trueconsole.log(typeof Number(str1)); // numberconsole.log(typeof Number(str2)); // numberconsole.log(Number(str1) &lt; Number(str2)); // true 動手做做看 補充：字串與數字在加減乘除的差異不同型別運算時會進行 隱式型態轉換 + 運算子在「有字串」的情況下會是 字串串接。 -、*、/ 等運算子不做字串串接，而是會嘗試把字串轉成數字再計算。 如果轉換失敗，就會得到 NaN（Not-a-Number）。 字串 + 字串 運算 範例 結果 原因 + &quot;2&quot; + &quot;3&quot; &quot;23&quot; + 觸發字串串接 - &quot;5&quot; - &quot;2&quot; 3 兩個字串都可轉數字 * &quot;4&quot; * &quot;3&quot; 12 兩個字串都可轉數字 / &quot;8&quot; / &quot;2&quot; 4 兩個字串都可轉數字 - &quot;a&quot; - &quot;1&quot; NaN &quot;a&quot; 無法轉為數字 字串 + 數字 運算 範例 結果 原因 + &quot;2&quot; + 3 &quot;23&quot; 有字串 → 轉成字串串接 - &quot;2&quot; - 1 1 &quot;2&quot; 轉成數字 2 * &quot;3&quot; * 2 6 &quot;3&quot; 轉成數字 3 / &quot;6&quot; / 3 2 &quot;6&quot; 轉成數字 6 js1234567891011// 字串 + 數字console.log(&quot;2&quot; + 3); // &quot;23&quot; → 字串串接console.log(&quot;2&quot; - 1); // 1 → 轉成數字計算console.log(&quot;3&quot; * 2); // 6 → 轉成數字計算console.log(&quot;6&quot; / 3); // 2 → 轉成數字計算// 字串 + 字串console.log(&quot;5&quot; + &quot;2&quot;); // &quot;52&quot; → 字串串接console.log(&quot;5&quot; - &quot;2&quot;); // 3 → 兩個字串轉成數字計算console.log(&quot;4&quot; * &quot;3&quot;); // 12 → 兩個字串轉成數字計算console.log(&quot;a&quot; - &quot;1&quot;); // NaN → &quot;a&quot; 無法轉為數字 健忘筆記 為了避免運算產生的型別錯誤，請把字串轉為數字再做運算 動手做做看 結論JavaScript 在進行大小比較時，如果是字串會以 Unicode 字元逐個比較，可能會導致意想不到的結果。 養成明確轉型的習慣。 避免字串與數字混合比較。 不確定的地方，可以用 typeof 檢查變數型別。 這樣就能避免很多難以追蹤的錯誤行為，有遇過意想不到的比較結果嗎？歡迎留言分享～","link":"/Frontend/JavaScript/String-Comparison-Type-Gotchas/"},{"title":"【Git】使用 git revert 一次性還原多個提交","text":"本篇重點 git revert 的用途以及使用情境 還原指定或多個提交的方法 調整容易混淆的還原範圍寫法 多個還原合併成一次提交 git revert 和 git reset 的差異 動手做做看 我建了一個範例 repository，可以 clone 下來後跟著文章操作！git clone https://github.com/forgetfulengineer/git-revert-example.git 使用 Git 做版本控制，偶爾會遇到需要「還原某些修改」的情境，這時候除了常聽到的 git reset，還有一個更安全、常被忽略的指令：git revert。 git revert用途建立一個新的 commit，將指定 commit 的變更「還原」回去，換句話說，它不會直接刪除歷史紀錄，而是新增一個「還原某次修改」的提交。 使用情境 誤把有問題的功能合併進主要分支，需要「還原」但不能破壞歷史。 在多人協作的專案裡，避免因為 git reset 改寫歷史而造成衝突。 還原指定提交git1git revert &lt;commit-hash&gt; 範例： git12345git log --onelinec3d9e28 修正 README 錯字b71c5a2 新增登入驗證功能a84f0d1 新增會員註冊功能9d2a6ff 初始化專案 發現登入驗證功能 (b71c5a2) 有 bug，需要先移除功能 git1git revert b71c5a2 Git 會自動進入編輯器，讓你修改 commit message，通常預設會像這樣： git123Revert &quot;新增登入驗證功能&quot;This reverts commit b71c5a2. 儲存後就會新增一個還原修改的提交了 git123456git log --onelinegak451r Revert &quot;新增登入驗證功能&quot;c3d9e28 修正 README 錯字b71c5a2 新增登入驗證功能a84f0d1 新增會員註冊功能9d2a6ff 初始化專案 健忘筆記 直接使用預設提交訊息，不做任何修改，可以使用 git revert &lt;commit-hash&gt; --no-edit 還原多個提交還原連續提交容易混淆的還原範圍git1git revert &lt;oldest-commit&gt;..&lt;latest-commit&gt; 從 &lt;oldest-commit&gt; 的下一個提交開始到 &lt;latest-commit&gt; 為止，並依序產生「反向 commit」，&lt;oldest-commit&gt; 本身的內容並不會被還原。 範例 git12345git log --onelinec3d9e28 修正 README 錯字b71c5a2 新增登入驗證功能a84f0d1 新增會員註冊功能9d2a6ff 初始化專案 如果執行 git revert a84f0d1..c3d9e28，實際被還原的會是 b71c5a2 和 c3d9e28，而 a84f0d1 並不會被包含在內。 調整還原範圍的寫法因為 &lt;oldest-commit&gt;..&lt;latest-commit&gt; 的範圍並不包含 &lt;oldest-commit&gt;，在實際使用時可能會造成混淆。 如果希望範圍正好是從 &lt;oldest-commit&gt; 到 &lt;latest-commit&gt;（包含 &lt;oldest-commit&gt; 本身），就需要在 &lt;oldest-commit&gt; 後面加上 ^，代表「從這個提交的前一個開始」。 git1git revert &lt;oldest-commit&gt;^..&lt;latest-commit&gt; 範例 git12345git log --onelinec3d9e28 修正 README 錯字b71c5a2 新增登入驗證功能a84f0d1 新增會員註冊功能9d2a6ff 初始化專案 如果執行 git revert a84f0d1^..c3d9e28，實際被還原的就是 a84f0d1 到 c3d9e28。 多個還原合併成一次提交還原多個提交會逐一產生「反向 commit」，如果不希望產生多個 commit，而是想把所有變更合併到一次提交中，可以使用 --no-commit 參數，然後再手動下 git commit git12git revert --no-commit &lt;oldest-commit&gt;^..&lt;latest-commit&gt;git commit -m &quot;Revert commits from &lt;oldest-commit&gt; to &lt;latest-commit&gt;&quot; 範例 git12345git log --onelinec3d9e28 修正 README 錯字b71c5a2 新增登入驗證功能a84f0d1 新增會員註冊功能9d2a6ff 初始化專案 git12git revert --no-commit a84f0d1^..c3d9e28git commit -m &quot;還原到專案初始化的狀態&quot; -m &quot;Revert commits from a84f0d1 to c3d9e28&quot; 健忘筆記 第一個 -m 是提交訊息，第二個 -m 是提交的補充說明，多個 -m 選項會串連成個別段落，詳細說明可察看官方文件 還原非連續提交如果要還原的提交非連續，無法使用範圍操作 git12git revert --no-commit &lt;commit1&gt; &lt;commit2&gt; &lt;commit3&gt;git commit -m &quot;Revert selected commits&quot; 範例 git12345git log --onelineb71c5a2 新增登入驗證功能c3d9e28 修正 README 錯字a84f0d1 新增會員註冊功能9d2a6ff 初始化專案 git12git revert --no-commit a84f0d1 b71c5a2git commit -m &quot;移除會員註冊、登入驗證功能&quot; -m &quot;Revert commits a84f0d1, b71c5a2&quot; git revert 和 git reset 的差異 指令 行為 是否保留歷史 適合場合 git revert 新增一個「撤銷指定 commit」的提交 保留歷史 公開分支、多人協作 git reset 將分支指標移動到指定 commit 改寫歷史 私人分支、尚未 push 的情況 範例 git revert git tree12A - B - C - D (main) ↑ (HEAD) 假設要還原 C，git revert C 後會變成： git tree12A - B - C - D - E (main) ↑ (HEAD) E 這個新 commit 就是「還原 C 的內容」 git reset git tree12A - B - C - D (main) ↑ (HEAD) 執行 git reset B git tree12A - B (main) ↑ (HEAD) 原本的 C 和 D 會直接消失（歷史被改寫） 健忘筆記 還原指令建議 如果專案已經 push 到 GitHub，建議使用 git revert 如果還在本地測試、未 push，可以用 git reset 來清理歷史 結論 語法 作用 git revert --no-commit A..D 還原 B、C、D（不包含 A） git revert --no-commit A^..D 還原 A、B、C、D git revert --no-commit A B C D 手動指定還原 A, B, C, D git revert 適合在多人協作、公開分支上使用，能保留完整歷史並安全還原修改。 如果要還原多個提交，可以 一次指定多個 commit 或 使用範圍語法。 git revert 和 git reset 最大的差異在於是否「改寫歷史」： revert 會新增 commit，保留歷史。 reset 則會刪掉歷史，不適合公開分支。 動手做做看 我建了一個範例 repository，可以 clone 下來後跟著文章操作！git clone https://github.com/forgetfulengineer/git-revert-example.git 延伸閱讀 【Git 官方文件】git revert 介紹 【Git 官方文件】git commit -m 介紹 【Git 官方文件】git reset 介紹","link":"/Other/Git/Git-Revert-Multiple-Commits/"},{"title":"【MySQL】欄位編碼設定影響查詢的大小寫敏感","text":"本篇重點 不同 collation 對查詢的影響 如何確認欄位 collation 設定 collation 的方法 查詢時強制區分大小寫 操作 MySQL 查詢時，有時候會發現輸入的條件大小寫不同卻能查到相同的結果，例如 WHERE name = 'Tom' 與 WHERE name = 'tom' 回傳的內容一樣。這並不是 MySQL 的「錯誤」，而是因為欄位的 collation 可能被設定為大小寫不敏感 (case-insensitive)，導致查詢忽略了大小寫差異。 不同 Collation 對查詢的影響MySQL 中，collation (編碼、排序規則) 影響字串的比較與排序方式，以下是 collation 的重要特性： 是否區分大小寫 (case sensitivity)、是否區分重音 (accent sensitivity) ci → case-insensitive (不區分大小寫)，查詢時 Tom 與 tom 視為相同 bin → binary (以二進位比較，嚴格區分內容)，查詢時 Tom 與 tom 或是 Eric 與 Éric 會被視為不同 語言排序規則 utf8mb4_general_ci → 簡單快速，但會犧牲部分語言正確性 utf8mb4_unicode_ci → 依 Unicode 規範排序，更精準，適合多語言 範例： 不同的 collation 得到不同的結果 sql1234567891011-- utf8mb4_general_ci 大小寫不敏感SELECT * FROM customers WHERE name_ci = 'tom';SELECT * FROM customers WHERE name_ci = 'TOm';-- utf8mb4_bin 區分大小寫SELECT * FROM customers WHERE name_bin = 'tom';SELECT * FROM customers WHERE name_bin = 'Tom';-- 區分重音SELECT * FROM customers WHERE name_ci = 'Eric';SELECT * FROM customers WHERE name_bin = 'Eric'; 動手做做看 不同的 collation 得到不同的結果 是否區分大小寫（case sensitivity） 是否區分重音（accent sensitivity） 動手做做看 如何確認欄位 Collation透過指令檢查欄位的 collation sql12345678-- 查看資料表欄位的 collationSHOW FULL COLUMNS FROM customers;-- 或從 information_schema 查詢SELECT COLUMN_NAME, COLLATION_NAMEFROM information_schema.COLUMNSWHERE TABLE_SCHEMA = 'your_database' AND TABLE_NAME = 'customers'; 動手做做看 透過指令檢查欄位的 collation 動手做做看 設定 Collation哪些欄位需要大小寫敏感？不區分大小寫 (使用 ci) 一般文字內容（標題、文章、備註） 使用者暱稱、搜尋功能中的關鍵字 多語言資料 區分大小寫 (使用 cs 或 bin) 使用者帳號 密碼欄位 Token、驗證碼、序號等需嚴格比對的字串 建立欄位或資料表建立整張資料表指定 Collation sql12345CREATE TABLE customers ( id INT AUTO_INCREMENT PRIMARY KEY, name_ci VARCHAR(50) COLLATE utf8mb4_general_ci, name_bin VARCHAR(50) COLLATE utf8mb4_bin); 新增欄位指定 Collation sql123ALTER TABLE customersADD name_bin2 VARCHAR(50) CHARACTER SET utf8mb4COLLATE utf8mb4_bin; CHARACTER SET 與 COLLATE 要一起指定 動手做做看 建立欄位或資料表設定 collation 建立整張資料表指定 Collation 新增欄位指定 Collation 動手做做看 修改欄位或資料表修改整張資料表指定 Collation sql123ALTER TABLE customersCONVERT TO CHARACTER SET utf8COLLATE utf8_bin; 修改資料表所有文字欄位（VARCHAR、TEXT 等）的 Character Set 與 Collation 修改欄位指定 Collation sql123ALTER TABLE customersMODIFY name_ci VARCHAR(100)COLLATE utf8mb4_general_ci; 動手做做看 修改欄位或資料表設定 collation 修改整張資料表指定 Collation 修改欄位指定 Collation 動手做做看 查詢時強制區分大小寫sql12SELECT * FROM customersWHERE name_ci COLLATE utf8mb4_bin LIKE 'Tom'; 結論MySQL 查詢是否區分大小寫，取決於 collation 的設定。 ci 適合大部分一般文字內容 bin 或 cs 適合帳號、密碼、Token 等需嚴格比對的欄位 不用每個欄位都個別設定，建議在資料庫層級先指定一個通用的 collation，再針對需要區分大小寫的欄位額外調整。 延伸閱讀 【官方文件】命名慣例介紹","link":"/Backend/MySQL/column-collation-case-sensitivity/"},{"title":"【Netlify】環境變數更新無效的除錯流程","text":"本篇重點 Netlify function 更新程式碼後，新設定的環境變數未被正確讀取 檢查環境變數是否設定在正確的環境 (Production / Deploy Preview / Branch deploys) 確認環境變數名稱是否正確 透過 Deploy project without cache 解決問題 問題情境專案架設於 Netlify，並透過 GitHub 連動自動佈署。 更新程式碼後，function 使用新的環境變數，雖然已在 Netlify 後台新增並儲存變數，但程式始終沒有正確讀取。 排查流程確認環境是否正確Netlify 提供不同環境： Production：主要佈署來源，與正式網域綁定 Deploy Preview：針對 PR 產生的測試環境 Branch deploys：針對指定分支的佈署 若環境變數僅設定在 Deploy Preview 或 Branch deploys，Production 可能無法取得。 檢查後確認 Production 已正確設定，並且如果是免費方案的 Netlify 會部屬在全區域，無法設定環境變數部屬區域，只能指定各區域的變數值。 確認環境變數名稱拼字常見錯誤包含： 拼錯大小寫（環境變數區分大小寫） 變數前後多餘空格 後台儲存時沒有正確提交 檢查後確認名稱正確無誤，程式碼與後台設定的環境變數名稱一致。 移除快取重新佈署雖然後台顯示環境變數已更新，但 function 仍未讀到新值。嘗試在佈署頁面選擇：「Trigger deploy → Deploy project without cache」，清除快取後重新佈署。 重新部署並清除快取後，function 成功取得最新環境變數。 為什麼會發生？Netlify 在部署過程中會建立建構快取 (build cache)，其中可能包含舊的環境設定或編譯結果。 當環境變數更新後，如果 Netlify 沒有完全清除快取，舊的變數值可能仍會被沿用，導致新值無法被讀取。 結論這次的問題並非環境變數設定錯誤，是 Netlify function 使用了快取的舊設定。透過清除快取並重新佈署後，function 才正確讀取到新環境變數。 未來遇到類似狀況，可以依照流程依序排查： 確認環境設定位置是否正確 確認拼字無誤 清除快取重新佈署 延伸閱讀 【Netlify 官方文件】環境變數介紹","link":"/Backend/Netlify/Netlify-Env-Variables-Debugging/"},{"title":"【Html】解析 preconnect、preload、Fetch Priority API","text":"本篇重點 資源連線與載入的時間線 縮短首次繪製時間（First Paint）的方法 rel=&quot;preconnect&quot;、rel=&quot;preload&quot;、fetchpriority 的用意與差異 有/無用這些屬性時，載入時間的差異 fetchpriority 與 preload 的差異 crossorigin 屬性的用途與使用時機 onload=&quot;this.rel='stylesheet'&quot; 的動態載入樣式 資源連線與載入的時間線瀏覽器載入網頁時，通常會經歷以下階段： DNS 查詢：查詢網域名稱對應的 IP。 TCP 連線：建立與伺服器的連線。 TLS 握手（HTTPS 時）：建立安全通道。 HTTP 請求與回應：正式請求與接收資源。 解析 HTML → 載入資源（CSS、JS、字型、圖片等）。 若外部資源（例如字型、CSS、圖片）位於不同網域，這三個階段（DNS、TCP、TLS）都要重新建立一次。 因此，若能「提前建立連線」或「提前載入關鍵資源」，就能減少等待時間，縮短「首次繪製時間（First Paint）」。 rel=”preconnect”preconnect 可讓瀏覽器先幫該網域建立連線（包含 DNS、TCP、TLS），後續正式請求資源時，可以直接跳過連線階段，加速載入。 不會下載資源，只提前連線 不會影響 HTML 解析與 DOM 建立流程 適合第三方資源（CDN、字型、API 域名） 差異說明 無使用：瀏覽器碰到真正要下載資源的 HTML/CSS/JS（例如 &lt;link href=&quot;...&quot;&gt;、@font-face 的字型 URL）時，才開始 DNS → TCP → TLS 等連線流程。 有使用：瀏覽器解析到 &lt;link rel=&quot;preconnect&quot; href=&quot;...&quot;&gt;，就會在此階段開始 DNS → TCP → TLS。之後當資源被引用，連線步驟已完成，可以立即發送請求。 範例 Google Fonts 官方載入範例 html12&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin&gt; 健忘筆記 僅對「關鍵第三方域名」使用 preconnect（如字型、主要 CDN、關鍵 API）；濫用會浪費連線資源與瀏覽器配額。 preconnect 對縮短首次網路握手時間最有效，但不會下載任何檔案。 rel=”preload”preload 告訴瀏覽器「這個資源很重要，請優先載入」，即使該資源稍後才會在 CSS 或 JS 中被引用。下載後並不會直接執行資源，只是讓瀏覽器先行下載。 控制載入順序、避免延遲渲染 不會影響 HTML 解析與 DOM 建立流程 適合關鍵字型、首屏圖片等 差異說明 無使用：瀏覽器會在解析到資源引用（例如在 CSS 裡發現 @font-face 或 HTML 中發現 &lt;img&gt; / &lt;link rel=&quot;stylesheet&quot;&gt;）時才下載；若 CSS 在較後才解析，資源下載會被延後。 有使用：在瀏覽器解析 &lt;link rel=&quot;preload&quot; href=&quot;...&quot; as=&quot;...&quot;&gt; 那一刻就開始下載該資源，因此能顯著縮短關鍵資源的可用時間。 範例 html html1&lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/foo.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin /&gt; 健忘筆記 preload 需要正確的 as（例如 as=”font”、as=”style”、as=”image”），錯誤會導致瀏覽器無法正確處理緩存與優先權。 跨來源的字型資源通常需要 crossorigin 才能成功載入並使用 Fetch Priority APIHTML5 新增的屬性，允許開發者為單一資源標記優先順序（high、low、auto），讓瀏覽器在其內部的排程中更傾向先下載或後下載該資源，但瀏覽器可能根據自身策略（例如當前網路情況、連線數量、瀏覽器內部優化、節能模式等）決定是否完全遵從 。 控制資源載入優先順序 適用於關鍵圖片、主樣式表、首屏腳本等 常用於 &lt;img&gt;、&lt;link&gt;、&lt;script&gt; 瀏覽器載入優先級（Chrome） 優先度 資源類型 備註 Highest HTML、CSS、fonts 首屏必要資源 High 主程式 script、defer script、首屏圖片（in-viewport） 主要邏輯與畫面 Medium 一般 script（例如次要互動） 非立即需要 Low async script、lazyload 圖片/影音 非同步載入、不影響首屏 Lowest prefetch、非當前頁面資源 未來可能用到 健忘筆記 優先度決定「當多個資源在候補要下載時，哪個先被拿到網路資源」，詳細可查看【wev.dev】了解 Fetch Priority API 差異說明 無使用：照原瀏覽器載入順序下載資源 有使用：影響該資源在下載排程的優先順序 範例 html12&lt;img src=&quot;/hero.webp&quot; fetchpriority=&quot;high&quot; alt=&quot;Main Banner&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/main.css&quot; fetchpriority=&quot;high&quot;&gt; 提醒瀏覽器「這個資源對渲染很重要」，應該盡早下載 相反地，背景圖片、懸浮區塊可標註為 fetchpriority=&quot;low&quot;，節省頻寬 與 preload 差異： preload 是「強制提前下載」 fetchpriority 是「建議調整優先權」 項目 fetchpriority &lt;link rel=&quot;preload&quot;&gt; 是否強制下載 不會強制（僅建議） 強制瀏覽器預先載入資源 適用資源 任何可下載資源（img, script, css, font） 通常用於關鍵字體、CSS、首屏圖片 時機差異 等瀏覽器解析到資源時才決定下載順序 在解析 HTML 初期就主動開始下載 是否影響渲染 不直接影響渲染，只影響載入排序 可顯著縮短首屏渲染時間 動態載入樣式可讓瀏覽器延遲樣式表的應用，避免同步的 CSS 阻塞初始渲染。 使用 rel=&quot;preload&quot; 先下載 CSS，但不立即套用 當 onload 觸發後，再將 rel 改為 &quot;stylesheet&quot;，瀏覽器才正式套用樣式 避免 render-blocking 常用於「非關鍵 CSS」 範例： html12&lt;link rel=&quot;preload&quot; href=&quot;/css/print.css&quot; as=&quot;style&quot; onload=&quot;this.onload=null;this.rel='stylesheet'&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/print.css&quot;&gt;&lt;/noscript&gt; 說明： onload=null 避免載入後重複觸發事件 &lt;noscript&gt; 提供給沒有 JS 環境的用戶 可避免 CSS 阻塞渲染（Render-blocking），提升 LCP（Largest Contentful Paint） crossorigin 屬性的用途與時機給需要使用 CORS（Cross-Origin Resource Sharing）驗證的資源，不是所有跨源資源都需要使用 crossorigin。 值 說明 anonymous 不帶憑證（cookies、授權資訊）。 use-credentials 帶憑證發送請求。 使用時機： 字型、圖片、影片、JS 來自不同網域時。 需要通過 CORS 驗證的資源（否則會被視為失敗）。 範例： html12// 字型檔屬於「需要 CORS 驗證」的資源&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin&gt; 結論preconnect、preload、fetchpriority 是優化前端中互補的三個屬性： preconnect：提前連線，解決「網路握手延遲」，不下載資源，適合重要的第三方域名。 preload：提前下載，解決「關鍵資源延後載入」，適合關鍵字型／圖片效果顯著。 fetchpriority：精細調整優先權，解決「資源搶占頻寬問題」，是建議而非強制。 整體而言，這些屬性的目的都是讓「瀏覽器提早行動」，減少等待，提升用戶的載入體驗，但也要控制使用數量與範圍，避免造成頻寬壅塞或預載過多無效資源的問題。 延伸閱讀 【MDN】rel=preconnect 介紹 【MDN】rel=preload 介紹 【wev.dev】了解 rel=preconnect 和 rel=dns-prefetch 【wev.dev】了解 Fetch Priority API 【MDN】瀏覽器渲染流程","link":"/Frontend/Html/Analyzing-Preconnect-Preloading-Fetch-Priority/"}],"tags":[{"name":"php","slug":"php","link":"/tags/php/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"git bash","slug":"git-bash","link":"/tags/git-bash/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"system","slug":"system","link":"/tags/system/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"timestamp","slug":"timestamp","link":"/tags/timestamp/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"ga","slug":"ga","link":"/tags/ga/"},{"name":"netlify","slug":"netlify","link":"/tags/netlify/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"}],"categories":[{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"PHP","slug":"Backend/PHP","link":"/categories/Backend/PHP/"},{"name":"MySQL","slug":"Backend/MySQL","link":"/categories/Backend/MySQL/"},{"name":"Git","slug":"Other/Git","link":"/categories/Other/Git/"},{"name":"VSCode","slug":"Other/VSCode","link":"/categories/Other/VSCode/"},{"name":"Linux","slug":"Backend/Linux","link":"/categories/Backend/Linux/"},{"name":"Hexo","slug":"Other/Hexo","link":"/categories/Other/Hexo/"},{"name":"Css","slug":"Frontend/Css","link":"/categories/Frontend/Css/"},{"name":"Html","slug":"Frontend/Html","link":"/categories/Frontend/Html/"},{"name":"JQuery","slug":"Frontend/JQuery","link":"/categories/Frontend/JQuery/"},{"name":"GitHub","slug":"Other/GitHub","link":"/categories/Other/GitHub/"},{"name":"JavaScript","slug":"Frontend/JavaScript","link":"/categories/Frontend/JavaScript/"},{"name":"NPM","slug":"Other/NPM","link":"/categories/Other/NPM/"},{"name":"Tool","slug":"Other/Tool","link":"/categories/Other/Tool/"},{"name":"API","slug":"Backend/API","link":"/categories/Backend/API/"},{"name":"Netlify","slug":"Backend/Netlify","link":"/categories/Backend/Netlify/"}],"pages":[{"title":"404 - 網頁不存在","text":"var redirects = { \"/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/\": \"/Backend/PHP/4-Ways-to-Check-If-a-Variable-or-Array-Exists/\", \"/VSCode/Using-Git-Bash-in-VSCode/\": \"/Other/VSCode/Using-Git-Bash-in-VSCode/\", \"/Backend/MySQL/Execution-Order-and-Performance-Optimization-of-DQL-Commands/\": \"/Backend/MySQL/DQL-Execution-Order/\", }; var path = window.location.pathname; if (redirects[path]) { window.location.replace(redirects[path]); } 這是一個不存在的頁面 抱歉，找不到你要的頁面 😢將在 5 秒後返回首頁。 let countTime = 5; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if (countTime === 0) { location.href = 'https://forgetfulengineer.github.io'; } setTimeout(() => { count(); }, 1000); } count();","link":"/404.html"},{"title":"【HTML】解析 &lt;a&gt; 的 rel 屬性 - window.opener 惡意連結實例","text":"原視窗重新導向到首頁如果帶有 target=&quot;_blank&quot; 的連結沒有加上 rel 的 noopener 屬性，新視窗可以使用 window.opener 控制原視窗重新導向指定網址。 js12// 原視窗重新導向到首頁window.opener.location.href = &quot;https://forgetfulengineer.github.io/&quot;; 開啟原視窗的 alert如果帶有 target=&quot;_blank&quot; 的連結沒有加上 rel 的 noopener 屬性，新視窗可以使用 window.opener 開啟原視窗的 alert。 js12// 開啟原視窗的 alertwindow.opener.alert('你點到惡意連結了'); 操作原視窗的 DOM如果帶有 target=&quot;_blank&quot; 的連結沒有加上 rel 的 noopener 屬性，新視窗可以使用 window.opener 操作原視窗的 DOM。 js12// 操作原視窗的 DOMwindow.opener.document.querySelector('body').innerHTML='&lt;b style=&quot;color: red; font-size: 100px; margin: auto;&quot;&gt;你點到惡意連結了&lt;/b&gt;'; 健忘筆記 現代瀏覽器在大部分情況下已經自動為帶有 target=&quot;_blank&quot; 的連結加上 rel=&quot;noopener&quot;，所以有沒有設定 noopener 使用 window.opener 都會得到 null，但為了確保相容性和覆蓋到所有情況，依然建議明確地設定 rel=&quot;noopener&quot;。 😈 惡意連結實例 原視窗重新導向到首頁 開啟原視窗的 alert 操作原視窗的 DOM 回到原文章 let urlParams = new URLSearchParams(window.location.search); let example = (['1', '2', '3'].includes(urlParams.get('example'))) ? urlParams.get('example') : 1; let element = document.querySelector(\".example-\" + example); element.classList.remove(\"is-hidden\"); switch (example) { case '1': default: window.opener.location.href = \"https://forgetfulengineer.github.io/\"; break; case '2': window.opener.alert('你點到惡意連結了'); break; case '3': window.opener.document.querySelector('body').innerHTML='你點到惡意連結了'; break; }","link":"/example/Malicious-Links-Using-window-opener.html"},{"title":"Cookie Policy","text":"甚麼是 cookie?Cookie 是由網站儲存在使用者瀏覽器中的小型文字檔案，用於在不同的頁面或訪問之間存儲數據。它們主要用來保存使用者資訊，以便在使用者再次訪問網站時提供個性化的體驗。 更詳細的說明可查看 【資安趨勢部落格】cookie 介紹 在哪裡使用 cookie本網站使用了一些第三方服務 Google Analytics : 用來紀錄訪客數據 Twikoo 評論系統 : 用來讓訪客回覆，紀錄訪客資訊 (名稱、信箱等) 禁用 cookie您可以經由瀏覽器的設定，取消或限制 cookie (操作方式請至瀏覽器幫助查詢)，但我並不建議您禁用 cookie，禁用可能會導致您喪失網站的一些功能。","link":"/cookie-policy/index.html"}]}